{
  "structure": [
    {
      "originalPath": "1. Release Note",
      "name": "Release Note",
      "path": "release-note",
      "type": "folder",
      "children": [
        {
          "originalPath": "tsfsd.md",
          "id": 1,
          "name": "Tsfsd",
          "type": "file",
          "path": "release-note/tsfsd",
          "content": "tsrfc\nInstallation\nConfiguration\nLogger Function\n"
        }
      ]
    },
    {
      "originalPath": "2. Need to know.md",
      "id": 2,
      "name": "Need To Know",
      "type": "file",
      "path": "need-to-know",
      "content": "## Compatibility\n\n- params (`:id`)\n- wildcard (`/*path` or `/*`)\n- optional params (`/:id?`)\n\n### 1. Router\n\n- not support directly wildcard and optional params. (use `basePath` ‚úÖ)\n\n```ts\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n### 2. Overwritten router (method)\n\n- Method will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n- not found Handler will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n\n```ts\n// ‚ùå Conflicting routes\n// ‚ùì Will be overwritten by the last handler.\n// Output: {name: \"Jhon\"}\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/:name\", handleByName); // Will execute be reached\n\n// ‚úÖ Solution: Use distinct paths\napp.get(\"/users/id/:id\", handleUser);\napp.get(\"/users/name/:name\", handleByName);\n```\n\n### 3. Matching Priority\n\nRoutes are matched with following priority order:\n\n1. Static paths (`/users/list`)\n2. Named parameters (`/users/:id`)\n3. Wildcard parameters (`/users/*`)\n4. Optional parameters (`/users/:id?`)\n\n## **4. ‚ö†Ô∏è Critical Implementation Note**\n\n**Sub-router groups require explicit rule declaration:**\n\nInside sub-router each group (middleware ) act as a independence middleware.\nSo, like parent(sub-router) again add middlewareRule same as parent(sub-router)\n\n```typescript\n// ‚úÖ Correct Implementation\nconst userRouter = new Router();\nuserRouter.group(\"/users\", { middlewareRule: \"follow\" }, (group) => {\n  group.use(loggerMiddleware);\n  group.get(\"/:id\", getUser);\n});\n\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n\n// ‚ùå Incorrect Implementation\nconst userRouter = new Router();\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n\nuserRouter.group(\"/users\", (group) => {\n  // MiddlewareRule not set here - will not inherit parent rule\n});\n```\n\n### **‚ùå Incorrect Approach**\n\nAlways attach the middleware rule before declaring the group.\n\n```typescript\nconst userRouter = new Router();\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n\n//‚ùå This won't work because it's declared after router addition\nuserRouter.group(\"\", { middlewareRule: \"follow\" }, (group) => {\n  group.use(function test(ctx, next) {\n    console.log(\"inside user group\");\n    return next();\n  });\n\n  group.delete(\"/users/:id\", async (ctx) => {\n    return ctx.json({ message: `User ID ${ctx.req.params.id} Deleted` });\n  });\n});\n\n// ‚úÖ Correct Implementation\nconst userRouter = new Router();\nuserRouter.group(\"\", { middlewareRule: \"follow\" }, (group) => {\n  group.use(function test(ctx, next) {\n    console.log(\"inside user group\");\n    return next();\n  });\n\n  group.delete(\"/users/:id\", async (ctx) => {\n    return ctx.json({ message: `User ID ${ctx.req.params.id} Deleted` });\n  });\n});\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n```\n"
    },
    {
      "originalPath": "3. Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Installation.md",
          "id": 3,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "# **TezX Installation** üì¶\n\n---\n\n## **Installation Steps** üöÄ\n\n### 1. **Create New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### 2. **Install TezX Framework**\n\n- npm\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n### 3. **Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ server.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## **Environment Configuration** ‚öôÔ∏è\n\n### 1. **Create `.env` File**\n\n```env\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n## **Basic Server Setup** üíª\n\n### 1. **Create `src/server.ts`**\n\n```typescript\nimport { TezX, loadEnv, logger, nodeAdapter } from \"tezx\";\n\nconst env = loadEnv();\n\nconst server = new TezX({\n  logger: logger,\n  env: env,\n});\n\nserver.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n### 2. **Add TypeScript Support (Optional)**\n\n```bash\nnpm install typescript @types/node ts-node-dev --save-dev\n```\n\n**`tsconfig.json`**\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n\n---\n\n## **Running the Server** ‚ñ∂Ô∏è\n\n### **Development Mode (Hot Reload)**\n\n```bash\nnpx ts-node-dev --respawn src/server.ts\n```\n\nor use nodemon with ts-node\n\n```bash\nnodemon src/server.ts\n```\n\n### **Production Build**\n\n```bash\nnpm run build && node dist/server.js\n```\n\n**Add to `package.json`**\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"ts-node-dev --respawn src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\"\n  }\n}\n```\n\n---\n\n## **Advanced Configuration** üîß\n\n### 1. **Add Static File Support**\n\n```typescript\nserver.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\n```typescript\nimport { cors } from \"tezx/middleware\";\n\nserver.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\n```typescript\nserver.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## **Troubleshooting** üö®\n\n### **Common Issues**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\n**Happy Coding!** üöÄ\n"
        },
        {
          "originalPath": "2. Configuration.md",
          "id": 4,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": ""
        },
        {
          "originalPath": "6. Node.md",
          "id": 5,
          "name": "Node",
          "type": "file",
          "path": "getting-started/node",
          "content": "\n### **Node.js Configuration with TezX**\n\n### **Running the Server**\n\n1. Install `TezX`:\n\n```bash\n   npm install TezX\n```\n\n2. Save the code in a file (e.g., `index.js`).\n\n3. Run:\n\n```bash\nnode index.js\n```\n\n4. Test endpoints like `http://localhost:3001/products`.\n\n### **Example**\n\n```javascript\n// Import necessary modules from TezX\nimport { loadEnv, logger, nodeAdapter, Router, TezX } from \"TezX\";\n\n// Load environment variables (e.g., from a .env file)\nconst env = loadEnv();\n\n// Initialize the TezX application with configuration\nconst app = new TezX({\n  logger: logger,         // Built-in logger for request/response logging\n  env: env,              // Environment variables for configuration\n  allowDuplicateMw: true // Allows duplicate middleware registration\n});\n\n// **Product Routes**\n\n// Initialize a new Router instance for product-related routes\nconst productRouter = new Router({});\n\n// Group product routes with shared middleware\nproductRouter.group(\"\", (group) => {\n  // Middleware applied to all routes in this group\n  group.use((ctx, next) => {\n    console.log(\"inside router\"); // Log for debugging\n    return next();                // Proceed to next middleware/handler\n  });\n\n  // GET /products - Returns an empty JSON object\n  group.get(\"/products\", async (ctx) => {\n    return ctx.json({});\n  });\n});\n\n// GET /products/:id - Fetch product by ID\nproductRouter.get(\"/products/:id\", async (ctx) => {\n  return ctx.json({ message: `Product ID: ${ctx.req.params.id}` });\n});\n\n// POST /products - Create a new product\nproductRouter.post(\"/products\", async (ctx) => {\n  const productData = await ctx.req.json(); // Parse request body\n  return ctx.json({ message: \"Product Created\", data: productData });\n});\n\n// PUT /products/:id - Update a product by ID\nproductRouter.put(\"/products/:id\", async (ctx) => {\n  return ctx.json({ message: `Product ID ${ctx.req.params.id} Updated` });\n});\n\n// DELETE /products/:id - Delete a product by ID\nproductRouter.delete(\"/products/:id\", async (ctx) => {\n  return ctx.json({ message: `Product ID ${ctx.req.params.id} Deleted` });\n});\n\n// Mount the productRouter at the root path \"/\"\napp.use(\"/\", productRouter);\n\n// Start the server using the Node.js adapter\nnodeAdapter(app).listen(3001, () => {\n  console.log(\"Server running on port 3001\");\n});\n```\n\n### **Sample Requests**\n\n| Method | Path                | Response                                  |\n|--------|---------------------|-------------------------------------------|\n| GET    | `/products`         | `{}`                                     |\n| GET    | `/products/123`     | `{\"message\": \"Product ID: 123\"}`         |\n| POST   | `/products`         | `{\"message\": \"Product Created\", \"data\": {...}}` |\n| PUT    | `/products/123`     | `{\"message\": \"Product ID 123 Updated\"}`  |\n| DELETE | `/products/123`     | `{\"message\": \"Product ID 123 Deleted\"}`  |\n\n---\n\n### **Key Notes**\n\n- The `allowDuplicateMw: true` setting still allows duplicate middleware within the `productRouter` group if added multiple times.\n- The middleware `console.log(\"inside router\")` applies to all routes in the group (e.g., `/products`).\n- The server runs on port `3001` as before.\n\n---\n"
        },
        {
          "originalPath": "7. Bun.md",
          "id": 6,
          "name": "Bun",
          "type": "file",
          "path": "getting-started/bun",
          "content": ""
        },
        {
          "originalPath": "8. Deno.md",
          "id": 7,
          "name": "Deno",
          "type": "file",
          "path": "getting-started/deno",
          "content": ""
        }
      ]
    },
    {
      "originalPath": "5. API",
      "name": "API",
      "path": "api",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Middleware API",
          "name": "Middleware API",
          "path": "api/0-middleware-api",
          "type": "folder",
          "children": [
            {
              "originalPath": "0. Basic.md",
              "id": 8,
              "name": "Basic",
              "type": "file",
              "path": "api/middleware-api/basic",
              "content": "## **üöÄ Merging Middlewares**\n\nThe `mergeMiddleware` function effectively integrates nested middlewares from a new router into the parent router structure. This approach mirrors the way routing systems merge nested routers, ensuring efficient handling of middleware arrays while respecting configurations such as `allowDuplicateMw`.\n\n---\n\n#### **1Ô∏è‚É£ Before Merging**\n\nInitial state of the `RootMiddlewares` router:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Contains middleware `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n#### **2Ô∏è‚É£ New RouterMiddlewares (To Merge)**\n\nMiddleware structure from a new router to be merged:\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Contains middleware `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n#### **3Ô∏è‚É£ After Merging**\n\nResulting structure of `RootMiddlewares` router after merging:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  <-- Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  <-- New Middleware Added\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are merged into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: A new child route with middleware `[m4]` added.\n\n---\n\n### **üîß Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option governs whether duplicate middleware functions are allowed during merging or registration.\n\n```typescript\n/**\n * `allowDuplicateMw` determines whether duplicate middleware functions\n * are allowed in the router.\n *\n * - When `true`: Allows the same middleware to be added multiple times.\n * - When `false`: Ensures each middleware is registered only once\n *   per route or application context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n#### **Usage**\n\n```typescript\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middlewares\n  overwriteMethod: false, // Preserves existing method handlers\n});\n```\n\n#### **Behavior**\n\n- **`allowDuplicateMw: true`**:\n\n  - Middlewares can be registered multiple times for the same route, allowing duplicates.\n  - Example after merging with duplicates:\n\n    ```plaintext\n    RootMiddlewares\n     ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n     ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  <-- Duplicates Permitted\n    ```\n\n- **`allowDuplicateMw: false`** (default):\n\n  - Duplicates are filtered out, ensuring no repetition in the middleware array.\n  - Example after merging:\n\n    ```plaintext\n    RootMiddlewares\n     ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n     ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  <-- No Duplicates\n    ```\n\n---\n\n### **üîë Key Takeaways**\n\n- ‚úÖ **Merges Middleware at the Same Path**: When paths match (e.g., `/test`), middleware arrays are combined, respecting `allowDuplicateMw`.\n- ‚úÖ **Recursively Merges Nested Middleware**: Child routes (e.g., `/test/2`) are recursively added or merged into the router.\n- ‚úÖ **Memory Optimization**: After merging, middleware arrays are cleared (`middlewares.length = 0`), and child nodes are cleared (`children.clear()`) to optimize memory usage.\n\n---\n\n### **üåü Final Summary**\n\n- **Recursive Approach**: The function uses a recursive strategy to merge nested middlewares, ensuring all levels of the route tree are handled.\n- **Memory Optimization**: Efficient memory usage is achieved by resetting unused arrays and child collections after the merge.\n\n---\n\n### **Example**\n\n#### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n#### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n#### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  <-- Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  <-- New Child Middleware\n```\n\nWith `allowDuplicateMw: true`, adding `rateLimiter` again to `/api/users` would result in `[authMiddleware, rateLimiter, rateLimiter]`.\n\n---\n"
            },
            {
              "originalPath": "2. Middleware.md",
              "id": 9,
              "name": "Middleware",
              "type": "file",
              "path": "api/middleware-api/middleware",
              "content": "# **Middleware Guide**\n\nMiddleware allows handling requests before they reach the final route handler. It can be used for authentication, logging, rate limiting, etc.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\n```typescript\ntype Middleware<T> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => NextCallback | Promise<TezResponse> | TezResponse;\n```\n\n- **Purpose**: Defines middleware that processes requests and optionally calls the next middleware or handler in the chain.\n- **Parameters**:\n  - `ctx`: The request context, typed with custom properties via `T`.\n  - `next`: A callback to invoke the next middleware or handler.\n- **Returns**: Either `next()` (to continue the chain), a `TezResponse`, or a `Promise<TezResponse>`.\n\n**Example**:\n\n```typescript\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  return next(); // Proceed to next middleware or handler\n};\n```\n\n### **2. `Callback<T>`**\n\n```typescript\ntype Callback<T> = (ctx: ctx<T>) => Promise<TezResponse> | TezResponse;\n```\n\n- **Purpose**: Defines a final request handler that does not invoke `next`.\n- **Parameters**:\n  - `ctx`: The request context.\n- **Returns**: A `TezResponse` or `Promise<TezResponse>`.\n\n**Example**:\n\n```typescript\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n### **3. `ctx<T>`**\n\n```typescript\ntype ctx<T = {}> = Context<T> & T;\n```\n\n- **Purpose**: A flexible context object combining framework-provided properties (e.g., `req`, `json`) with custom user-defined properties via `T`.\n- **Example**:\n\n```typescript\ninterface AuthContext {\n  user: User;\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.headers.get(\"Authorization\"));\n  return next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                          |\n| --------------------- | ------------------------------- | ------------------------------------ |\n| **Path + Middleware** | `.use('/api', auth)`            | Applies middleware to `/api` routes  |\n| **Path + Multiple**   | `.use('/admin', [auth, audit])` | Chains multiple middleware for path  |\n| **Path + Callback**   | `.use('/v1', v1Router)`         | Mounts a sub-router at `/v1`         |\n| **Global Middleware** | `.use(logger)`                  | Applies middleware to all routes     |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```typescript\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```typescript\nserver\n  .use(\"/api\", apiRateLimiter) // Rate limiting for /api routes\n  .group(\"/api\", (group) => {\n    group.use(authMiddleware); // Authentication for /api sub-routes\n    group.get(\"/data\", fetchDataHandler);\n  });\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```typescript\nserver.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array for uploads\n  uploadRouter, // Sub-router for upload routes\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in the order of registration, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\nRegister global middleware first, followed by path-specific middleware and handlers.\n\n```typescript\nserver\n  .use(requestID) // Assigns unique request IDs\n  .use(logger) // Logs requests\n  .use(errorHandler); // Catches errors last\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```typescript\n  server.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Specify exact paths.\n\n  ```typescript\n  server.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\nLeverage TypeScript generics for type-safe context extensions.\n\n```typescript\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\nserver.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n  return next();\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```typescript\nserver.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```typescript\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\nserver.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```typescript\nserver.post(\n  \"/submit\",\n  bodyParser(),\n  validateSchema(submitSchema),\n  submitHandler,\n);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place sync middleware before async to minimize overhead.\n\n   ```typescript\n   server\n     .use(syncOperation) // Fast, synchronous\n     .use(asyncMiddleware); // Slower, asynchronous\n   ```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Move intensive tasks (e.g., file processing) to handlers.\n\n   ```typescript\n   // ‚ùå Avoid in middleware\n   await processLargeFile();\n\n   // ‚úÖ Use in handler\n   server.get(\"/process\", (ctx) => processLargeFile());\n   ```\n\n3. **Cache Repeated Operations**\n\n   - Store results of expensive computations in the context.\n\n   ```typescript\n   server.use((ctx, next) => {\n     ctx.cachedData = expensiveOperation();\n     return next();\n   });\n   ```\n\n---\n\n## **Error Reference**\n\n| Error Pattern                                 | Solution                                                  |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware matches `(ctx, next) => ...` signature  |\n| Missing `next()` call                         | Return `next()` or a `TezResponse` explicitly             |\n| Type mismatches in `ctx`                      | Check generic type `T` aligns with middleware and handler |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "1. Router",
          "name": "Router",
          "path": "api/1-router",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Basic.md",
              "id": 10,
              "name": "Basic",
              "type": "file",
              "path": "api/router/basic",
              "content": "# **Router with Merging**\n\n---\n\n## **Overview of Routing**\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: A new routing structure to be merged into the parent router.\n- **Final Router**: The resulting structure after merging.\n\n---\n\n## **Example: Before Merge**\n\nHere‚Äôs an example of a parent router before any merging occurs:\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test` (root node) has a `GET` handler (`handler1`).\n- `/test/1` (child node) has its own `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\nA new sub-router can be merged into the parent router. Here‚Äôs an example of a new router to merge:\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2` has a `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\nWhen the new sub-router is merged into the parent router, the resulting structure depends on the merge logic and configuration (e.g., `overwriteMethod`). Here‚Äôs an example of the final router:\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- The `/test` branch remains unchanged.\n- The `/products` branch is added as a new root-level node with its child `/products/2`.\n\n**Note**: If the new sub-router had overlapping paths (e.g., `/test` instead of `/products`), the behavior would depend on the `overwriteMethod` setting (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option controls how `TezX` handles overlapping routes‚Äîi.e., when a new handler is added for the same path and HTTP method as an existing handler.\n\n### **Definition**\n\n```typescript\n/**\n * `overwriteMethod` controls whether existing route handlers\n * should be overwritten when a new handler for the same\n * HTTP method and path is added.\n *\n * - When `true`: The new handler replaces the existing one.\n * - When `false`: Prevents overwriting, ensuring that the\n *   first registered handler remains active.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```typescript\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware, if applicable\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n- **`overwriteMethod: true` (default)**:\n  - If a new `GET` handler is added to `/test` and a `GET` handler already exists, the new handler overwrites the old one.\n  - Example:\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n- **`overwriteMethod: false`**:\n  - The existing handler is preserved, and the new handler is ignored.\n  - Example:\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**: Sub-routers can be merged into the parent router without disrupting unrelated routes.\n2. **Overlapping Control**: Use `overwriteMethod` to decide how overlapping routes are handled.\n3. **Nested Routes**: Child nodes allow for deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Best Practices**\n\n- Set `overwriteMethod: false` in production environments to prevent accidental overwriting of critical handlers.\n- Use descriptive handler names or logging to debug route conflicts.\n- Test merged router thoroughly to ensure the final structure matches your expectations.\n\n---\n"
            },
            {
              "originalPath": "2. Router.md",
              "id": 11,
              "name": "Router",
              "type": "file",
              "path": "api/router/router",
              "content": "# Router API\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\n**Hierarchical routing system with middleware support**\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes          |\n| **Middleware Chain** | Sequential execution of pre/post processors   |\n| **Path Isolation**   | Routes inherit parent path prefix             |\n| **Type Propagation** | Maintain typed context through nested routers |\n\n---\n\n### **2. Middleware System**\n\n#### **Execution Flow**\n\n```js\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **2. Route Groups**\n\n#### Logical grouping of routes with shared configuration\n\n```ts\napp.group(\"/admin\", (group) => {\n  // Shared middleware for admin routes\n  group.use(adminAuth, auditLogger);\n\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\n#### Mount sub-router with path prefix\n\n| Parameter | Type     | Description                            |\n| --------- | -------- | -------------------------------------- |\n| `path`    | `string` | Base path for all routes in sub-router |\n| `router`  | `Router` | Configured router instance             |\n\n**Example:**\n\n```ts\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount under /auth prefix\n// ‚ùå not support middleware chain. Please use app.use(....)\napp.addRouter(\"/auth\", authRouter);\n// or\n//‚úÖ It support middleware chain\napp.use(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n```ts\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// ‚ùå not use wildcard\n// Mount under /auth prefix\napp.addRouter(\"/auth/*\", authRouter);\n// or\n// ‚ùå not use wildcard\napp.use(\"/auth/*\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n```ts\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// ‚ùå not use optional params\n// Mount under /auth prefix\napp.addRouter(\"/auth/:version?\", authRouter);\n// or\n// ‚ùå not ues optional params\napp.use(\"/auth/auth/:version?\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n**Note** : If you `app.use` or `app.addRouter` with path pass a new Router path must be static or dynamic params.(not use wildcard and optional params)\n\nIf you want to use wildcards or optional parameters in the router:\n\n```ts\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\n**Support dynamic params, optional params, wildcard**\n**Create scoped route group**\n\n| Parameter  | Type       | Description                             |\n| ---------- | ---------- | --------------------------------------- |\n| `prefix`   | `string`   | Path segment for group                  |\n| `callback` | `function` | Receives group-specific router instance |\n\n**Advanced Example:**\n\n```ts\napp.group(\"/api/v1\", (group) => {\n  // Group-level middleware\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n\n// Resulting paths:\n// /api/v1/users/123\n// /api/v1/posts/456\n```\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\n```ts\n// Global middleware (applies to all routes)\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n### **2. Context Propagation**\n\n**Type-safe context inheritance:**\n\n```ts\ninterface CustomContext {\n  user?: User;\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  // ctx is typed as CustomContext\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found**\n\n**Type-safe context inheritance:**\n\n```ts\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n`notFound` handler will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n\n---\n\n### **3. Error**\n\n**Type-safe context inheritance:**\n\n```ts\napp.onError((error, ctx) => {\n  return ctx.text(error, 500);\n});\n```\n\n`onError` handler will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\n```bash\nroutes/\n‚îú‚îÄ auth/\n‚îÇ  ‚îú‚îÄ login.ts\n‚îÇ  ‚îú‚îÄ logout.ts\n‚îú‚îÄ api/\n‚îÇ  ‚îú‚îÄ v1/\n‚îÇ  ‚îÇ  ‚îú‚îÄ users.ts\n‚îÇ  ‚îú‚îÄ v2/\n‚îÇ     ‚îú‚îÄ users.ts\n```\n\n---\n\n<!--\n## **Configuration Options**\n\n```ts\nnew Router({\n  caseSensitive: false, // /Users vs /users\n  strictPaths: true,    // /users/ vs /users\n  maxNesting: 5,        // Prevent infinite loops\n  autoHead: true        // Auto-create HEAD routes\n});\n``` -->\n"
            },
            {
              "originalPath": "3. Route Parameter.md",
              "id": 12,
              "name": "Route Parameter",
              "type": "file",
              "path": "api/router/route-parameter",
              "content": "---\n## Parameter Types\n\n### 1. Standard Parameters (`:param`)\n\nCapture dynamic path segments between slashes\n\n**Syntax:**\n\n```typescript\n\"/path/:parameterName\"\n```\n\n**Examples:**\n\n```ts\napp.get(\"/users/:id\", (ctx) => {\nctx.params.id // => \"123\" from /users/123\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\nctx.params.year  // => \"2023\"\nctx.params.month // => \"09\"\n});\n```\n\n**Characteristics:**\n\n- Mandatory path segments\n- Match until next `/` character\n- Must appear in order declared\n---\n\n### 2. Optional Parameters (`:param?`)\n\nMatch segments that may or may not exist\n\n**Syntax:**\n\n```typescript\n\"/path/:optionalParam?\";\n```\n\n**Examples:**\n\n```ts\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // Matches:\n  // - /archive/2023/08 => year: \"2023\", month: \"08\"\n  // - /archive/2023     => year: \"2023\", month: undefined\n  // - /archive          => year: undefined, month: undefined\n});\n```\n\n**Characteristics:**\n\n- Can be omitted from request\n- Must be sequential at end of path\n- Intermediary optional params require subsequent params to also be optional\n\n---\n\n### 3. Wildcard Parameters (`*`)\n\nCapture all remaining path segments\n\n**Syntax:**\n\n```typescript\n\"/path/*wildcardParam\";\n```\n\n**Examples:**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg =>\n  // ctx.params.path = \"images/2023/photo.jpg\"\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints =>\n  // ctx.params.category = \"api/v2/endpoints\"\n});\n```\n\n**Characteristics:**\n\n- Always returns string (never undefined)\n- Must be final segment in route\n- Matches all remaining path segments\n- Supports nested directory structures\n\n---\n\n## Matching Priority\n\nRoutes are matched with following priority order:\n\n1. Static paths (`/users/list`)\n2. Named parameters (`/users/:id`)\n3. Wildcard parameters (`/users/*`)\n4. Optional parameters (`/users/:id?`)\n\n**Example Hierarchy:**\n\n```ts\napp.get(\"/users/list\", handleList); // Highest priority\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll); // Lowest priority\n```\n\n---\n\n## Parameter Access\n\nCaptured parameters are available in `ctx.req.params`:\n\n```ts\ninterface Params {\n  [key: string]: string | undefined;\n}\n\n// Example usage:\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string\n  // item: string | undefined\n});\n```\n\n---\n\n## Conflict Resolution\n\n### Ambiguous Routes\n\n```ts\n// ‚ùå Conflicting routes\n// ‚ùì Will be overwritten by the last handler.\n// Output: {name: \"Jhon\"}\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/:name\", handleByName); // Will execute be reached\n\n// ‚úÖ Solution: Use distinct paths\napp.get(\"/users/id/:id\", handleUser);\napp.get(\"/users/name/:name\", handleByName);\n```\n\n### Wildcard Position\n\n```ts\n// ‚ùå Invalid wildcard placement\napp.get(\"/*/profile\", handleProfile);\n\n// ‚úÖ Valid usage\napp.get(\"/user/*/profile\", handleProfile); // Static segment before wildcard\n```\n\n---\n\n## Escaping Special Characters\n\nTo match literal `:` or `*`, escape with backslash:\n\n```ts\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n});\n```\n\n---\n\n## Best Practices\n\n1. **Order Routes by Specificity:** Place static routes before dynamic ones\n2. **Validate Parameters:** Always sanitize and validate parameter values\n3. **Use Optional Sparingly:** Prefer explicit routes for better visibility\n4. **Document Complex Routes:** Add comments for routes with multiple parameters\n5. **Limit Wildcard Scope:** Use specific patterns before wildcards when possible\n\n```ts\n// Good practice example\napp.get(\"/api/v1/:version/:resource\", (ctx) => {\n  const version = parseInt(ctx.params.version || \"\");\n  if (isNaN(version)) ctx.status(400).send(\"Invalid version\");\n});\n```\n\n---\n\n## Conflict Resolution Table\n\n| Path        | Priority | Notes                                  |\n| ----------- | -------- | -------------------------------------- |\n| /users/list | High     | Specific method + param (static match) |\n| /users/:id  | High     | Specific method + param                |\n| /users      | Medium   | Specific method                        |\n| /users/\\*   | Low      | Wildcard has lowest priority           |\n\n### **Same as post, put, ... http method**\n\n---\n\n## `all()` - Universal Method Handler\n\n**Catches ALL HTTP methods for a specific path**\n\n### Signature\n\n```typescript\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### Path Parameter Support\n\n```ts\n|Type            | Example              | Captured Values\n----------------|----------------------|-------------------\nStandard        | /:version/api        | version: \"v2\"\nOptional        | /user/:id?/profile   | id: \"123\" or undefined\nWildcard        | /docs/*              | *: \"getting-started\"\nMixed           | /:lang?/api/*        | lang: \"en\", *: \"v2/endpoints\"\n```\n\n### Examples\n\n**Basic Usage:**\n\n```ts\n// Handle all methods to /healthcheck\napp.all(\"/healthcheck\", (ctx) => {\n  ctx.text(`Method ${ctx.method} received`);\n});\n\n// GET/POST/PUT/DELETE etc to /healthcheck\n// ‚Üí \"Method GET received\"\n```\n\n**With Parameters:**\n\n```ts\napp.all(\"/*service/status\", (ctx) => {\n  ctx.json({\n    servicePath: ctx.params.service, // \"auth/api\"\n    wildcard: ctx.params[\"wildcard\"], // \"auth/api\"\n    method: ctx.method,\n  });\n});\n\n// PUT /auth/api/v2/status ‚Üí\n// { servicePath: \"auth/api/v2\", wildcard: \"auth/api/v2\", method: \"PUT\" }\n```\n\n**With Middleware:**\n\n```ts\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  ctx.text(`Accessed ${ctx.params.zone || \"default\"} zone`);\n});\n\n// POST /secure/admin ‚Üí Runs middlewares, handles zone=\"admin\"\n```\n\n---\n\n## `addRoute()` - Custom Method Registration\n\n**Handle non-standard/custom HTTP methods**\n\n### Signature\n\n```typescript\npublic addRoute(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### Supported Methods\n\n```ts\nStandard Methods | Custom Examples\n-----------------|-----------------\nGET, POST, PUT   | PURGE, LOCK\nPATCH, DELETE    | COPY, SEARCH\nHEAD, OPTIONS    | CUSTOM_API\n```\n\n### Parameter Examples\n\n**Custom Method with Parameters:**\n\n```ts\n// Register PURGE method\napp.addRoute(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group, // \"user-profiles/v2\"\n  });\n  ctx.status(202);\n});\n\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí Success\n```\n\n**Optional Parameters:**\n\n```ts\napp.addRoute(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.params.type || \"daily\");\n});\n\n// REPORT /stats/weekly ‚Üí type=\"weekly\"\n// REPORT /stats ‚Üí type=\"daily\"\n```\n\n**Wildcard Capture:**\n\n```ts\napp.addRoute(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n});\n\n// MSEARCH /files/docs/archived/project.txt\n```\n\n---\n\n## Parameter Access Pattern\n\n```ts\ninterface Context {\n  params: {\n    [key: string]: string | undefined;\n    \"*\"?: string; // Wildcard capture\n  };\n}\n\n// Access patterns\nctx.req.params.paramName; // Standard/optional params\nctx.req.params[\"*\"]; // Wildcard value\nctx.req.params[0]; // Not used - named params only\n```\n\n---\n\n## Best Practices\n\n### For `all()`\n\n1. Use for:\n   - Maintenance mode handlers\n   - Global path-specific middleware\n   - Method-agnostic endpoints\n2. Avoid:\n   - Complex business logic\n   - Overlapping with specific method handlers\n3. Ordering:\n\n   ```ts\n   app.get(\"/api\", specificHandler); // Higher priority\n   app.all(\"/*api\", globalMiddleware); // Lower priority\n   ```\n\n### For `addRoute()`\n\n1. Use for:\n   - Custom HTTP methods (RFC 2518 WebDAV, etc)\n   - Proprietary API methods\n   - Experimental features\n2. Compatibility:\n\n   ```ts\n   // Check method support\n   if (!ctx.methodSupported(\"PURGE\")) {\n     ctx.status(405).header(\"Allow\", \"PURGE, GET\");\n   }\n   ```\n\n3. Security:\n   - Explicitly document non-standard methods\n   - Handle CORS/preflight appropriately\n\n---\n\n## Conflict Resolution Table\n\n| Method            | Path         | Priority | Match Example           |\n| ----------------- | ------------ | -------- | ----------------------- |\n| addRoute('PURGE') | /cache       | High     | PURGE /cache            |\n| all()             | /cache/\\*    | Medium   | GET/POST etc /cache/123 |\n| get()             | /cache/clear | Highest  | GET /cache/clear        |\n\n**Resolution Rules:**\n\n1. Exact method matches take priority over `all()`\n2. Specific paths beat wildcards\n3. Registration order matters for same-priority routes\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "2. Context",
          "name": "Context",
          "path": "api/2-context",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Basic.md",
              "id": 13,
              "name": "Basic",
              "type": "file",
              "path": "api/context/basic",
              "content": "## **Public Properties**\n\n| Property   | Type            | Description                                             |\n| ---------- | --------------- | ------------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration                 |\n| `headers`  | `HeadersParser` | HTTP headers parser instance                            |\n| `pathname` | `string`        | Request path without query parameters                   |\n| `url`      | `string`        | Full request URL including protocol and query string    |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (GET/POST/PUT etc)                |\n| `state`    | `State`         | Application state container for middleware data sharing |\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nManages cookies with chainable methods:\n\n```ts\n// Get cookie value\nconst session = ctx.cookies.get('sessionID');\n\n// Set new cookie\nctx.cookies.set('prefs', darkMode:true, {\n  maxAge: 3600\n});\n\n// Delete cookie\nctx.cookies.delete('oldSession');\n```\n\n**Methods:**\n\n| Method   | Parameters                                                 | Description                             |\n| -------- | ---------------------------------------------------------- | --------------------------------------- |\n| `get`    | `name: string`                                             | Returns cookie value or `undefined`     |\n| `all`    | -                                                          | Returns all cookies as key-value object |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets cookie with options                |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates cookie                      |\n\n**CookieOptions:**\n\n```ts\ninterface CookieOptions {\n  domain?: string;\n  path?: string;\n  expires?: Date;\n  maxAge?: number;\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: \"Strict\" | \"Lax\" | \"None\";\n}\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends JSON response:\n\n```ts\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, { \"Cache-Control\": \"no-store\" });\n```\n\n### **2. `send(body, status?, headers?)`**\n\nUniversal response handler with auto-detected content type:\n\n```ts\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(...), 201); // application/octet-stream\n```\n\n### **3. `html(data, status?, headers?)`**\n\nSends HTML content:\n\n```ts\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n### **4. `text(data, status?, headers?)`**\n\nSends plain text:\n\n```ts\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n### **5. `xml(data, status?, headers?)`**\n\nSends XML content:\n\n```ts\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n### **6. `redirect(url, status=302, headers?)`**\n\nPerforms HTTP redirect:\n\n```ts\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers file download:\n\n```ts\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n### **8. `status(code)`**\n\nSets HTTP status code (chainable):\n\n```ts\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides normalized request object:\n\n```ts\ninterface Request {\n  method: HTTPMethod;\n  headers: HeadersParser;\n  params: Record<string, any>;\n  // ... other request properties\n}\n\n// Usage\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Example Workflow**\n\n```ts\n// Middleware example\napp.use(async (ctx, next) => {\n  // Set request ID\n  ctx.requestId = crypto.randomUUID();\n\n  // Authentication check\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n\n// Route handler\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n### **Headers (`headers`)**\n\n```ts\n// Get authorization header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Add custom header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n**Common Operations**:\n\n```ts\n// Check content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Parse JSON body\n}\n\n// Set multiple response headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Best Practices**\n\n1. **State Management**\n\n   ```ts\n   // Middleware sets state\n   ctx.state.set(\"user\", authenticatedUser);\n\n   //or\n   ctx.user = authenticatedUser; //context propagation\n\n   // Route handler accesses\n   const currentUser = ctx.state.get(\"user\");\n   ```\n\n2. **Header Validation**\n\n   ```ts\n   const contentType = ctx.req.headers.get(\"Content-Type\");\n   if (!allowedTypes.includes(contentType)) {\n     return ctx.status(415).text(\"Unsupported Media Type\");\n   }\n   ```\n\n3. **Parameter Sanitization**\n\n   ```ts\n   const userId = parseInt(ctx.req.params.id);\n   if (isNaN(userId)) {\n     return ctx.status(400).text(\"Invalid ID format\");\n   }\n   ```\n"
            },
            {
              "originalPath": "2. State.md",
              "id": 14,
              "name": "State",
              "type": "file",
              "path": "api/context/state",
              "content": "# State management\n\n---\n\nPublic state container for application data. state storage for middleware and plugins\n\n## Usage Example\n\n```typescript\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\nconsole.log(ctx.state.get(\"user\")); // Output: { id: 1, name: \"Alice\" }\n```\n\n## Class Definition\n\n```typescript\nexport class State {\n    private state: Map<string, any>;\n\n    constructor() {\n        this.state = new Map();\n    }\n```\n\n### Methods\n\n#### `set(key: string, value: any): void`\n\nStores a value associated with a specific key.\n\n**Parameters:**\n\n- `key` (string): The key for the value.\n- `value` (any): The value to be stored.\n\n**Example:**\n\n```typescript\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n#### `get(key: string): any | undefined`\n\nRetrieves a stored value by key.\n\n**Parameters:**\n\n- `key` (string): The key of the value to retrieve.\n\n**Returns:**\n\n- The stored value or `undefined` if not found.\n\n**Example:**\n\n```typescript\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n#### `delete(key: string): boolean`\n\nDeletes a stored value by key.\n\n**Parameters:**\n\n- `key` (string): The key to remove.\n\n**Returns:**\n\n- `true` if the key was deleted, `false` otherwise.\n\n**Example:**\n\n```typescript\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n#### `has(key: string): boolean`\n\nChecks if a key exists in storage.\n\n**Parameters:**\n\n- `key` (string): The key to check.\n\n**Returns:**\n\n- `true` if the key exists, `false` otherwise.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n#### `keys(): string[]`\n\nReturns an array of all stored keys.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n#### `values(): any[]`\n\nReturns an array of all stored values.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n#### `entries(): [string, any][]`\n\nReturns an array of key-value pairs.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n#### `clear(): void`\n\nRemoves all stored entries.\n\n**Example:**\n\n```typescript\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n"
            },
            {
              "originalPath": "3. Context Propagation.md",
              "id": 15,
              "name": "Context Propagation",
              "type": "file",
              "path": "api/context/context-propagation",
              "content": "---\n# Context Propagation\n\n## Overview\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and handlers. It ensures strict type validation while allowing hierarchical context extension.\n---\n\n## Core Concepts\n\n### 1. Type-Safe Context Definition\n\nDefine your context shape using TypeScript interfaces:\n\n```typescript\ninterface CustomContext {\n  // Optional authentication data\n  user?: User;\n\n  // Required request identifier\n  requestId: string;\n\n  // Add other request-specific properties\n  // logger?: Logger\n  // db?: DatabaseConnection\n}\n```\n\n### 2. Router Initialization\n\nCreate a router with your context type:\n\n```typescript\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n### 3. Middleware Implementation\n\nAdd context-enriching middleware with full type safety:\n\n```typescript\n// Authentication middleware\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Request ID middleware\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n### 4. Handler Access\n\nAccess validated context properties in endpoints:\n\n```typescript\napp.get(\"/profile\", (ctx) => {\n  // TypeScript automatically infers context shape\n  return Response.json({\n    id: ctx.requestId,\n    user: ctx.user.email, // Safe access to user data\n  });\n});\n```\n\n---\n\n## Advanced Features\n\n### Context Composition\n\nMerge multiple context types for modular development:\n\n```typescript\ninterface AuthContext {\n  user: User;\n  session: Session;\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n### Validation Middleware\n\nEnsure context integrity with validation:\n\n```typescript\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## Error Handling\n\n### Type Safety Guards\n\nThe compiler prevents common mistakes:\n\n```typescript\napp.use((ctx, next) => {\n  // Type Error: Property 'newProp' does not exist\n  ctx.newProp = \"value\";\n  // Type Error: requestId must be string\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n### Optional Properties\n\nSafely handle partial context:\n\n```typescript\napp.get(\"/public\", (ctx) => {\n  // user is optional - check existence\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## Best Practices\n\n1. **Initialization Order**\n\n   - Set critical context properties early in the middleware chain\n   - Place validation middleware after property initialization\n\n2. **Immutability**\n\n   ```typescript\n   // Avoid:\n   ctx.user = { ...ctx.user, ...newData };\n\n   // Prefer:\n   const updatedUser = { ...ctx.user, ...newData };\n   ```\n\n3. **Testing Patterns**\n\n   ```typescript\n   // Mock context for testing\n   const testCtx: CustomContext = {\n     requestId: \"test-123\",\n     user: mockUser,\n   };\n   ```\n\n---\n\n### Context Lifecycle\n\n1. Initialization\n2. Middleware Processing\n3. Handler Execution\n4. Cleanup Hooks\n\n---\n"
            },
            {
              "originalPath": "4. Cookies.md",
              "id": 16,
              "name": "Cookies",
              "type": "file",
              "path": "api/context/cookies",
              "content": "# Cookies\n\n---\n\n## **Setting and Retrieving Cookies in `PUT /data` Route**\n\n```ts\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { HttpOnly: true, Secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie\n  // ctx.cookies.delete('sessionToken');\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                         |\n| ---------------------------- | ------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie.               |\n| `all()`                      | Returns an object containing all cookies.               |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.             |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration in the past. |\n\n---\n\n## **Example Usage in a Client Request**\n\n### **Sending a Cookie with Fetch API**\n\n```js\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // its mandatory\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data));\n```\n\n## **Security Considerations**\n\nWhen handling cookies, consider the following:\n\n1. **Use `HttpOnly` for Security:** Prevents JavaScript access to cookies, reducing XSS risks.\n2. **Use `Secure` for HTTPS:** Ensures cookies are only transmitted over HTTPS.\n3. **Use `SameSite` to Prevent CSRF:**\n   - `SameSite=Strict`: Blocks all cross-site requests.\n   - `SameSite=Lax`: Allows safe cross-site navigation.\n   - `SameSite=None; Secure`: Required for cross-origin cookies (e.g., third-party cookies).\n4. **Set Expiry for Session Management:** Use `expires` to define cookie lifespan.\n5. **Enable Path Restriction:** Restrict cookies to specific paths using `Path=/some-path`.\n\n---\n\n### **Notes**\n\n- Cookies can have attributes like `HttpOnly`, `Secure`, `SameSite`, and `Expires`.\n- Ensure that **cookies are sent with credentials (`credentials: 'include'`)** if needed.\n"
            }
          ]
        },
        {
          "originalPath": "3. Request",
          "name": "Request",
          "path": "api/3-request",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Request.md",
              "id": 17,
              "name": "Request",
              "type": "file",
              "path": "api/request/request",
              "content": "---\n\n## **Request Handling API**\n\n## **1. Method**\n\n**Retrieves the HTTP request method.**\n\n```ts\n// Example: GET, POST, PUT, DELETE, etc.\nconst method = ctx.req.method; \n```\n\n**Properties**:\n\n- Read-only property\n- Always returns uppercase method name\n\n**Example**:\n\n```ts\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n**Deconstructed URL components.**\n\n```ts\ninterface UrlRef {\n  hash?: string; // #section\n  protocol?: string; // \"http:\" or \"https:\"\n  origin?: string; // \"https://example.com:8080\"\n  username?: string; // Auth username\n  password?: string; // Auth password\n  hostname?: string; // \"example.com\"\n  port?: string; // \"8080\"\n  href?: string; // Full URL string\n  query: Record<string, string>; // Parsed query parameters\n  pathname: string; // \"/api/v2/users\"\n}\n```\n\n**Usage**:\n\n```ts\nconst url = ctx.req.urlRef;\n\n// Example for \"https://api.com:8080/users?id=123#details\"\nconsole.log(url.port); // \"8080\"\nconsole.log(url.hostname); // \"api.com\"\nconsole.log(url.query); // { id: \"123\" }\nconsole.log(url.hash); // \"details\"\n```\n\n**Note**: Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n**Parsed URL query string parameters.**\n\n```ts\n// URL: /search?q=term&page=2&filter=new\nconst query = ctx.req.query;\n/* Returns:\n{\n  q: \"term\",\n  page: \"2\",\n  filter: \"new\"\n} */\n```\n\n**Behavior**:\n\n- Decodes URL-encoded values\n- Last value wins for duplicate keys\n- Returns empty object if no query\n\n**Example**:\n\n```ts\napp.get(\"/products\", (ctx) => {\n  const page = ctx.req.query.page || \"1\";\n  // Pagination logic\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n**Captured route parameters from path patterns.**\n\n**Route Patterns**:\n\n```ts\n// Route definition\napp.get(\"/users/:id/posts/:slug*\", handler);\n\n// Request: /users/42/posts/announcements/2023\nctx.req.params = {\n  id: \"42\",\n  slug: \"announcements/2023\", // Wildcard capture\n};\n```\n\n**Supported Patterns**:\n\n| Pattern   | Example Route   | Request Path       | Result                    |\n| --------- | --------------- | ------------------ | ------------------------- |\n| `:param`  | /users/:id      | /users/42          | `{ id: \"42\" }`            |\n| `:param?` | /archive/:year? | /archive           | `{ year: null }`          |\n| `*`       | /files/\\*path   | /files/docs/readme | `{ path: \"docs/readme\" }` |\n\n**Best Practices**:\n\n```ts\n// Validate numeric ID\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400);\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n```ts\n// Get authorization header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Add custom header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n**Common Operations**:\n\n```ts\n// Check content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Parse JSON body\n}\n\n// Set multiple response headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Request Flow Diagram**\n\n```bash\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler:\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send data\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\nHandle request bodies with built-in parsers for various content types.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON validation            |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | File uploads + form fields |\n\n---\n\n### **1. Text Parsing**\n\n**Use Case:** Plaintext, XML, CSV, or custom formats  \n**Max Size:** Configurable via `maxBodySize`\n\n```ts\n// Basic text parsing\nconst rawText = await ctx.req.text();\n\n// With error handling\ntry {\n  const config = await ctx.req.text();\n  // Process text content\n} catch (error) {\n  ctx.status(400).text(\"Invalid text payload\");\n}\n```\n\n---\n\n### **2. JSON Parsing**\n\n**Automatic Validation:**\n\n```ts\ntry {\n  const data = await ctx.req.json();\n} catch (error) {\n  ctx.status(422).json({ error: \"Validation failed\" });\n}\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```ts\nconst form = await ctx.req.formData();\nconsole.log(form.username); // \"john_doe\"\n```\n\n#### **Multipart File Uploads**\n\n```ts\n// File upload configuration\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\nconst form = await ctx.req.formData(config);\nconst file = form.avatar as File;\n\n// Save to filesystem\nconst buffer = await file.arrayBuffer();\nwriteFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n```\n\n---\n\n### **4. File Upload Example**\n\n**Route Handler:**\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n\n    const files = form.attachments;\n    let results = [];\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n**Client-Side Upload:**\n\n```js\nconst form = new FormData();\nform.append(\"avatar\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n"
            },
            {
              "originalPath": "2. Body Parser.md",
              "id": 18,
              "name": "Body Parser",
              "type": "file",
              "path": "api/request/body-parser",
              "content": "# Body Parser\n\n---\n\n- **Text parsing**\n- **JSON parsing**\n- **URL-encoded form parsing**\n- **Multipart form-data parsing** (including file handling)\n\n---\n\n## **Body Parser**\n\n### **1. Parsing Text Requests**\n\nThe `text()` method reads and returns the request body as a string.\n\n```ts\nconst body = await ctx.req.text();\n```\n\n---\n\n### **2. Parsing JSON Requests**\n\nThe `json()` method ensures that the content type is `application/json` before parsing the request body.\n\n```ts\nconst body = await ctx.req.json();\n```\n\n---\n\n### **3. Parsing Form Data (URL-Encoded & Multipart)**\n\nThe `formData()` method dynamically detects and parses form submissions, handling:\n\n- **JSON (`application/json`)**\n- **URL-encoded (`application/x-www-form-urlencoded`)**\n- **Multipart form-data (`multipart/form-data`)**, including file uploads.\n\n```ts\nconst body = await ctx.req.formData();\n```\n\n---\n\n## **Example: File Upload Route**\n\nThis route:\n\n- Accepts file uploads via `multipart/form-data`\n- Saves the file to the **uploads** directory\n- Responds with the file path\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n\n## **Send buffer**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file find\" }, 400);\n  }\n  const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n  return ctx.send(buffer, {\n    \"Content-Type\": file.type, // its required\n  });\n});\n```\n\n---\n\n## **Usage Example: Uploading a File via `fetch`**\n\nHere‚Äôs how a client can send a file to this endpoint using JavaScript:\n\n```js\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"file\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Feature      | Description                                                           |\n| ------------ | --------------------------------------------------------------------- |\n| `text()`     | Reads request body as a string.                                       |\n| `json()`     | Parses `application/json` data.                                       |\n| `formData()` | Parses `application/x-www-form-urlencoded` and `multipart/form-data`. |\n\n---\n\n```ts\n// Generic Form Handling\nconst form = await ctx.req.formData();\n\n// Accessing Values\nconst username = form.username;\nconst avatar = form.avatar as File;\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```ts\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB\n  allowedTypes?: string[]; // ['image/*', 'application/pdf']\n  maxFiles?: number; // Default: undefine\n}\n```\n\n### **cURL Upload**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/upload\n```\n\n### **2. Browser Fetch with Progress**\n\n```js\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"file\", file);\n\n  const response = await fetch(\"/upload\", {\n    method: \"POST\",\n    body: form,\n    headers: {\n      \"X-Upload-Token\": \"auth_token_here\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Upload failed: ${await response.text()}`);\n  }\n\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing:** For large files, use streaming instead of full buffering\n\n   ```ts\n   const stream = file.stream();\n   const transformer = new TransformStream();\n   // Add processing logic\n   ```\n\n2. **Memory Management:** Configure body parser limits based on expected payloads\n\n3. **Async Processing:** Handle file operations in background workers for large uploads\n\n4. **CORS Configuration:** Proper headers for cross-origin uploads\n\n   ```ts\n   ctx.headers.set(\"Access-Control-Allow-Origin\", \"trusted-domain.com\");\n   ```\n\n### **üõ†Ô∏è Example Usage**\n\n```javascript\nconst allowedTypes = [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"];\n\nconst formData = await ctx.req.formData({\n  sanitized: true, // Ensure filename is sanitized\n  allowedTypes, // Define accepted file types as an array\n  maxSize: 5000, // Max file size in KB (5MB)\n});\n```\n\n---\n\n## **üîπ API Reference: `ctx.req.formData(options)`**\n\n### **üìù Parameters**\n\n| Option         | Type       | Default    | Description                                                             |\n| -------------- | ---------- | ---------- | ----------------------------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | If `true`, filenames will be **sanitized** (remove special characters). |\n| `allowedTypes` | `string[]` | `[]`       | An **array of MIME types** (e.g., `[\"image/png\", \"image/jpeg\"]`).       |\n| `maxSize`      | `number`   | `Infinity` | Max file size allowed (in KB).                                          |\n\n---\n\n### **üîπ Return Value**\n\nThe function returns a **parsed form data object**:\n\n```javascript\n{\n    fields: { key1: \"value1\" }, // Form fields (non-file)\n    files: [\n        {\n            name: \"example.jpg\",\n            sanitizedName: \"example.jpg\",\n            type: \"image/jpeg\",\n            size: 1024, // File size in KB\n            path: \"/tmp/uploads/example.jpg\"\n        }\n    ]\n}\n```\n\n---\n\n## **üöÄ Examples**\n\n### **‚úÖ Allow Only PNG & JPEG Images**\n\n```javascript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **‚úÖ Allow Images & Videos**\n\n```javascript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // Max 8MB\n});\n```\n\n---\n\n## **‚ö†Ô∏è Error Handling**\n\n### **‚ùå If File Type is Not Allowed**\n\nIf a file type isn't in `allowedTypes`, it is **ignored** without throwing an error.\n\n### **‚ùå If File Exceeds `maxSize`**\n\n- The system **prevents** the upload of large files.\n\n### **‚ùå If No Files are Uploaded**\n\n- Returns an empty `files` array.\n\n---\n\n## **üõ†Ô∏è Best Practices**\n\n‚úÖ Use an **array for easier customization** (`allowedTypes`).  \n‚úÖ Always **sanitize filenames** if saving on a app.  \n‚úÖ Set a **reasonable file size limit** (`maxSize`).  \n‚úÖ Implement **logging** for skipped files.\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "4. Response",
          "name": "Response",
          "path": "api/4-response",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. TezResponse.md",
              "id": 19,
              "name": "TezResponse",
              "type": "file",
              "path": "api/response/tezresponse",
              "content": "# **TezResponse**\n\n## Overview\n\nThe `TezResponse` class provides a set of static methods to simplify HTTP response handling in a web application. It supports various response types including JSON, HTML, text, XML, file downloads, and redirections.\n\n---\n\n## Import\n\n```ts\nimport { TezResponse } from \"jezx\";\n```\n\n## Or Custom Response\n\n```ts\napp.get('/data', async (ctx) => {\n    return new Response('Hello World', { status: 200 });\n});`\n```\n\n## Methods\n\n### `json`\n\n#### Description\n\nSends a JSON response.\n\n#### Parameters\n\n- `body: any` - The response data.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with JSON data.\n\n#### Usage\n\n```ts\nreturn TezResponse.json({ message: \"Success\" }, 200);\n// or using context\nreturn ctx.json({ message: \"Success\" }, 200);\n```\n\n---\n\n### `html`\n\n#### Description\n\nSends an HTML response.\n\n#### Parameters\n\n- `data: string` - The HTML content as a string.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with HTML data.\n\n#### Usage\n\n```ts\nreturn TezResponse.html(\"<h1>Welcome</h1>\", 200);\n// or using context\nreturn ctx.html(\"<h1>Welcome</h1>\", 200);\n```\n\n---\n\n### `text`\n\n#### Description\n\nSends a plain text response.\n\n#### Parameters\n\n- `data: string` - The text content.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with plain text data.\n\n#### Usage\n\n```ts\nreturn TezResponse.text(\"Hello, World!\", 200);\n// or using context\nreturn ctx.text(\"Hello, World!\", 200);\n```\n\n---\n\n### `xml`\n\n#### Description\n\nSends an XML response.\n\n#### Parameters\n\n- `data: string` - The XML content.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with XML data.\n\n#### Usage\n\n```ts\nreturn TezResponse.xml(\n  \"<note><to>User</to><message>Hello</message></note>\",\n  200,\n);\n// or using context\nreturn ctx.xml(\"<note><to>User</to><message>Hello</message></note>\", 200);\n```\n\n---\n\n### `send`\n\n#### Description\n\nSends a response with any content type, automatically determining the content type if not provided.\n\n#### Parameters\n\n- `body: any` - The response body.\n- `status?: number` (Optional) - HTTP status code.\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with the provided data.\n\n#### Usage\n\n```ts\nreturn TezResponse.send(\"Custom Content\", 200, { \"X-Custom-Header\": \"value\" });\n// or using context\nreturn ctx.send(\"Custom Content\", 200, { \"X-Custom-Header\": \"value\" });\n```\n\n---\n\n### `redirect`\n\n#### Description\n\nRedirects to a given URL.\n\n#### Parameters\n\n- `url: string` - The target URL.\n- `status?: number` (Optional) - HTTP status code (default: 302).\n- `headers?: ResponseHeaders` (Optional) - Additional headers.\n\n#### Returns\n\n`Response` object with redirect headers.\n\n#### Usage\n\n```ts\nreturn TezResponse.redirect(\"https://example.com\");\n// or using context\nreturn ctx.redirect(\"https://example.com\");\n```\n\n---\n\n### `download`\n\n#### Description\n\nHandles file downloads.\n\n#### Parameters\n\n- `filePath: string` - The path to the file.\n- `fileName: string` - The name of the downloaded file.\n\n#### Returns\n\nA `Promise<Response>` object for file download.\n\n#### Usage\n\n```ts\nreturn await TezResponse.download(\"/path/to/file.pdf\", \"document.pdf\");\n// or using context\nreturn ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n```\n\n---\n\n### `sendFile`\n\n#### Description\n\nServes a static file to the client.\n\n#### Parameters\n\n- `filePath: string` - Absolute or relative path to the file.\n- `fileName?: string` (Optional) - The name of the sent file.\n\n#### Returns\n\nA `Promise<Response>` object with the file stream.\n\n#### Usage\n\n```ts\nreturn await TezResponse.sendFile(\"/path/to/image.jpg\", \"picture.jpg\");\n// or using context\nreturn ctx.sendFile(\"/path/to/image.jpg\", \"picture.jpg\");\n```\n\n---\n\n## Notes\n\n- The `TezResponse` class is designed to work in different runtime environments such as Node.js, Bun, and Deno.\n- Methods automatically handle appropriate content-type headers.\n- `download` and `sendFile` methods check for file existence and serve accordingly.\n\n---\n\n## Example Usage in an Express-like Framework\n\n```ts\napp.get(\"/json\", (req, res) => {\n  return TezResponse.json({ message: \"Hello World\" });\n  // or using context\n  return ctx.json({ message: \"Hello World\" });\n});\n\napp.get(\"/redirect\", (req, res) => {\n  return TezResponse.redirect(\"https://example.com\");\n  // or using context\n  return ctx.redirect(\"https://example.com\");\n});\nf;\n```\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "5. Headers API.md",
      "id": 20,
      "name": "Headers API",
      "type": "file",
      "path": "headers-api",
      "content": "---\n\n# Headers API\n\n**Request and response headers are different.**\n\n---\n\n## **Core Methods**\n\n### **1. `add(headers: [string, string][] | Record<string, string>)`**\n\n**Purpose:** Add multiple headers without overwriting existing ones  \n**Behavior:**\n\n- Appends new headers while preserving existing ones\n- Merges values for duplicate headers\n\n```ts\n// Array of tuples example\nheaders.add([\n  [\"Content-Type\", \"application/json\"],\n  [\"Cache-Control\", \"max-age=3600\"],\n]);\n\n// Object example\nheaders.add({\n  \"X-Custom-Header\": \"Value1\",\n  \"Accept-Encoding\": \"gzip\",\n});\n```\n\n---\n\n### **2. `set(key: string, value: string | string[])`**\n\n**Purpose:** Create or overwrite a header  \n**Behavior:**\n\n- Replaces all existing values for this header\n- Accepts single value or array of values\n\n```ts\n// Single value\nheaders.set(\"Authorization\", \"Bearer abc123\");\n\n// Multiple values\nheaders.set(\"Accept-Language\", [\"en-US\", \"fr-FR\"]);\n```\n\n---\n\n### **3. `get(key: string): string | undefined`**\n\n**Purpose:** Retrieve first value of a header\n\n```ts\nconst contentType = ctx.req.headers.get(\"content-type\");\n// \"application/json\" (case-insensitive)\n```\n\n---\n\n### **4. `getAll(key: string): string[]`**\n\n**Purpose:** Retrieve all values of a header\n\n```ts\nconst languages = ctx.req.headers.getAll(\"accept-language\");\n// [\"en-US\", \"fr-FR\"]\n```\n\n---\n\n### **5. `has(key: string): boolean`**\n\n**Purpose:** Check header existence\n\n```ts\nif (ctx.req.headers.has(\"x-auth-token\")) {\n  // Handle authentication\n}\n```\n\n---\n\n### **6. `delete(key: string): boolean`**\n\n**Purpose:** Remove a header  \n**Returns:** `true` if header existed, `false` otherwise\n\n```ts\nconst existed = ctx.req.headers.delete(\"expires\");\n```\n\n---\n\n### **7. `append(key: string, value: string)`**\n\n**Purpose:** Add value to existing header or create new\n\n```ts\nheaders.append(\"Vary\", \"User-Agent\");\nheaders.append(\"Vary\", \"Accept-Encoding\");\n// Vary: User-Agent, Accept-Encoding\n```\n\n---\n\n## **Iteration Methods**\n\n### **8. `entries(): Iterable<[string, string[]]>`**\n\n**Purpose:** Get [key, values] iterator\n\n```ts\nfor (const [header, values] of headers.entries()) {\n  console.log(`${header}: ${values.join(\", \")}`);\n}\n```\n\n### **9. `keys(): Iterable<string>`**\n\n**Purpose:** Get header names iterator\n\n```ts\nfor (const headerName of headers.keys()) {\n  console.log(\"Header present:\", headerName);\n}\n```\n\n### **10. `values(): Iterable<string[]>`**\n\n**Purpose:** Get header values iterator\n\n```ts\nfor (const values of headers.values()) {\n  console.log(\"Values:\", values);\n}\n```\n\n---\n\n## **Utility Methods**\n\n### **11. `forEach(callback: (values: string[], key: string) => void)`**\n\n**Purpose:** Iterate through headers\n\n```ts\nheaders.forEach((values, key) => {\n  console.log(`Header ${key} has ${values.length} values`);\n});\n```\n\n### **12. `toObject(): Record<string, string | string[]>`**\n\n**Purpose:** Convert to plain JS object\n\n```ts\nconst headerObj = headers.toObject();\n/* Returns:\n{\n  \"content-type\": \"application/json\",\n  \"accept-language\": [\"en-US\", \"fr-FR\"]\n}\n*/\n```\n\n---\n\n## **Usage Patterns**\n\n### **Request Header Modification**\n\n```ts\n// Middleware to add security headers\napp.use(async (ctx) => {\n  ctx.headers\n    .set(\"X-Content-Type-Options\", \"nosniff\")\n    .set(\"Content-Security-Policy\", \"default-src 'self'\")\n    .delete(\"X-Powered-By\");\n\n  await ctx.next();\n});\n```\n\n### **Response Header Handling**\n\n```ts\n// API versioning example\napp.get(\"/data\", (ctx) => {\n  ctx.headers.set(\"X-API-Version\", \"2.1\").append(\"Vary\", \"Accept-Encoding\");\n\n  return ctx.json({ data: \"...\" });\n});\n```\n\n---\n\n## **Header Operations Cheat Sheet**\n\n| Method       | Description            | Mutable | Returns    |\n| ------------ | ---------------------- | ------- | ---------- | ---------- |\n| `add()`      | Add multiple headers   | ‚úÖ      | `void`     |\n| `set()`      | Replace header values  | ‚úÖ      | `void`     |\n| `get()`      | Get first header value | ‚ùå      | `string    | undefined` |\n| `getAll()`   | Get all header values  | ‚ùå      | `string[]` |\n| `has()`      | Check existence        | ‚ùå      | `boolean`  |\n| `delete()`   | Remove header          | ‚úÖ      | `boolean`  |\n| `append()`   | Add header value       | ‚úÖ      | `void`     |\n| `toObject()` | Serialize headers      | ‚ùå      | `Record`   |\n\n---\n"
    },
    {
      "originalPath": "9. Static File.md",
      "id": 21,
      "name": "Static File",
      "type": "file",
      "path": "static-file",
      "content": "---\n\n# **`static()` - Serve Static Files Efficiently**  \n\n## **Overview**  \n\nThe `static()` method allows serving static files (HTML, CSS, JS, images, videos, fonts, etc.) from a specified directory. It supports defining a **base route** or directly serving from the **root (`/`)** while offering customizable options like caching and indexing.  \n\n## **Usage**  \n\n### **1Ô∏è‚É£ Serve Static Files from the Root (`/`)**  \n\n```typescript\napp.static(\"./public\");\n```\n\n- Serves files from the **\"public\"** directory.  \n- Example: A file `public/style.css` will be accessible at `http://yourdomain.com/style.css`.  \n\n### **2Ô∏è‚É£ Serve Static Files from a Specific Route**  \n\n```typescript\napp.static(\"/static\", \"./assets\");\n```\n\n- Serves files from the **\"assets\"** directory under `/static`.  \n- Example: `assets/logo.png` will be available at `http://yourdomain.com/static/logo.png`.  \n\n### **3Ô∏è‚É£ Serve Static Files with Options**  \n\n```typescript\napp.static(\"./public\", { \n    cacheControl: \"public, max-age=3600\", \n     });\n```\n\n- Enables HTTP caching with **Cache-Control headers**.  \n\n---\n\n## **Method Signature**\n\n```typescript\nstatic(route: string, folder: string, option?: StaticServeOption): this;\nstatic(folder: string, option?: StaticServeOption): this;\n```\n\n## **Parameters**\n\n| Parameter             | Type                | Description                                                                                         |\n| --------------------- | ------------------- | --------------------------------------------------------------------------------------------------- |\n| `route` _(optional)_  | `string`            | The base route to serve static files from (e.g., `/public`). If omitted, files are served from `/`. |\n| `folder`              | `string`            | The directory containing static files.                                                              |\n| `option` _(optional)_ | `StaticServeOption` | Additional options for static file serving.                                                         |\n\n---\n\n## **üìå Available Options (`StaticServeOption`)**\n\nThe `option` parameter allows configuring various settings for serving static files.\n\n| Option         | Type             | Default      | Description                                                                            |\n| -------------- | ---------------- | ------------ | -------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Controls HTTP caching for files. Example: `\"public, max-age=3600\"` for 1-hour caching. |\n| `header`       | `HeaderResponse` | `undefined`  | Record of headers                                                                      |\n\n---\n\n## **üîπ Example Implementations**\n\n### **1Ô∏è‚É£ Enable Cache-Control for Performance**\n\n```typescript\napp.static(\"./public\", { cacheControl: \"public, max-age=86400\" }); // 1-day caching\n```\n\n## **üöÄ Return Value**\n\nReturns the current instance (`this`), allowing **method chaining**:\n\n```typescript\napp.static(\"./public\").use(middlewareFunction);\n```\n\n---\n\n## **üìù Notes**\n\n- Automatically detects **MIME types** for proper `Content-Type` headers.\n- Ensures **secure file path resolution** to prevent directory traversal attacks.\n- Works seamlessly across **Node.js, Deno, and Bun** with minimal modifications.\n- Supports both **absolute and relative** folder paths.\n\n---\n\nThis **enhanced documentation** includes:  \n‚úÖ **Detailed parameter descriptions**  \n‚úÖ **Comprehensive options table**  \n‚úÖ **Real-world use cases**  \n‚úÖ **Security & performance best practices**\n\n<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control>\n\n## **You can Overwrite static path**\n\n```ts\napp.get(\"/static/image.png\", (ctx) => {\n  //-------------\n  //------------- code\n  //-------------\n  //-------------\n});\n```\n"
    },
    {
      "originalPath": "97. Middlewares",
      "name": "Middlewares",
      "path": "middlewares",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. CORS Middleware.md",
          "id": 22,
          "name": "CORS Middleware",
          "type": "file",
          "path": "middlewares/cors-middleware",
          "content": "---\n# CORS Middleware\n\n## **Overview**\n\nMiddleware for handling Cross-Origin Resource Sharing (CORS) headers. Supports dynamic origin validation, preflight requests, and granular control over allowed methods/headers.\n---\n\n## **Installation & Basic Usage**\n\n```typescript\nimport { cors } from \"tezx\";\n\n// Basic setup (allow all origins)\napp.use(cors());\n\n// Advanced configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type                                                              | Default                             | Description                           |\n| ---------------- | ----------------------------------------------------------------- | ----------------------------------- | ------------------------------------- |\n| `origin`         | `string RegExp  (string RegExp)[]  ((origin: string) => boolean)` | `*` (allow all)                     | Controls allowed origins              |\n| `methods`        | `string[]`                                                        | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | HTTP methods allowed in CORS requests |\n| `allowedHeaders` | `string[]`                                                        | `[\"Content-Type\", \"Authorization\"]` | Headers clients can send              |\n| `exposedHeaders` | `string[]`                                                        | (none)                              | Headers exposed to client             |\n| `credentials`    | `boolean`                                                         | `false`                             | Allow cookies/credentials             |\n| `maxAge`         | `number`                                                          | (none)                              | Preflight cache duration in seconds   |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```typescript\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n#### **Multiple Origins**\n\n```typescript\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex support\n  ],\n});\n```\n\n#### **Dynamic Validation**\n\n```typescript\ncors({\n  origin: (requestOrigin) => {\n    return validateOriginAgainstDB(requestOrigin); // Async supported via ctx\n  },\n});\n```\n\n---\n\n### **2. Preflight Handling**\n\nAutomatically responds to `OPTIONS` requests:\n\n```http\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response**:\n\n```http\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\nWhen enabled:\n\n```typescript\ncors({ credentials: true });\n```\n\nSets header:\n\n```http\nAccess-Control-Allow-Credentials: true\n```\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers automatically:\n\n| Header                             | Value Example                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Per-Route CORS Configuration**\n\n```typescript\n// Apply to specific route\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n### **2. Combining with Authentication**\n\n```typescript\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\n\napp.use(authMiddleware); // Reads Authorization header\n```\n\n### **3. Long Cache Preflight**\n\n```typescript\ncors({\n  maxAge: 86400, // 24-hour cache\n});\n```\n\n---\n\n## **Error Handling**\n\nThe middleware **does not** throw errors for invalid origins. Instead:\n\n- Sets empty `Access-Control-Allow-Origin` for invalid origins\n- Returns 204 for OPTIONS requests regardless of origin validity\n- Relies on browser enforcement of CORS policies\n\n**To implement strict blocking**:\n\n```typescript\napp.use(\n  cors({\n    origin: (origin) => {\n      if (!isValid(origin)) {\n        throw new Error(\"Invalid origin\"); // Will propagate\n      }\n      return origin;\n    },\n  }),\n);\n```\n\n---\n\n## **Best Practices**\n\n1. **Avoid Wide Open CORS**\n\n   ```typescript\n   // ‚ùå Dangerous in production\n   cors({ origin: \"*\" });\n\n   // ‚úÖ Restrictive setup\n   cors({ origin: process.env.ALLOWED_ORIGINS });\n   ```\n\n2. **Limit Exposed Headers**\n\n   ```typescript\n   cors({\n     exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"],\n   });\n   ```\n\n3. **Use Credentials Sparingly**\n\n   ```typescript\n   // Only enable when cookies/auth needed\n   cors({ credentials: true });\n   ```\n\n4. **Combine with Rate Limiting**\n\n   ```typescript\n   app.use(rateLimiter());\n   app.use(cors());\n   ```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\nMatch origins using regular expressions:\n\n```typescript\n// Allow all subdomains of example.com\ncors({ origin: /\\.example\\.com$/ });\n\n// Allow specific patterns\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ });\n```\n\n### **2. Mixed Array Support**\n\nCombine strings and regexes in the origin array:\n\n```typescript\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**  \n   `'https://exact-domain.com'`\n\n2. **Regex Pattern Test**  \n   `/\\.domain\\.com$/`\n\n3. **Array Membership Check**  \n   (Strings or regexes)\n\n4. **Function Validation**  \n   Custom logic\n\n### **Matching Flow**\n\n```js\ngraph TD\n    A[Request Origin] --> B{Is origin string?}\n    B -->|Yes| C[Exact match]\n    B -->|No| D{Is origin regex?}\n    D -->|Yes| E[Regex test]\n    D -->|No| F{Is array?}\n    F -->|Yes| G[Check array elements]\n    F -->|No| H{Is function?}\n    H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```typescript\n// Allow all subdomains and local development\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex Generation**\n\n```typescript\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\n\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function Combination**\n\n```typescript\ncors({\n  origin: (origin) => {\n    const isLocal = /localhost:\\d+/.test(origin);\n    return isLocal || someOtherCheck(origin);\n  },\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```typescript\n// Match exact domain with regex\ncors({ origin: /^https:\\/\\/exact\\.com$/ });\n\n// Allow HTTP and HTTPS\ncors({ origin: /^https?:\\/\\/app\\.com$/ });\n```\n\n### **Port Matching**\n\n```typescript\n// Allow any localhost port\ncors({ origin: /http:\\/\\/localhost:\\d+/ });\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchored Patterns**  \n   Always anchor regexes to prevent partial matches:\n\n   ```typescript\n   // ‚ùå Vulnerable to \"evil-example.com\"\n   /example\\.com/\n\n   // ‚úÖ Secure match\n   /^https:\\/\\/.*\\.example\\.com$/\n   ```\n\n2. **Escape Special Characters**\n\n   ```typescript\n   const domain = \"special.domain.com\";\n   const escaped = domain.replace(/\\./g, \"\\\\.\");\n   new RegExp(`^https://${escaped}$`);\n   ```\n\n3. **Combine with Allow Lists**\n\n   ```typescript\n   const allowed = loadFromDB(); // ['trusted.com', ...]\n   cors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n   ```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex Patterns**\n\n```typescript\nconst testOrigin = \"https://app.staging.com\";\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(testOrigin)); // true\n```\n\n### **Log Matched Origins**\n\n```typescript\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n**Returns:** Middleware function\n\n**Flow:**\n\n1. Validates request origin\n2. Sets CORS response headers\n3. Short-circuits OPTIONS requests\n4. Proceeds to next middleware for non-OPTIONS\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "98. Helpers",
      "name": "Helpers",
      "path": "helpers",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Load Environment.md",
          "id": 23,
          "name": "Load Environment",
          "type": "file",
          "path": "helpers/load-environment",
          "content": "---\n\n## **Core Components**\n\n### **1. `loadEnv(basePath?: string)`**\n\n**Purpose:** Loads environment variables from `.env` files  \n**Parameters:**\n\n- `basePath` (optional): Directory containing `.env` files (default: current working directory)\n\n**Supported Files:**\n\n```js\n.env                # Base environment\n.env.local          # Local overrides\n.env.[mode]         # Environment-specific (e.g., .env.production)\n.env.[mode].local   # Mode-specific local overrides\n```\n\n**Return Type:**  \n\n```typescript\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: 'development' | 'production' | 'test';\n  PORT?: string;\n  API_KEY?: string;\n  // ... other variables\n}\n```\n\n**Example:**\n\n```typescript\n// Load from specific directory\nconst env = loadEnv('./config');\n\n// Access variables\nconst port = env.PORT || '3000';\n//or\n\nconst port = process.env.PORT\n```\n\n---\n\n### **2. `CustomContext` Interface**\n\n**Extends base context with application-specific properties:**\n\n```typescript\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n**Usage in Middleware:**\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n---\n\n### **3. Server Initialization**\n\n**Type-Safe Configuration:**\n\n```typescript\nconst server = new Accelero<CustomContext>({\n  env: loadEnv(),\n  // Other options\n});\n```\n\n**Configuration Options:**\n\n| Option | Type           | Default                     | Description                     |\n| ------ | -------------- | --------------------------- | ------------------------------- |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Environment variables container |\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```typescript\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst server = new Accelero({\n  env,\n  logger: logger,\n});\n\n// Access env in middleware\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n### **2. Advanced Context Usage**\n\n```typescript\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst server = new Accelero<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware to extend context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\n```typescript\n// .env.production\nNODE_ENV = production;\nPORT = 443;\nAPI_KEY = prod_abcdef;\n\n// .env.development\nNODE_ENV = development;\nPORT = 3000;\nAPI_KEY = dev_123456;\n```\n\n### **2. Security**\n\n```text\n# .gitignore\n.env.local\n.env.*.local\n```\n\n---\n\n**Example:**\n\n```typescript\nif (env.DEBUG) enableDebugging();\n```\n\n---\n"
        },
        {
          "originalPath": "2. Logger.md",
          "id": 24,
          "name": "Logger",
          "type": "file",
          "path": "helpers/logger",
          "content": "# Logger Function\n\nThe `TezX` logger provides a flexible logging system that integrates with request/response cycles and supports custom log levels. It follows the **LoggerFnType** interface for structured logging.\n\n---\n\n## **Quick Start**\n\n### **Basic Setup**\n\n```typescript\nimport { TezX, loadEnv, logger } from \"tezx\";\n\nconst server = new TezX({\n  logger: logger,\n  env: loadEnv(),\n});\n```\n\n---\n\n## **Logger Configuration**\n\n### **LoggerFnType Interface**\n\n```typescript\ntype LoggerFnType = () => {\n  request?: (method: HTTPMethod, pathname: string) => void;\n  response?: (method: HTTPMethod, pathname: string, status?: number) => void;\n  info?: (msg: string, ...args: unknown[]) => void;\n  warn?: (msg: string, ...args: unknown[]) => void;\n  error?: (msg: string, ...args: unknown[]) => void;\n  debug?: (msg: string, ...args: unknown[]) => void;\n  success?: (msg: string, ...args: unknown[]) => void;\n};\n```\n\n```ts\napp.post(\"/products\", async (ctx) => {\n  logger().debug(\"Successful\");\n  return ctx.json({ success: true, message: \"Created Successful\" });\n});\n```\n\n---\n\n## **Core Methods**\n\n### **1. Request/Response Tracking**\n\n| Method     | Parameters                     | Description              |\n| ---------- | ------------------------------ | ------------------------ |\n| `request`  | `method`, `pathname`           | Logs incoming requests   |\n| `response` | `method`, `pathname`, `status` | Logs completed responses |\n\n**Example:**\n\n```typescript\nconst logger = () => ({\n  request: (method, path) => {\n    console.log(`‚ûî ${method} ${path}`);\n  },\n  response: (method, path, status) => {\n    console.log(`‚Üê ${status} ${method} ${path}`);\n  },\n});\n```\n\n### **2. Log Levels**\n\n| Method    | Use Case            | Example Output                       |\n| --------- | ------------------- | ------------------------------------ |\n| `info`    | General information | `[INFO] Server started on port 3000` |\n| `warn`    | Non-critical issues | `[WARN] High memory usage detected`  |\n| `error`   | Critical errors     | `[ERROR] Database connection failed` |\n| `debug`   | Debugging details   | `[DEBUG] Route matched: /api/users`  |\n| `success` | Positive outcomes   | `[SUCCESS] User created: ID-123`     |\n\n---\n\n### **Custom Log Format**\n\n```typescript\nconst logger = () => ({\n  info: (msg, ...args) => {\n    const timestamp = new Date().toISOString();\n    console.log(`[${timestamp}] INFO: ${msg}`, ...args);\n  },\n  error: (msg, ...args) => {\n    const timestamp = new Date().toISOString();\n    console.error(`[${timestamp}] ERROR: ${msg}`, ...args);\n  },\n});\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "99. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Basic.md",
          "id": 25,
          "name": "Basic",
          "type": "file",
          "path": "examples/basic",
          "content": ""
        },
        {
          "originalPath": "1. Uploader.md",
          "id": 26,
          "name": "Uploader",
          "type": "file",
          "path": "examples/uploader",
          "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
        }
      ]
    },
    {
      "originalPath": "m.md",
      "id": 27,
      "name": "M",
      "type": "file",
      "path": "m",
      "content": "Ei function `addMiddleware` ekta **Trie-based middleware system** er part, jetar kaj **nested middlewares ke root middleware tree te merge kora**. Ei function **TrieRouter er motoi kaj kore, but middlewares niye**.\n\n---\n\n### **üîç Function Breakdown with Comments**\n\n```ts\nfunction addMiddleware(\n  children: Map<string, TriMiddleware>,\n  node: TriMiddleware,\n) {\n  let n = node; // Root node ke current node hisebe set kora\n\n  // Looping through all middleware children\n  for (const [path, middlewareNode] of children) {\n    // Jodi already path ta parent node e thake\n    if (n.children.has(path)) {\n      let findNode = n.children.get(path)!; // Existing node ta retrieve kori\n\n      // **Middleware Merge:** New middlewares ke existing node er sathe add kori\n      findNode.middlewares.push(...middlewareNode.middlewares);\n\n      // **Clearing Old Middlewares:** Jeno duplicate na thake\n      middlewareNode.middlewares.length = 0;\n\n      // **Recursive Merge:** Jodi nested middleware children thake, tahole abar call kori\n      if (middlewareNode.children.size) {\n        addMiddleware(middlewareNode.children, findNode);\n      }\n    } else {\n      // Jodi path root e na thake, tahole direct add kori\n      n.children.set(path, middlewareNode);\n\n      // **Clearing Middlewares & Children:** Jeno extra memory na use hoy\n      middlewareNode.middlewares.length = 0;\n      middlewareNode.children.clear();\n    }\n  }\n}\n```\n\n---\n\n### **üöÄ Merging Middlewares**\n\nEi function **nested middleware gulo ke parent Trie er sathe merge kore**.\n\n1Ô∏è‚É£ **Before merging:**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n2Ô∏è‚É£ **New RouterMiddlewares (To Merge)**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n3Ô∏è‚É£ **After merging:**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  <-- Merged!\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  <-- New Middleware Added\n```\n\n---\n\n### **üîë Key Takeaways**\n\n‚úÖ **Same middleware path hole merge hoy** (duplicate avoid kore)  \n‚úÖ **Nested middlewares recursively merge hoy**  \n‚úÖ **Clearing middleware arrays** memory optimize kore  \n‚úÖ **TrieRouter er motoi middleware tree structure handle kore**\n\n---\n\n### **üåü Final Summary**\n\n- Ei function **Hono.js er middleware merging er moto kaj kore**.\n- Recursive method diye **nested middlewares ke Trie structure e merge kore**.\n- **Optimized memory** rakhar jonne `middlewares.length = 0` and `children.clear()` kora hoy.\n\nAro details lagle bolo! üöÄüî•\n"
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "release-note/tsfsd",
      "name": "Tsfsd",
      "folder": "Release Note",
      "content": "tsrfc\nInstallation\nConfiguration\nLogger Function\n"
    },
    {
      "id": 2,
      "path": "need-to-know",
      "name": "Need To Know",
      "folder": ".",
      "content": "## Compatibility\n\n- params (`:id`)\n- wildcard (`/*path` or `/*`)\n- optional params (`/:id?`)\n\n### 1. Router\n\n- not support directly wildcard and optional params. (use `basePath` ‚úÖ)\n\n```ts\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n### 2. Overwritten router (method)\n\n- Method will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n- not found Handler will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n\n```ts\n// ‚ùå Conflicting routes\n// ‚ùì Will be overwritten by the last handler.\n// Output: {name: \"Jhon\"}\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/:name\", handleByName); // Will execute be reached\n\n// ‚úÖ Solution: Use distinct paths\napp.get(\"/users/id/:id\", handleUser);\napp.get(\"/users/name/:name\", handleByName);\n```\n\n### 3. Matching Priority\n\nRoutes are matched with following priority order:\n\n1. Static paths (`/users/list`)\n2. Named parameters (`/users/:id`)\n3. Wildcard parameters (`/users/*`)\n4. Optional parameters (`/users/:id?`)\n\n## **4. ‚ö†Ô∏è Critical Implementation Note**\n\n**Sub-router groups require explicit rule declaration:**\n\nInside sub-router each group (middleware ) act as a independence middleware.\nSo, like parent(sub-router) again add middlewareRule same as parent(sub-router)\n\n```typescript\n// ‚úÖ Correct Implementation\nconst userRouter = new Router();\nuserRouter.group(\"/users\", { middlewareRule: \"follow\" }, (group) => {\n  group.use(loggerMiddleware);\n  group.get(\"/:id\", getUser);\n});\n\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n\n// ‚ùå Incorrect Implementation\nconst userRouter = new Router();\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n\nuserRouter.group(\"/users\", (group) => {\n  // MiddlewareRule not set here - will not inherit parent rule\n});\n```\n\n### **‚ùå Incorrect Approach**\n\nAlways attach the middleware rule before declaring the group.\n\n```typescript\nconst userRouter = new Router();\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n\n//‚ùå This won't work because it's declared after router addition\nuserRouter.group(\"\", { middlewareRule: \"follow\" }, (group) => {\n  group.use(function test(ctx, next) {\n    console.log(\"inside user group\");\n    return next();\n  });\n\n  group.delete(\"/users/:id\", async (ctx) => {\n    return ctx.json({ message: `User ID ${ctx.req.params.id} Deleted` });\n  });\n});\n\n// ‚úÖ Correct Implementation\nconst userRouter = new Router();\nuserRouter.group(\"\", { middlewareRule: \"follow\" }, (group) => {\n  group.use(function test(ctx, next) {\n    console.log(\"inside user group\");\n    return next();\n  });\n\n  group.delete(\"/users/:id\", async (ctx) => {\n    return ctx.json({ message: `User ID ${ctx.req.params.id} Deleted` });\n  });\n});\nserver.addRouter(\"/\", { middlewareRule: \"follow\" }, userRouter);\n```\n"
    },
    {
      "id": 3,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "# **TezX Installation** üì¶\n\n---\n\n## **Installation Steps** üöÄ\n\n### 1. **Create New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### 2. **Install TezX Framework**\n\n- npm\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n### 3. **Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ server.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## **Environment Configuration** ‚öôÔ∏è\n\n### 1. **Create `.env` File**\n\n```env\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n## **Basic Server Setup** üíª\n\n### 1. **Create `src/server.ts`**\n\n```typescript\nimport { TezX, loadEnv, logger, nodeAdapter } from \"tezx\";\n\nconst env = loadEnv();\n\nconst server = new TezX({\n  logger: logger,\n  env: env,\n});\n\nserver.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n### 2. **Add TypeScript Support (Optional)**\n\n```bash\nnpm install typescript @types/node ts-node-dev --save-dev\n```\n\n**`tsconfig.json`**\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n\n---\n\n## **Running the Server** ‚ñ∂Ô∏è\n\n### **Development Mode (Hot Reload)**\n\n```bash\nnpx ts-node-dev --respawn src/server.ts\n```\n\nor use nodemon with ts-node\n\n```bash\nnodemon src/server.ts\n```\n\n### **Production Build**\n\n```bash\nnpm run build && node dist/server.js\n```\n\n**Add to `package.json`**\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"ts-node-dev --respawn src/server.ts\",\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\"\n  }\n}\n```\n\n---\n\n## **Advanced Configuration** üîß\n\n### 1. **Add Static File Support**\n\n```typescript\nserver.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\n```typescript\nimport { cors } from \"tezx/middleware\";\n\nserver.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\n```typescript\nserver.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## **Troubleshooting** üö®\n\n### **Common Issues**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\n**Happy Coding!** üöÄ\n"
    },
    {
      "id": 4,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": ""
    },
    {
      "id": 5,
      "path": "getting-started/node",
      "name": "Node",
      "folder": "Getting Started",
      "content": "\n### **Node.js Configuration with TezX**\n\n### **Running the Server**\n\n1. Install `TezX`:\n\n```bash\n   npm install TezX\n```\n\n2. Save the code in a file (e.g., `index.js`).\n\n3. Run:\n\n```bash\nnode index.js\n```\n\n4. Test endpoints like `http://localhost:3001/products`.\n\n### **Example**\n\n```javascript\n// Import necessary modules from TezX\nimport { loadEnv, logger, nodeAdapter, Router, TezX } from \"TezX\";\n\n// Load environment variables (e.g., from a .env file)\nconst env = loadEnv();\n\n// Initialize the TezX application with configuration\nconst app = new TezX({\n  logger: logger,         // Built-in logger for request/response logging\n  env: env,              // Environment variables for configuration\n  allowDuplicateMw: true // Allows duplicate middleware registration\n});\n\n// **Product Routes**\n\n// Initialize a new Router instance for product-related routes\nconst productRouter = new Router({});\n\n// Group product routes with shared middleware\nproductRouter.group(\"\", (group) => {\n  // Middleware applied to all routes in this group\n  group.use((ctx, next) => {\n    console.log(\"inside router\"); // Log for debugging\n    return next();                // Proceed to next middleware/handler\n  });\n\n  // GET /products - Returns an empty JSON object\n  group.get(\"/products\", async (ctx) => {\n    return ctx.json({});\n  });\n});\n\n// GET /products/:id - Fetch product by ID\nproductRouter.get(\"/products/:id\", async (ctx) => {\n  return ctx.json({ message: `Product ID: ${ctx.req.params.id}` });\n});\n\n// POST /products - Create a new product\nproductRouter.post(\"/products\", async (ctx) => {\n  const productData = await ctx.req.json(); // Parse request body\n  return ctx.json({ message: \"Product Created\", data: productData });\n});\n\n// PUT /products/:id - Update a product by ID\nproductRouter.put(\"/products/:id\", async (ctx) => {\n  return ctx.json({ message: `Product ID ${ctx.req.params.id} Updated` });\n});\n\n// DELETE /products/:id - Delete a product by ID\nproductRouter.delete(\"/products/:id\", async (ctx) => {\n  return ctx.json({ message: `Product ID ${ctx.req.params.id} Deleted` });\n});\n\n// Mount the productRouter at the root path \"/\"\napp.use(\"/\", productRouter);\n\n// Start the server using the Node.js adapter\nnodeAdapter(app).listen(3001, () => {\n  console.log(\"Server running on port 3001\");\n});\n```\n\n### **Sample Requests**\n\n| Method | Path                | Response                                  |\n|--------|---------------------|-------------------------------------------|\n| GET    | `/products`         | `{}`                                     |\n| GET    | `/products/123`     | `{\"message\": \"Product ID: 123\"}`         |\n| POST   | `/products`         | `{\"message\": \"Product Created\", \"data\": {...}}` |\n| PUT    | `/products/123`     | `{\"message\": \"Product ID 123 Updated\"}`  |\n| DELETE | `/products/123`     | `{\"message\": \"Product ID 123 Deleted\"}`  |\n\n---\n\n### **Key Notes**\n\n- The `allowDuplicateMw: true` setting still allows duplicate middleware within the `productRouter` group if added multiple times.\n- The middleware `console.log(\"inside router\")` applies to all routes in the group (e.g., `/products`).\n- The server runs on port `3001` as before.\n\n---\n"
    },
    {
      "id": 6,
      "path": "getting-started/bun",
      "name": "Bun",
      "folder": "Getting Started",
      "content": ""
    },
    {
      "id": 7,
      "path": "getting-started/deno",
      "name": "Deno",
      "folder": "Getting Started",
      "content": ""
    },
    {
      "id": 8,
      "path": "api/middleware-api/basic",
      "name": "Basic",
      "folder": "API/Middleware API",
      "content": "## **üöÄ Merging Middlewares**\n\nThe `mergeMiddleware` function effectively integrates nested middlewares from a new router into the parent router structure. This approach mirrors the way routing systems merge nested routers, ensuring efficient handling of middleware arrays while respecting configurations such as `allowDuplicateMw`.\n\n---\n\n#### **1Ô∏è‚É£ Before Merging**\n\nInitial state of the `RootMiddlewares` router:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Contains middleware `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n#### **2Ô∏è‚É£ New RouterMiddlewares (To Merge)**\n\nMiddleware structure from a new router to be merged:\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Contains middleware `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n#### **3Ô∏è‚É£ After Merging**\n\nResulting structure of `RootMiddlewares` router after merging:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  <-- Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  <-- New Middleware Added\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are merged into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: A new child route with middleware `[m4]` added.\n\n---\n\n### **üîß Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option governs whether duplicate middleware functions are allowed during merging or registration.\n\n```typescript\n/**\n * `allowDuplicateMw` determines whether duplicate middleware functions\n * are allowed in the router.\n *\n * - When `true`: Allows the same middleware to be added multiple times.\n * - When `false`: Ensures each middleware is registered only once\n *   per route or application context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n#### **Usage**\n\n```typescript\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middlewares\n  overwriteMethod: false, // Preserves existing method handlers\n});\n```\n\n#### **Behavior**\n\n- **`allowDuplicateMw: true`**:\n\n  - Middlewares can be registered multiple times for the same route, allowing duplicates.\n  - Example after merging with duplicates:\n\n    ```plaintext\n    RootMiddlewares\n     ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n     ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  <-- Duplicates Permitted\n    ```\n\n- **`allowDuplicateMw: false`** (default):\n\n  - Duplicates are filtered out, ensuring no repetition in the middleware array.\n  - Example after merging:\n\n    ```plaintext\n    RootMiddlewares\n     ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n     ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  <-- No Duplicates\n    ```\n\n---\n\n### **üîë Key Takeaways**\n\n- ‚úÖ **Merges Middleware at the Same Path**: When paths match (e.g., `/test`), middleware arrays are combined, respecting `allowDuplicateMw`.\n- ‚úÖ **Recursively Merges Nested Middleware**: Child routes (e.g., `/test/2`) are recursively added or merged into the router.\n- ‚úÖ **Memory Optimization**: After merging, middleware arrays are cleared (`middlewares.length = 0`), and child nodes are cleared (`children.clear()`) to optimize memory usage.\n\n---\n\n### **üåü Final Summary**\n\n- **Recursive Approach**: The function uses a recursive strategy to merge nested middlewares, ensuring all levels of the route tree are handled.\n- **Memory Optimization**: Efficient memory usage is achieved by resetting unused arrays and child collections after the merge.\n\n---\n\n### **Example**\n\n#### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n#### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n#### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  <-- Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  <-- New Child Middleware\n```\n\nWith `allowDuplicateMw: true`, adding `rateLimiter` again to `/api/users` would result in `[authMiddleware, rateLimiter, rateLimiter]`.\n\n---\n"
    },
    {
      "id": 9,
      "path": "api/middleware-api/middleware",
      "name": "Middleware",
      "folder": "API/Middleware API",
      "content": "# **Middleware Guide**\n\nMiddleware allows handling requests before they reach the final route handler. It can be used for authentication, logging, rate limiting, etc.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\n```typescript\ntype Middleware<T> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => NextCallback | Promise<TezResponse> | TezResponse;\n```\n\n- **Purpose**: Defines middleware that processes requests and optionally calls the next middleware or handler in the chain.\n- **Parameters**:\n  - `ctx`: The request context, typed with custom properties via `T`.\n  - `next`: A callback to invoke the next middleware or handler.\n- **Returns**: Either `next()` (to continue the chain), a `TezResponse`, or a `Promise<TezResponse>`.\n\n**Example**:\n\n```typescript\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  return next(); // Proceed to next middleware or handler\n};\n```\n\n### **2. `Callback<T>`**\n\n```typescript\ntype Callback<T> = (ctx: ctx<T>) => Promise<TezResponse> | TezResponse;\n```\n\n- **Purpose**: Defines a final request handler that does not invoke `next`.\n- **Parameters**:\n  - `ctx`: The request context.\n- **Returns**: A `TezResponse` or `Promise<TezResponse>`.\n\n**Example**:\n\n```typescript\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n### **3. `ctx<T>`**\n\n```typescript\ntype ctx<T = {}> = Context<T> & T;\n```\n\n- **Purpose**: A flexible context object combining framework-provided properties (e.g., `req`, `json`) with custom user-defined properties via `T`.\n- **Example**:\n\n```typescript\ninterface AuthContext {\n  user: User;\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.headers.get(\"Authorization\"));\n  return next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                          |\n| --------------------- | ------------------------------- | ------------------------------------ |\n| **Path + Middleware** | `.use('/api', auth)`            | Applies middleware to `/api` routes  |\n| **Path + Multiple**   | `.use('/admin', [auth, audit])` | Chains multiple middleware for path  |\n| **Path + Callback**   | `.use('/v1', v1Router)`         | Mounts a sub-router at `/v1`         |\n| **Global Middleware** | `.use(logger)`                  | Applies middleware to all routes     |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```typescript\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```typescript\nserver\n  .use(\"/api\", apiRateLimiter) // Rate limiting for /api routes\n  .group(\"/api\", (group) => {\n    group.use(authMiddleware); // Authentication for /api sub-routes\n    group.get(\"/data\", fetchDataHandler);\n  });\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```typescript\nserver.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array for uploads\n  uploadRouter, // Sub-router for upload routes\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in the order of registration, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\nRegister global middleware first, followed by path-specific middleware and handlers.\n\n```typescript\nserver\n  .use(requestID) // Assigns unique request IDs\n  .use(logger) // Logs requests\n  .use(errorHandler); // Catches errors last\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```typescript\n  server.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Specify exact paths.\n\n  ```typescript\n  server.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\nLeverage TypeScript generics for type-safe context extensions.\n\n```typescript\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\nserver.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n  return next();\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```typescript\nserver.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```typescript\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\nserver.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```typescript\nserver.post(\n  \"/submit\",\n  bodyParser(),\n  validateSchema(submitSchema),\n  submitHandler,\n);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place sync middleware before async to minimize overhead.\n\n   ```typescript\n   server\n     .use(syncOperation) // Fast, synchronous\n     .use(asyncMiddleware); // Slower, asynchronous\n   ```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Move intensive tasks (e.g., file processing) to handlers.\n\n   ```typescript\n   // ‚ùå Avoid in middleware\n   await processLargeFile();\n\n   // ‚úÖ Use in handler\n   server.get(\"/process\", (ctx) => processLargeFile());\n   ```\n\n3. **Cache Repeated Operations**\n\n   - Store results of expensive computations in the context.\n\n   ```typescript\n   server.use((ctx, next) => {\n     ctx.cachedData = expensiveOperation();\n     return next();\n   });\n   ```\n\n---\n\n## **Error Reference**\n\n| Error Pattern                                 | Solution                                                  |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware matches `(ctx, next) => ...` signature  |\n| Missing `next()` call                         | Return `next()` or a `TezResponse` explicitly             |\n| Type mismatches in `ctx`                      | Check generic type `T` aligns with middleware and handler |\n\n---\n"
    },
    {
      "id": 10,
      "path": "api/router/basic",
      "name": "Basic",
      "folder": "API/Router",
      "content": "# **Router with Merging**\n\n---\n\n## **Overview of Routing**\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: A new routing structure to be merged into the parent router.\n- **Final Router**: The resulting structure after merging.\n\n---\n\n## **Example: Before Merge**\n\nHere‚Äôs an example of a parent router before any merging occurs:\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test` (root node) has a `GET` handler (`handler1`).\n- `/test/1` (child node) has its own `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\nA new sub-router can be merged into the parent router. Here‚Äôs an example of a new router to merge:\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2` has a `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\nWhen the new sub-router is merged into the parent router, the resulting structure depends on the merge logic and configuration (e.g., `overwriteMethod`). Here‚Äôs an example of the final router:\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- The `/test` branch remains unchanged.\n- The `/products` branch is added as a new root-level node with its child `/products/2`.\n\n**Note**: If the new sub-router had overlapping paths (e.g., `/test` instead of `/products`), the behavior would depend on the `overwriteMethod` setting (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option controls how `TezX` handles overlapping routes‚Äîi.e., when a new handler is added for the same path and HTTP method as an existing handler.\n\n### **Definition**\n\n```typescript\n/**\n * `overwriteMethod` controls whether existing route handlers\n * should be overwritten when a new handler for the same\n * HTTP method and path is added.\n *\n * - When `true`: The new handler replaces the existing one.\n * - When `false`: Prevents overwriting, ensuring that the\n *   first registered handler remains active.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```typescript\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware, if applicable\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n- **`overwriteMethod: true` (default)**:\n  - If a new `GET` handler is added to `/test` and a `GET` handler already exists, the new handler overwrites the old one.\n  - Example:\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n- **`overwriteMethod: false`**:\n  - The existing handler is preserved, and the new handler is ignored.\n  - Example:\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**: Sub-routers can be merged into the parent router without disrupting unrelated routes.\n2. **Overlapping Control**: Use `overwriteMethod` to decide how overlapping routes are handled.\n3. **Nested Routes**: Child nodes allow for deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Best Practices**\n\n- Set `overwriteMethod: false` in production environments to prevent accidental overwriting of critical handlers.\n- Use descriptive handler names or logging to debug route conflicts.\n- Test merged router thoroughly to ensure the final structure matches your expectations.\n\n---\n"
    },
    {
      "id": 11,
      "path": "api/router/router",
      "name": "Router",
      "folder": "API/Router",
      "content": "# Router API\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\n**Hierarchical routing system with middleware support**\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes          |\n| **Middleware Chain** | Sequential execution of pre/post processors   |\n| **Path Isolation**   | Routes inherit parent path prefix             |\n| **Type Propagation** | Maintain typed context through nested routers |\n\n---\n\n### **2. Middleware System**\n\n#### **Execution Flow**\n\n```js\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **2. Route Groups**\n\n#### Logical grouping of routes with shared configuration\n\n```ts\napp.group(\"/admin\", (group) => {\n  // Shared middleware for admin routes\n  group.use(adminAuth, auditLogger);\n\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\n#### Mount sub-router with path prefix\n\n| Parameter | Type     | Description                            |\n| --------- | -------- | -------------------------------------- |\n| `path`    | `string` | Base path for all routes in sub-router |\n| `router`  | `Router` | Configured router instance             |\n\n**Example:**\n\n```ts\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount under /auth prefix\n// ‚ùå not support middleware chain. Please use app.use(....)\napp.addRouter(\"/auth\", authRouter);\n// or\n//‚úÖ It support middleware chain\napp.use(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n```ts\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// ‚ùå not use wildcard\n// Mount under /auth prefix\napp.addRouter(\"/auth/*\", authRouter);\n// or\n// ‚ùå not use wildcard\napp.use(\"/auth/*\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n```ts\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// ‚ùå not use optional params\n// Mount under /auth prefix\napp.addRouter(\"/auth/:version?\", authRouter);\n// or\n// ‚ùå not ues optional params\napp.use(\"/auth/auth/:version?\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n**Note** : If you `app.use` or `app.addRouter` with path pass a new Router path must be static or dynamic params.(not use wildcard and optional params)\n\nIf you want to use wildcards or optional parameters in the router:\n\n```ts\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\n**Support dynamic params, optional params, wildcard**\n**Create scoped route group**\n\n| Parameter  | Type       | Description                             |\n| ---------- | ---------- | --------------------------------------- |\n| `prefix`   | `string`   | Path segment for group                  |\n| `callback` | `function` | Receives group-specific router instance |\n\n**Advanced Example:**\n\n```ts\napp.group(\"/api/v1\", (group) => {\n  // Group-level middleware\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n\n// Resulting paths:\n// /api/v1/users/123\n// /api/v1/posts/456\n```\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\n```ts\n// Global middleware (applies to all routes)\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n### **2. Context Propagation**\n\n**Type-safe context inheritance:**\n\n```ts\ninterface CustomContext {\n  user?: User;\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  // ctx is typed as CustomContext\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found**\n\n**Type-safe context inheritance:**\n\n```ts\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n`notFound` handler will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n\n---\n\n### **3. Error**\n\n**Type-safe context inheritance:**\n\n```ts\napp.onError((error, ctx) => {\n  return ctx.text(error, 500);\n});\n```\n\n`onError` handler will overwrite ‚Üí Descending (from parent to child) ‚úÖ\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\n```bash\nroutes/\n‚îú‚îÄ auth/\n‚îÇ  ‚îú‚îÄ login.ts\n‚îÇ  ‚îú‚îÄ logout.ts\n‚îú‚îÄ api/\n‚îÇ  ‚îú‚îÄ v1/\n‚îÇ  ‚îÇ  ‚îú‚îÄ users.ts\n‚îÇ  ‚îú‚îÄ v2/\n‚îÇ     ‚îú‚îÄ users.ts\n```\n\n---\n\n<!--\n## **Configuration Options**\n\n```ts\nnew Router({\n  caseSensitive: false, // /Users vs /users\n  strictPaths: true,    // /users/ vs /users\n  maxNesting: 5,        // Prevent infinite loops\n  autoHead: true        // Auto-create HEAD routes\n});\n``` -->\n"
    },
    {
      "id": 12,
      "path": "api/router/route-parameter",
      "name": "Route Parameter",
      "folder": "API/Router",
      "content": "---\n## Parameter Types\n\n### 1. Standard Parameters (`:param`)\n\nCapture dynamic path segments between slashes\n\n**Syntax:**\n\n```typescript\n\"/path/:parameterName\"\n```\n\n**Examples:**\n\n```ts\napp.get(\"/users/:id\", (ctx) => {\nctx.params.id // => \"123\" from /users/123\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\nctx.params.year  // => \"2023\"\nctx.params.month // => \"09\"\n});\n```\n\n**Characteristics:**\n\n- Mandatory path segments\n- Match until next `/` character\n- Must appear in order declared\n---\n\n### 2. Optional Parameters (`:param?`)\n\nMatch segments that may or may not exist\n\n**Syntax:**\n\n```typescript\n\"/path/:optionalParam?\";\n```\n\n**Examples:**\n\n```ts\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // Matches:\n  // - /archive/2023/08 => year: \"2023\", month: \"08\"\n  // - /archive/2023     => year: \"2023\", month: undefined\n  // - /archive          => year: undefined, month: undefined\n});\n```\n\n**Characteristics:**\n\n- Can be omitted from request\n- Must be sequential at end of path\n- Intermediary optional params require subsequent params to also be optional\n\n---\n\n### 3. Wildcard Parameters (`*`)\n\nCapture all remaining path segments\n\n**Syntax:**\n\n```typescript\n\"/path/*wildcardParam\";\n```\n\n**Examples:**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg =>\n  // ctx.params.path = \"images/2023/photo.jpg\"\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints =>\n  // ctx.params.category = \"api/v2/endpoints\"\n});\n```\n\n**Characteristics:**\n\n- Always returns string (never undefined)\n- Must be final segment in route\n- Matches all remaining path segments\n- Supports nested directory structures\n\n---\n\n## Matching Priority\n\nRoutes are matched with following priority order:\n\n1. Static paths (`/users/list`)\n2. Named parameters (`/users/:id`)\n3. Wildcard parameters (`/users/*`)\n4. Optional parameters (`/users/:id?`)\n\n**Example Hierarchy:**\n\n```ts\napp.get(\"/users/list\", handleList); // Highest priority\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll); // Lowest priority\n```\n\n---\n\n## Parameter Access\n\nCaptured parameters are available in `ctx.req.params`:\n\n```ts\ninterface Params {\n  [key: string]: string | undefined;\n}\n\n// Example usage:\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string\n  // item: string | undefined\n});\n```\n\n---\n\n## Conflict Resolution\n\n### Ambiguous Routes\n\n```ts\n// ‚ùå Conflicting routes\n// ‚ùì Will be overwritten by the last handler.\n// Output: {name: \"Jhon\"}\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/:name\", handleByName); // Will execute be reached\n\n// ‚úÖ Solution: Use distinct paths\napp.get(\"/users/id/:id\", handleUser);\napp.get(\"/users/name/:name\", handleByName);\n```\n\n### Wildcard Position\n\n```ts\n// ‚ùå Invalid wildcard placement\napp.get(\"/*/profile\", handleProfile);\n\n// ‚úÖ Valid usage\napp.get(\"/user/*/profile\", handleProfile); // Static segment before wildcard\n```\n\n---\n\n## Escaping Special Characters\n\nTo match literal `:` or `*`, escape with backslash:\n\n```ts\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n});\n```\n\n---\n\n## Best Practices\n\n1. **Order Routes by Specificity:** Place static routes before dynamic ones\n2. **Validate Parameters:** Always sanitize and validate parameter values\n3. **Use Optional Sparingly:** Prefer explicit routes for better visibility\n4. **Document Complex Routes:** Add comments for routes with multiple parameters\n5. **Limit Wildcard Scope:** Use specific patterns before wildcards when possible\n\n```ts\n// Good practice example\napp.get(\"/api/v1/:version/:resource\", (ctx) => {\n  const version = parseInt(ctx.params.version || \"\");\n  if (isNaN(version)) ctx.status(400).send(\"Invalid version\");\n});\n```\n\n---\n\n## Conflict Resolution Table\n\n| Path        | Priority | Notes                                  |\n| ----------- | -------- | -------------------------------------- |\n| /users/list | High     | Specific method + param (static match) |\n| /users/:id  | High     | Specific method + param                |\n| /users      | Medium   | Specific method                        |\n| /users/\\*   | Low      | Wildcard has lowest priority           |\n\n### **Same as post, put, ... http method**\n\n---\n\n## `all()` - Universal Method Handler\n\n**Catches ALL HTTP methods for a specific path**\n\n### Signature\n\n```typescript\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### Path Parameter Support\n\n```ts\n|Type            | Example              | Captured Values\n----------------|----------------------|-------------------\nStandard        | /:version/api        | version: \"v2\"\nOptional        | /user/:id?/profile   | id: \"123\" or undefined\nWildcard        | /docs/*              | *: \"getting-started\"\nMixed           | /:lang?/api/*        | lang: \"en\", *: \"v2/endpoints\"\n```\n\n### Examples\n\n**Basic Usage:**\n\n```ts\n// Handle all methods to /healthcheck\napp.all(\"/healthcheck\", (ctx) => {\n  ctx.text(`Method ${ctx.method} received`);\n});\n\n// GET/POST/PUT/DELETE etc to /healthcheck\n// ‚Üí \"Method GET received\"\n```\n\n**With Parameters:**\n\n```ts\napp.all(\"/*service/status\", (ctx) => {\n  ctx.json({\n    servicePath: ctx.params.service, // \"auth/api\"\n    wildcard: ctx.params[\"wildcard\"], // \"auth/api\"\n    method: ctx.method,\n  });\n});\n\n// PUT /auth/api/v2/status ‚Üí\n// { servicePath: \"auth/api/v2\", wildcard: \"auth/api/v2\", method: \"PUT\" }\n```\n\n**With Middleware:**\n\n```ts\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  ctx.text(`Accessed ${ctx.params.zone || \"default\"} zone`);\n});\n\n// POST /secure/admin ‚Üí Runs middlewares, handles zone=\"admin\"\n```\n\n---\n\n## `addRoute()` - Custom Method Registration\n\n**Handle non-standard/custom HTTP methods**\n\n### Signature\n\n```typescript\npublic addRoute(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### Supported Methods\n\n```ts\nStandard Methods | Custom Examples\n-----------------|-----------------\nGET, POST, PUT   | PURGE, LOCK\nPATCH, DELETE    | COPY, SEARCH\nHEAD, OPTIONS    | CUSTOM_API\n```\n\n### Parameter Examples\n\n**Custom Method with Parameters:**\n\n```ts\n// Register PURGE method\napp.addRoute(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group, // \"user-profiles/v2\"\n  });\n  ctx.status(202);\n});\n\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí Success\n```\n\n**Optional Parameters:**\n\n```ts\napp.addRoute(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.params.type || \"daily\");\n});\n\n// REPORT /stats/weekly ‚Üí type=\"weekly\"\n// REPORT /stats ‚Üí type=\"daily\"\n```\n\n**Wildcard Capture:**\n\n```ts\napp.addRoute(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n});\n\n// MSEARCH /files/docs/archived/project.txt\n```\n\n---\n\n## Parameter Access Pattern\n\n```ts\ninterface Context {\n  params: {\n    [key: string]: string | undefined;\n    \"*\"?: string; // Wildcard capture\n  };\n}\n\n// Access patterns\nctx.req.params.paramName; // Standard/optional params\nctx.req.params[\"*\"]; // Wildcard value\nctx.req.params[0]; // Not used - named params only\n```\n\n---\n\n## Best Practices\n\n### For `all()`\n\n1. Use for:\n   - Maintenance mode handlers\n   - Global path-specific middleware\n   - Method-agnostic endpoints\n2. Avoid:\n   - Complex business logic\n   - Overlapping with specific method handlers\n3. Ordering:\n\n   ```ts\n   app.get(\"/api\", specificHandler); // Higher priority\n   app.all(\"/*api\", globalMiddleware); // Lower priority\n   ```\n\n### For `addRoute()`\n\n1. Use for:\n   - Custom HTTP methods (RFC 2518 WebDAV, etc)\n   - Proprietary API methods\n   - Experimental features\n2. Compatibility:\n\n   ```ts\n   // Check method support\n   if (!ctx.methodSupported(\"PURGE\")) {\n     ctx.status(405).header(\"Allow\", \"PURGE, GET\");\n   }\n   ```\n\n3. Security:\n   - Explicitly document non-standard methods\n   - Handle CORS/preflight appropriately\n\n---\n\n## Conflict Resolution Table\n\n| Method            | Path         | Priority | Match Example           |\n| ----------------- | ------------ | -------- | ----------------------- |\n| addRoute('PURGE') | /cache       | High     | PURGE /cache            |\n| all()             | /cache/\\*    | Medium   | GET/POST etc /cache/123 |\n| get()             | /cache/clear | Highest  | GET /cache/clear        |\n\n**Resolution Rules:**\n\n1. Exact method matches take priority over `all()`\n2. Specific paths beat wildcards\n3. Registration order matters for same-priority routes\n\n---\n"
    },
    {
      "id": 13,
      "path": "api/context/basic",
      "name": "Basic",
      "folder": "API/Context",
      "content": "## **Public Properties**\n\n| Property   | Type            | Description                                             |\n| ---------- | --------------- | ------------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration                 |\n| `headers`  | `HeadersParser` | HTTP headers parser instance                            |\n| `pathname` | `string`        | Request path without query parameters                   |\n| `url`      | `string`        | Full request URL including protocol and query string    |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (GET/POST/PUT etc)                |\n| `state`    | `State`         | Application state container for middleware data sharing |\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nManages cookies with chainable methods:\n\n```ts\n// Get cookie value\nconst session = ctx.cookies.get('sessionID');\n\n// Set new cookie\nctx.cookies.set('prefs', darkMode:true, {\n  maxAge: 3600\n});\n\n// Delete cookie\nctx.cookies.delete('oldSession');\n```\n\n**Methods:**\n\n| Method   | Parameters                                                 | Description                             |\n| -------- | ---------------------------------------------------------- | --------------------------------------- |\n| `get`    | `name: string`                                             | Returns cookie value or `undefined`     |\n| `all`    | -                                                          | Returns all cookies as key-value object |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets cookie with options                |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates cookie                      |\n\n**CookieOptions:**\n\n```ts\ninterface CookieOptions {\n  domain?: string;\n  path?: string;\n  expires?: Date;\n  maxAge?: number;\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: \"Strict\" | \"Lax\" | \"None\";\n}\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends JSON response:\n\n```ts\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, { \"Cache-Control\": \"no-store\" });\n```\n\n### **2. `send(body, status?, headers?)`**\n\nUniversal response handler with auto-detected content type:\n\n```ts\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(...), 201); // application/octet-stream\n```\n\n### **3. `html(data, status?, headers?)`**\n\nSends HTML content:\n\n```ts\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n### **4. `text(data, status?, headers?)`**\n\nSends plain text:\n\n```ts\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n### **5. `xml(data, status?, headers?)`**\n\nSends XML content:\n\n```ts\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n### **6. `redirect(url, status=302, headers?)`**\n\nPerforms HTTP redirect:\n\n```ts\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers file download:\n\n```ts\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n### **8. `status(code)`**\n\nSets HTTP status code (chainable):\n\n```ts\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides normalized request object:\n\n```ts\ninterface Request {\n  method: HTTPMethod;\n  headers: HeadersParser;\n  params: Record<string, any>;\n  // ... other request properties\n}\n\n// Usage\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Example Workflow**\n\n```ts\n// Middleware example\napp.use(async (ctx, next) => {\n  // Set request ID\n  ctx.requestId = crypto.randomUUID();\n\n  // Authentication check\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n\n// Route handler\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n### **Headers (`headers`)**\n\n```ts\n// Get authorization header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Add custom header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n**Common Operations**:\n\n```ts\n// Check content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Parse JSON body\n}\n\n// Set multiple response headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Best Practices**\n\n1. **State Management**\n\n   ```ts\n   // Middleware sets state\n   ctx.state.set(\"user\", authenticatedUser);\n\n   //or\n   ctx.user = authenticatedUser; //context propagation\n\n   // Route handler accesses\n   const currentUser = ctx.state.get(\"user\");\n   ```\n\n2. **Header Validation**\n\n   ```ts\n   const contentType = ctx.req.headers.get(\"Content-Type\");\n   if (!allowedTypes.includes(contentType)) {\n     return ctx.status(415).text(\"Unsupported Media Type\");\n   }\n   ```\n\n3. **Parameter Sanitization**\n\n   ```ts\n   const userId = parseInt(ctx.req.params.id);\n   if (isNaN(userId)) {\n     return ctx.status(400).text(\"Invalid ID format\");\n   }\n   ```\n"
    },
    {
      "id": 14,
      "path": "api/context/state",
      "name": "State",
      "folder": "API/Context",
      "content": "# State management\n\n---\n\nPublic state container for application data. state storage for middleware and plugins\n\n## Usage Example\n\n```typescript\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\nconsole.log(ctx.state.get(\"user\")); // Output: { id: 1, name: \"Alice\" }\n```\n\n## Class Definition\n\n```typescript\nexport class State {\n    private state: Map<string, any>;\n\n    constructor() {\n        this.state = new Map();\n    }\n```\n\n### Methods\n\n#### `set(key: string, value: any): void`\n\nStores a value associated with a specific key.\n\n**Parameters:**\n\n- `key` (string): The key for the value.\n- `value` (any): The value to be stored.\n\n**Example:**\n\n```typescript\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n#### `get(key: string): any | undefined`\n\nRetrieves a stored value by key.\n\n**Parameters:**\n\n- `key` (string): The key of the value to retrieve.\n\n**Returns:**\n\n- The stored value or `undefined` if not found.\n\n**Example:**\n\n```typescript\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n#### `delete(key: string): boolean`\n\nDeletes a stored value by key.\n\n**Parameters:**\n\n- `key` (string): The key to remove.\n\n**Returns:**\n\n- `true` if the key was deleted, `false` otherwise.\n\n**Example:**\n\n```typescript\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n#### `has(key: string): boolean`\n\nChecks if a key exists in storage.\n\n**Parameters:**\n\n- `key` (string): The key to check.\n\n**Returns:**\n\n- `true` if the key exists, `false` otherwise.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n#### `keys(): string[]`\n\nReturns an array of all stored keys.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n#### `values(): any[]`\n\nReturns an array of all stored values.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n#### `entries(): [string, any][]`\n\nReturns an array of key-value pairs.\n\n**Example:**\n\n```typescript\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n#### `clear(): void`\n\nRemoves all stored entries.\n\n**Example:**\n\n```typescript\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n"
    },
    {
      "id": 15,
      "path": "api/context/context-propagation",
      "name": "Context Propagation",
      "folder": "API/Context",
      "content": "---\n# Context Propagation\n\n## Overview\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and handlers. It ensures strict type validation while allowing hierarchical context extension.\n---\n\n## Core Concepts\n\n### 1. Type-Safe Context Definition\n\nDefine your context shape using TypeScript interfaces:\n\n```typescript\ninterface CustomContext {\n  // Optional authentication data\n  user?: User;\n\n  // Required request identifier\n  requestId: string;\n\n  // Add other request-specific properties\n  // logger?: Logger\n  // db?: DatabaseConnection\n}\n```\n\n### 2. Router Initialization\n\nCreate a router with your context type:\n\n```typescript\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n### 3. Middleware Implementation\n\nAdd context-enriching middleware with full type safety:\n\n```typescript\n// Authentication middleware\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Request ID middleware\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n### 4. Handler Access\n\nAccess validated context properties in endpoints:\n\n```typescript\napp.get(\"/profile\", (ctx) => {\n  // TypeScript automatically infers context shape\n  return Response.json({\n    id: ctx.requestId,\n    user: ctx.user.email, // Safe access to user data\n  });\n});\n```\n\n---\n\n## Advanced Features\n\n### Context Composition\n\nMerge multiple context types for modular development:\n\n```typescript\ninterface AuthContext {\n  user: User;\n  session: Session;\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n### Validation Middleware\n\nEnsure context integrity with validation:\n\n```typescript\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## Error Handling\n\n### Type Safety Guards\n\nThe compiler prevents common mistakes:\n\n```typescript\napp.use((ctx, next) => {\n  // Type Error: Property 'newProp' does not exist\n  ctx.newProp = \"value\";\n  // Type Error: requestId must be string\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n### Optional Properties\n\nSafely handle partial context:\n\n```typescript\napp.get(\"/public\", (ctx) => {\n  // user is optional - check existence\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## Best Practices\n\n1. **Initialization Order**\n\n   - Set critical context properties early in the middleware chain\n   - Place validation middleware after property initialization\n\n2. **Immutability**\n\n   ```typescript\n   // Avoid:\n   ctx.user = { ...ctx.user, ...newData };\n\n   // Prefer:\n   const updatedUser = { ...ctx.user, ...newData };\n   ```\n\n3. **Testing Patterns**\n\n   ```typescript\n   // Mock context for testing\n   const testCtx: CustomContext = {\n     requestId: \"test-123\",\n     user: mockUser,\n   };\n   ```\n\n---\n\n### Context Lifecycle\n\n1. Initialization\n2. Middleware Processing\n3. Handler Execution\n4. Cleanup Hooks\n\n---\n"
    },
    {
      "id": 16,
      "path": "api/context/cookies",
      "name": "Cookies",
      "folder": "API/Context",
      "content": "# Cookies\n\n---\n\n## **Setting and Retrieving Cookies in `PUT /data` Route**\n\n```ts\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { HttpOnly: true, Secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie\n  // ctx.cookies.delete('sessionToken');\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                         |\n| ---------------------------- | ------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie.               |\n| `all()`                      | Returns an object containing all cookies.               |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.             |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration in the past. |\n\n---\n\n## **Example Usage in a Client Request**\n\n### **Sending a Cookie with Fetch API**\n\n```js\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // its mandatory\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data));\n```\n\n## **Security Considerations**\n\nWhen handling cookies, consider the following:\n\n1. **Use `HttpOnly` for Security:** Prevents JavaScript access to cookies, reducing XSS risks.\n2. **Use `Secure` for HTTPS:** Ensures cookies are only transmitted over HTTPS.\n3. **Use `SameSite` to Prevent CSRF:**\n   - `SameSite=Strict`: Blocks all cross-site requests.\n   - `SameSite=Lax`: Allows safe cross-site navigation.\n   - `SameSite=None; Secure`: Required for cross-origin cookies (e.g., third-party cookies).\n4. **Set Expiry for Session Management:** Use `expires` to define cookie lifespan.\n5. **Enable Path Restriction:** Restrict cookies to specific paths using `Path=/some-path`.\n\n---\n\n### **Notes**\n\n- Cookies can have attributes like `HttpOnly`, `Secure`, `SameSite`, and `Expires`.\n- Ensure that **cookies are sent with credentials (`credentials: 'include'`)** if needed.\n"
    },
    {
      "id": 17,
      "path": "api/request/request",
      "name": "Request",
      "folder": "API/Request",
      "content": "---\n\n## **Request Handling API**\n\n## **1. Method**\n\n**Retrieves the HTTP request method.**\n\n```ts\n// Example: GET, POST, PUT, DELETE, etc.\nconst method = ctx.req.method; \n```\n\n**Properties**:\n\n- Read-only property\n- Always returns uppercase method name\n\n**Example**:\n\n```ts\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n**Deconstructed URL components.**\n\n```ts\ninterface UrlRef {\n  hash?: string; // #section\n  protocol?: string; // \"http:\" or \"https:\"\n  origin?: string; // \"https://example.com:8080\"\n  username?: string; // Auth username\n  password?: string; // Auth password\n  hostname?: string; // \"example.com\"\n  port?: string; // \"8080\"\n  href?: string; // Full URL string\n  query: Record<string, string>; // Parsed query parameters\n  pathname: string; // \"/api/v2/users\"\n}\n```\n\n**Usage**:\n\n```ts\nconst url = ctx.req.urlRef;\n\n// Example for \"https://api.com:8080/users?id=123#details\"\nconsole.log(url.port); // \"8080\"\nconsole.log(url.hostname); // \"api.com\"\nconsole.log(url.query); // { id: \"123\" }\nconsole.log(url.hash); // \"details\"\n```\n\n**Note**: Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n**Parsed URL query string parameters.**\n\n```ts\n// URL: /search?q=term&page=2&filter=new\nconst query = ctx.req.query;\n/* Returns:\n{\n  q: \"term\",\n  page: \"2\",\n  filter: \"new\"\n} */\n```\n\n**Behavior**:\n\n- Decodes URL-encoded values\n- Last value wins for duplicate keys\n- Returns empty object if no query\n\n**Example**:\n\n```ts\napp.get(\"/products\", (ctx) => {\n  const page = ctx.req.query.page || \"1\";\n  // Pagination logic\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n**Captured route parameters from path patterns.**\n\n**Route Patterns**:\n\n```ts\n// Route definition\napp.get(\"/users/:id/posts/:slug*\", handler);\n\n// Request: /users/42/posts/announcements/2023\nctx.req.params = {\n  id: \"42\",\n  slug: \"announcements/2023\", // Wildcard capture\n};\n```\n\n**Supported Patterns**:\n\n| Pattern   | Example Route   | Request Path       | Result                    |\n| --------- | --------------- | ------------------ | ------------------------- |\n| `:param`  | /users/:id      | /users/42          | `{ id: \"42\" }`            |\n| `:param?` | /archive/:year? | /archive           | `{ year: null }`          |\n| `*`       | /files/\\*path   | /files/docs/readme | `{ path: \"docs/readme\" }` |\n\n**Best Practices**:\n\n```ts\n// Validate numeric ID\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400);\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n```ts\n// Get authorization header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Add custom header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n**Common Operations**:\n\n```ts\n// Check content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Parse JSON body\n}\n\n// Set multiple response headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Request Flow Diagram**\n\n```bash\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler:\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send data\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\nHandle request bodies with built-in parsers for various content types.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON validation            |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | File uploads + form fields |\n\n---\n\n### **1. Text Parsing**\n\n**Use Case:** Plaintext, XML, CSV, or custom formats  \n**Max Size:** Configurable via `maxBodySize`\n\n```ts\n// Basic text parsing\nconst rawText = await ctx.req.text();\n\n// With error handling\ntry {\n  const config = await ctx.req.text();\n  // Process text content\n} catch (error) {\n  ctx.status(400).text(\"Invalid text payload\");\n}\n```\n\n---\n\n### **2. JSON Parsing**\n\n**Automatic Validation:**\n\n```ts\ntry {\n  const data = await ctx.req.json();\n} catch (error) {\n  ctx.status(422).json({ error: \"Validation failed\" });\n}\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```ts\nconst form = await ctx.req.formData();\nconsole.log(form.username); // \"john_doe\"\n```\n\n#### **Multipart File Uploads**\n\n```ts\n// File upload configuration\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\nconst form = await ctx.req.formData(config);\nconst file = form.avatar as File;\n\n// Save to filesystem\nconst buffer = await file.arrayBuffer();\nwriteFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n```\n\n---\n\n### **4. File Upload Example**\n\n**Route Handler:**\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n\n    const files = form.attachments;\n    let results = [];\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n**Client-Side Upload:**\n\n```js\nconst form = new FormData();\nform.append(\"avatar\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n"
    },
    {
      "id": 18,
      "path": "api/request/body-parser",
      "name": "Body Parser",
      "folder": "API/Request",
      "content": "# Body Parser\n\n---\n\n- **Text parsing**\n- **JSON parsing**\n- **URL-encoded form parsing**\n- **Multipart form-data parsing** (including file handling)\n\n---\n\n## **Body Parser**\n\n### **1. Parsing Text Requests**\n\nThe `text()` method reads and returns the request body as a string.\n\n```ts\nconst body = await ctx.req.text();\n```\n\n---\n\n### **2. Parsing JSON Requests**\n\nThe `json()` method ensures that the content type is `application/json` before parsing the request body.\n\n```ts\nconst body = await ctx.req.json();\n```\n\n---\n\n### **3. Parsing Form Data (URL-Encoded & Multipart)**\n\nThe `formData()` method dynamically detects and parses form submissions, handling:\n\n- **JSON (`application/json`)**\n- **URL-encoded (`application/x-www-form-urlencoded`)**\n- **Multipart form-data (`multipart/form-data`)**, including file uploads.\n\n```ts\nconst body = await ctx.req.formData();\n```\n\n---\n\n## **Example: File Upload Route**\n\nThis route:\n\n- Accepts file uploads via `multipart/form-data`\n- Saves the file to the **uploads** directory\n- Responds with the file path\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n\n## **Send buffer**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file find\" }, 400);\n  }\n  const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n  return ctx.send(buffer, {\n    \"Content-Type\": file.type, // its required\n  });\n});\n```\n\n---\n\n## **Usage Example: Uploading a File via `fetch`**\n\nHere‚Äôs how a client can send a file to this endpoint using JavaScript:\n\n```js\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"file\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Feature      | Description                                                           |\n| ------------ | --------------------------------------------------------------------- |\n| `text()`     | Reads request body as a string.                                       |\n| `json()`     | Parses `application/json` data.                                       |\n| `formData()` | Parses `application/x-www-form-urlencoded` and `multipart/form-data`. |\n\n---\n\n```ts\n// Generic Form Handling\nconst form = await ctx.req.formData();\n\n// Accessing Values\nconst username = form.username;\nconst avatar = form.avatar as File;\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```ts\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB\n  allowedTypes?: string[]; // ['image/*', 'application/pdf']\n  maxFiles?: number; // Default: undefine\n}\n```\n\n### **cURL Upload**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/upload\n```\n\n### **2. Browser Fetch with Progress**\n\n```js\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"file\", file);\n\n  const response = await fetch(\"/upload\", {\n    method: \"POST\",\n    body: form,\n    headers: {\n      \"X-Upload-Token\": \"auth_token_here\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Upload failed: ${await response.text()}`);\n  }\n\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing:** For large files, use streaming instead of full buffering\n\n   ```ts\n   const stream = file.stream();\n   const transformer = new TransformStream();\n   // Add processing logic\n   ```\n\n2. **Memory Management:** Configure body parser limits based on expected payloads\n\n3. **Async Processing:** Handle file operations in background workers for large uploads\n\n4. **CORS Configuration:** Proper headers for cross-origin uploads\n\n   ```ts\n   ctx.headers.set(\"Access-Control-Allow-Origin\", \"trusted-domain.com\");\n   ```\n\n### **üõ†Ô∏è Example Usage**\n\n```javascript\nconst allowedTypes = [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"];\n\nconst formData = await ctx.req.formData({\n  sanitized: true, // Ensure filename is sanitized\n  allowedTypes, // Define accepted file types as an array\n  maxSize: 5000, // Max file size in KB (5MB)\n});\n```\n\n---\n\n## **üîπ API Reference: `ctx.req.formData(options)`**\n\n### **üìù Parameters**\n\n| Option         | Type       | Default    | Description                                                             |\n| -------------- | ---------- | ---------- | ----------------------------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | If `true`, filenames will be **sanitized** (remove special characters). |\n| `allowedTypes` | `string[]` | `[]`       | An **array of MIME types** (e.g., `[\"image/png\", \"image/jpeg\"]`).       |\n| `maxSize`      | `number`   | `Infinity` | Max file size allowed (in KB).                                          |\n\n---\n\n### **üîπ Return Value**\n\nThe function returns a **parsed form data object**:\n\n```javascript\n{\n    fields: { key1: \"value1\" }, // Form fields (non-file)\n    files: [\n        {\n            name: \"example.jpg\",\n            sanitizedName: \"example.jpg\",\n            type: \"image/jpeg\",\n            size: 1024, // File size in KB\n            path: \"/tmp/uploads/example.jpg\"\n        }\n    ]\n}\n```\n\n---\n\n## **üöÄ Examples**\n\n### **‚úÖ Allow Only PNG & JPEG Images**\n\n```javascript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **‚úÖ Allow Images & Videos**\n\n```javascript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // Max 8MB\n});\n```\n\n---\n\n## **‚ö†Ô∏è Error Handling**\n\n### **‚ùå If File Type is Not Allowed**\n\nIf a file type isn't in `allowedTypes`, it is **ignored** without throwing an error.\n\n### **‚ùå If File Exceeds `maxSize`**\n\n- The system **prevents** the upload of large files.\n\n### **‚ùå If No Files are Uploaded**\n\n- Returns an empty `files` array.\n\n---\n\n## **üõ†Ô∏è Best Practices**\n\n‚úÖ Use an **array for easier customization** (`allowedTypes`).  \n‚úÖ Always **sanitize filenames** if saving on a app.  \n‚úÖ Set a **reasonable file size limit** (`maxSize`).  \n‚úÖ Implement **logging** for skipped files.\n\n---\n"
    },
    {
      "id": 19,
      "path": "api/response/tezresponse",
      "name": "TezResponse",
      "folder": "API/Response",
      "content": "# **TezResponse**\n\n## Overview\n\nThe `TezResponse` class provides a set of static methods to simplify HTTP response handling in a web application. It supports various response types including JSON, HTML, text, XML, file downloads, and redirections.\n\n---\n\n## Import\n\n```ts\nimport { TezResponse } from \"jezx\";\n```\n\n## Or Custom Response\n\n```ts\napp.get('/data', async (ctx) => {\n    return new Response('Hello World', { status: 200 });\n});`\n```\n\n## Methods\n\n### `json`\n\n#### Description\n\nSends a JSON response.\n\n#### Parameters\n\n- `body: any` - The response data.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with JSON data.\n\n#### Usage\n\n```ts\nreturn TezResponse.json({ message: \"Success\" }, 200);\n// or using context\nreturn ctx.json({ message: \"Success\" }, 200);\n```\n\n---\n\n### `html`\n\n#### Description\n\nSends an HTML response.\n\n#### Parameters\n\n- `data: string` - The HTML content as a string.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with HTML data.\n\n#### Usage\n\n```ts\nreturn TezResponse.html(\"<h1>Welcome</h1>\", 200);\n// or using context\nreturn ctx.html(\"<h1>Welcome</h1>\", 200);\n```\n\n---\n\n### `text`\n\n#### Description\n\nSends a plain text response.\n\n#### Parameters\n\n- `data: string` - The text content.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with plain text data.\n\n#### Usage\n\n```ts\nreturn TezResponse.text(\"Hello, World!\", 200);\n// or using context\nreturn ctx.text(\"Hello, World!\", 200);\n```\n\n---\n\n### `xml`\n\n#### Description\n\nSends an XML response.\n\n#### Parameters\n\n- `data: string` - The XML content.\n- `status?: number` (Optional) - HTTP status code (default: 200).\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with XML data.\n\n#### Usage\n\n```ts\nreturn TezResponse.xml(\n  \"<note><to>User</to><message>Hello</message></note>\",\n  200,\n);\n// or using context\nreturn ctx.xml(\"<note><to>User</to><message>Hello</message></note>\", 200);\n```\n\n---\n\n### `send`\n\n#### Description\n\nSends a response with any content type, automatically determining the content type if not provided.\n\n#### Parameters\n\n- `body: any` - The response body.\n- `status?: number` (Optional) - HTTP status code.\n- `headers?: ResponseHeaders` (Optional) - Additional response headers.\n\n#### Returns\n\n`Response` object with the provided data.\n\n#### Usage\n\n```ts\nreturn TezResponse.send(\"Custom Content\", 200, { \"X-Custom-Header\": \"value\" });\n// or using context\nreturn ctx.send(\"Custom Content\", 200, { \"X-Custom-Header\": \"value\" });\n```\n\n---\n\n### `redirect`\n\n#### Description\n\nRedirects to a given URL.\n\n#### Parameters\n\n- `url: string` - The target URL.\n- `status?: number` (Optional) - HTTP status code (default: 302).\n- `headers?: ResponseHeaders` (Optional) - Additional headers.\n\n#### Returns\n\n`Response` object with redirect headers.\n\n#### Usage\n\n```ts\nreturn TezResponse.redirect(\"https://example.com\");\n// or using context\nreturn ctx.redirect(\"https://example.com\");\n```\n\n---\n\n### `download`\n\n#### Description\n\nHandles file downloads.\n\n#### Parameters\n\n- `filePath: string` - The path to the file.\n- `fileName: string` - The name of the downloaded file.\n\n#### Returns\n\nA `Promise<Response>` object for file download.\n\n#### Usage\n\n```ts\nreturn await TezResponse.download(\"/path/to/file.pdf\", \"document.pdf\");\n// or using context\nreturn ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n```\n\n---\n\n### `sendFile`\n\n#### Description\n\nServes a static file to the client.\n\n#### Parameters\n\n- `filePath: string` - Absolute or relative path to the file.\n- `fileName?: string` (Optional) - The name of the sent file.\n\n#### Returns\n\nA `Promise<Response>` object with the file stream.\n\n#### Usage\n\n```ts\nreturn await TezResponse.sendFile(\"/path/to/image.jpg\", \"picture.jpg\");\n// or using context\nreturn ctx.sendFile(\"/path/to/image.jpg\", \"picture.jpg\");\n```\n\n---\n\n## Notes\n\n- The `TezResponse` class is designed to work in different runtime environments such as Node.js, Bun, and Deno.\n- Methods automatically handle appropriate content-type headers.\n- `download` and `sendFile` methods check for file existence and serve accordingly.\n\n---\n\n## Example Usage in an Express-like Framework\n\n```ts\napp.get(\"/json\", (req, res) => {\n  return TezResponse.json({ message: \"Hello World\" });\n  // or using context\n  return ctx.json({ message: \"Hello World\" });\n});\n\napp.get(\"/redirect\", (req, res) => {\n  return TezResponse.redirect(\"https://example.com\");\n  // or using context\n  return ctx.redirect(\"https://example.com\");\n});\nf;\n```\n"
    },
    {
      "id": 20,
      "path": "headers-api",
      "name": "Headers API",
      "folder": ".",
      "content": "---\n\n# Headers API\n\n**Request and response headers are different.**\n\n---\n\n## **Core Methods**\n\n### **1. `add(headers: [string, string][] | Record<string, string>)`**\n\n**Purpose:** Add multiple headers without overwriting existing ones  \n**Behavior:**\n\n- Appends new headers while preserving existing ones\n- Merges values for duplicate headers\n\n```ts\n// Array of tuples example\nheaders.add([\n  [\"Content-Type\", \"application/json\"],\n  [\"Cache-Control\", \"max-age=3600\"],\n]);\n\n// Object example\nheaders.add({\n  \"X-Custom-Header\": \"Value1\",\n  \"Accept-Encoding\": \"gzip\",\n});\n```\n\n---\n\n### **2. `set(key: string, value: string | string[])`**\n\n**Purpose:** Create or overwrite a header  \n**Behavior:**\n\n- Replaces all existing values for this header\n- Accepts single value or array of values\n\n```ts\n// Single value\nheaders.set(\"Authorization\", \"Bearer abc123\");\n\n// Multiple values\nheaders.set(\"Accept-Language\", [\"en-US\", \"fr-FR\"]);\n```\n\n---\n\n### **3. `get(key: string): string | undefined`**\n\n**Purpose:** Retrieve first value of a header\n\n```ts\nconst contentType = ctx.req.headers.get(\"content-type\");\n// \"application/json\" (case-insensitive)\n```\n\n---\n\n### **4. `getAll(key: string): string[]`**\n\n**Purpose:** Retrieve all values of a header\n\n```ts\nconst languages = ctx.req.headers.getAll(\"accept-language\");\n// [\"en-US\", \"fr-FR\"]\n```\n\n---\n\n### **5. `has(key: string): boolean`**\n\n**Purpose:** Check header existence\n\n```ts\nif (ctx.req.headers.has(\"x-auth-token\")) {\n  // Handle authentication\n}\n```\n\n---\n\n### **6. `delete(key: string): boolean`**\n\n**Purpose:** Remove a header  \n**Returns:** `true` if header existed, `false` otherwise\n\n```ts\nconst existed = ctx.req.headers.delete(\"expires\");\n```\n\n---\n\n### **7. `append(key: string, value: string)`**\n\n**Purpose:** Add value to existing header or create new\n\n```ts\nheaders.append(\"Vary\", \"User-Agent\");\nheaders.append(\"Vary\", \"Accept-Encoding\");\n// Vary: User-Agent, Accept-Encoding\n```\n\n---\n\n## **Iteration Methods**\n\n### **8. `entries(): Iterable<[string, string[]]>`**\n\n**Purpose:** Get [key, values] iterator\n\n```ts\nfor (const [header, values] of headers.entries()) {\n  console.log(`${header}: ${values.join(\", \")}`);\n}\n```\n\n### **9. `keys(): Iterable<string>`**\n\n**Purpose:** Get header names iterator\n\n```ts\nfor (const headerName of headers.keys()) {\n  console.log(\"Header present:\", headerName);\n}\n```\n\n### **10. `values(): Iterable<string[]>`**\n\n**Purpose:** Get header values iterator\n\n```ts\nfor (const values of headers.values()) {\n  console.log(\"Values:\", values);\n}\n```\n\n---\n\n## **Utility Methods**\n\n### **11. `forEach(callback: (values: string[], key: string) => void)`**\n\n**Purpose:** Iterate through headers\n\n```ts\nheaders.forEach((values, key) => {\n  console.log(`Header ${key} has ${values.length} values`);\n});\n```\n\n### **12. `toObject(): Record<string, string | string[]>`**\n\n**Purpose:** Convert to plain JS object\n\n```ts\nconst headerObj = headers.toObject();\n/* Returns:\n{\n  \"content-type\": \"application/json\",\n  \"accept-language\": [\"en-US\", \"fr-FR\"]\n}\n*/\n```\n\n---\n\n## **Usage Patterns**\n\n### **Request Header Modification**\n\n```ts\n// Middleware to add security headers\napp.use(async (ctx) => {\n  ctx.headers\n    .set(\"X-Content-Type-Options\", \"nosniff\")\n    .set(\"Content-Security-Policy\", \"default-src 'self'\")\n    .delete(\"X-Powered-By\");\n\n  await ctx.next();\n});\n```\n\n### **Response Header Handling**\n\n```ts\n// API versioning example\napp.get(\"/data\", (ctx) => {\n  ctx.headers.set(\"X-API-Version\", \"2.1\").append(\"Vary\", \"Accept-Encoding\");\n\n  return ctx.json({ data: \"...\" });\n});\n```\n\n---\n\n## **Header Operations Cheat Sheet**\n\n| Method       | Description            | Mutable | Returns    |\n| ------------ | ---------------------- | ------- | ---------- | ---------- |\n| `add()`      | Add multiple headers   | ‚úÖ      | `void`     |\n| `set()`      | Replace header values  | ‚úÖ      | `void`     |\n| `get()`      | Get first header value | ‚ùå      | `string    | undefined` |\n| `getAll()`   | Get all header values  | ‚ùå      | `string[]` |\n| `has()`      | Check existence        | ‚ùå      | `boolean`  |\n| `delete()`   | Remove header          | ‚úÖ      | `boolean`  |\n| `append()`   | Add header value       | ‚úÖ      | `void`     |\n| `toObject()` | Serialize headers      | ‚ùå      | `Record`   |\n\n---\n"
    },
    {
      "id": 21,
      "path": "static-file",
      "name": "Static File",
      "folder": ".",
      "content": "---\n\n# **`static()` - Serve Static Files Efficiently**  \n\n## **Overview**  \n\nThe `static()` method allows serving static files (HTML, CSS, JS, images, videos, fonts, etc.) from a specified directory. It supports defining a **base route** or directly serving from the **root (`/`)** while offering customizable options like caching and indexing.  \n\n## **Usage**  \n\n### **1Ô∏è‚É£ Serve Static Files from the Root (`/`)**  \n\n```typescript\napp.static(\"./public\");\n```\n\n- Serves files from the **\"public\"** directory.  \n- Example: A file `public/style.css` will be accessible at `http://yourdomain.com/style.css`.  \n\n### **2Ô∏è‚É£ Serve Static Files from a Specific Route**  \n\n```typescript\napp.static(\"/static\", \"./assets\");\n```\n\n- Serves files from the **\"assets\"** directory under `/static`.  \n- Example: `assets/logo.png` will be available at `http://yourdomain.com/static/logo.png`.  \n\n### **3Ô∏è‚É£ Serve Static Files with Options**  \n\n```typescript\napp.static(\"./public\", { \n    cacheControl: \"public, max-age=3600\", \n     });\n```\n\n- Enables HTTP caching with **Cache-Control headers**.  \n\n---\n\n## **Method Signature**\n\n```typescript\nstatic(route: string, folder: string, option?: StaticServeOption): this;\nstatic(folder: string, option?: StaticServeOption): this;\n```\n\n## **Parameters**\n\n| Parameter             | Type                | Description                                                                                         |\n| --------------------- | ------------------- | --------------------------------------------------------------------------------------------------- |\n| `route` _(optional)_  | `string`            | The base route to serve static files from (e.g., `/public`). If omitted, files are served from `/`. |\n| `folder`              | `string`            | The directory containing static files.                                                              |\n| `option` _(optional)_ | `StaticServeOption` | Additional options for static file serving.                                                         |\n\n---\n\n## **üìå Available Options (`StaticServeOption`)**\n\nThe `option` parameter allows configuring various settings for serving static files.\n\n| Option         | Type             | Default      | Description                                                                            |\n| -------------- | ---------------- | ------------ | -------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Controls HTTP caching for files. Example: `\"public, max-age=3600\"` for 1-hour caching. |\n| `header`       | `HeaderResponse` | `undefined`  | Record of headers                                                                      |\n\n---\n\n## **üîπ Example Implementations**\n\n### **1Ô∏è‚É£ Enable Cache-Control for Performance**\n\n```typescript\napp.static(\"./public\", { cacheControl: \"public, max-age=86400\" }); // 1-day caching\n```\n\n## **üöÄ Return Value**\n\nReturns the current instance (`this`), allowing **method chaining**:\n\n```typescript\napp.static(\"./public\").use(middlewareFunction);\n```\n\n---\n\n## **üìù Notes**\n\n- Automatically detects **MIME types** for proper `Content-Type` headers.\n- Ensures **secure file path resolution** to prevent directory traversal attacks.\n- Works seamlessly across **Node.js, Deno, and Bun** with minimal modifications.\n- Supports both **absolute and relative** folder paths.\n\n---\n\nThis **enhanced documentation** includes:  \n‚úÖ **Detailed parameter descriptions**  \n‚úÖ **Comprehensive options table**  \n‚úÖ **Real-world use cases**  \n‚úÖ **Security & performance best practices**\n\n<https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control>\n\n## **You can Overwrite static path**\n\n```ts\napp.get(\"/static/image.png\", (ctx) => {\n  //-------------\n  //------------- code\n  //-------------\n  //-------------\n});\n```\n"
    },
    {
      "id": 22,
      "path": "middlewares/cors-middleware",
      "name": "CORS Middleware",
      "folder": "Middlewares",
      "content": "---\n# CORS Middleware\n\n## **Overview**\n\nMiddleware for handling Cross-Origin Resource Sharing (CORS) headers. Supports dynamic origin validation, preflight requests, and granular control over allowed methods/headers.\n---\n\n## **Installation & Basic Usage**\n\n```typescript\nimport { cors } from \"tezx\";\n\n// Basic setup (allow all origins)\napp.use(cors());\n\n// Advanced configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type                                                              | Default                             | Description                           |\n| ---------------- | ----------------------------------------------------------------- | ----------------------------------- | ------------------------------------- |\n| `origin`         | `string RegExp  (string RegExp)[]  ((origin: string) => boolean)` | `*` (allow all)                     | Controls allowed origins              |\n| `methods`        | `string[]`                                                        | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | HTTP methods allowed in CORS requests |\n| `allowedHeaders` | `string[]`                                                        | `[\"Content-Type\", \"Authorization\"]` | Headers clients can send              |\n| `exposedHeaders` | `string[]`                                                        | (none)                              | Headers exposed to client             |\n| `credentials`    | `boolean`                                                         | `false`                             | Allow cookies/credentials             |\n| `maxAge`         | `number`                                                          | (none)                              | Preflight cache duration in seconds   |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```typescript\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n#### **Multiple Origins**\n\n```typescript\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex support\n  ],\n});\n```\n\n#### **Dynamic Validation**\n\n```typescript\ncors({\n  origin: (requestOrigin) => {\n    return validateOriginAgainstDB(requestOrigin); // Async supported via ctx\n  },\n});\n```\n\n---\n\n### **2. Preflight Handling**\n\nAutomatically responds to `OPTIONS` requests:\n\n```http\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response**:\n\n```http\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\nWhen enabled:\n\n```typescript\ncors({ credentials: true });\n```\n\nSets header:\n\n```http\nAccess-Control-Allow-Credentials: true\n```\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers automatically:\n\n| Header                             | Value Example                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Per-Route CORS Configuration**\n\n```typescript\n// Apply to specific route\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n### **2. Combining with Authentication**\n\n```typescript\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\n\napp.use(authMiddleware); // Reads Authorization header\n```\n\n### **3. Long Cache Preflight**\n\n```typescript\ncors({\n  maxAge: 86400, // 24-hour cache\n});\n```\n\n---\n\n## **Error Handling**\n\nThe middleware **does not** throw errors for invalid origins. Instead:\n\n- Sets empty `Access-Control-Allow-Origin` for invalid origins\n- Returns 204 for OPTIONS requests regardless of origin validity\n- Relies on browser enforcement of CORS policies\n\n**To implement strict blocking**:\n\n```typescript\napp.use(\n  cors({\n    origin: (origin) => {\n      if (!isValid(origin)) {\n        throw new Error(\"Invalid origin\"); // Will propagate\n      }\n      return origin;\n    },\n  }),\n);\n```\n\n---\n\n## **Best Practices**\n\n1. **Avoid Wide Open CORS**\n\n   ```typescript\n   // ‚ùå Dangerous in production\n   cors({ origin: \"*\" });\n\n   // ‚úÖ Restrictive setup\n   cors({ origin: process.env.ALLOWED_ORIGINS });\n   ```\n\n2. **Limit Exposed Headers**\n\n   ```typescript\n   cors({\n     exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"],\n   });\n   ```\n\n3. **Use Credentials Sparingly**\n\n   ```typescript\n   // Only enable when cookies/auth needed\n   cors({ credentials: true });\n   ```\n\n4. **Combine with Rate Limiting**\n\n   ```typescript\n   app.use(rateLimiter());\n   app.use(cors());\n   ```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\nMatch origins using regular expressions:\n\n```typescript\n// Allow all subdomains of example.com\ncors({ origin: /\\.example\\.com$/ });\n\n// Allow specific patterns\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ });\n```\n\n### **2. Mixed Array Support**\n\nCombine strings and regexes in the origin array:\n\n```typescript\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**  \n   `'https://exact-domain.com'`\n\n2. **Regex Pattern Test**  \n   `/\\.domain\\.com$/`\n\n3. **Array Membership Check**  \n   (Strings or regexes)\n\n4. **Function Validation**  \n   Custom logic\n\n### **Matching Flow**\n\n```js\ngraph TD\n    A[Request Origin] --> B{Is origin string?}\n    B -->|Yes| C[Exact match]\n    B -->|No| D{Is origin regex?}\n    D -->|Yes| E[Regex test]\n    D -->|No| F{Is array?}\n    F -->|Yes| G[Check array elements]\n    F -->|No| H{Is function?}\n    H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```typescript\n// Allow all subdomains and local development\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex Generation**\n\n```typescript\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\n\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function Combination**\n\n```typescript\ncors({\n  origin: (origin) => {\n    const isLocal = /localhost:\\d+/.test(origin);\n    return isLocal || someOtherCheck(origin);\n  },\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```typescript\n// Match exact domain with regex\ncors({ origin: /^https:\\/\\/exact\\.com$/ });\n\n// Allow HTTP and HTTPS\ncors({ origin: /^https?:\\/\\/app\\.com$/ });\n```\n\n### **Port Matching**\n\n```typescript\n// Allow any localhost port\ncors({ origin: /http:\\/\\/localhost:\\d+/ });\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchored Patterns**  \n   Always anchor regexes to prevent partial matches:\n\n   ```typescript\n   // ‚ùå Vulnerable to \"evil-example.com\"\n   /example\\.com/\n\n   // ‚úÖ Secure match\n   /^https:\\/\\/.*\\.example\\.com$/\n   ```\n\n2. **Escape Special Characters**\n\n   ```typescript\n   const domain = \"special.domain.com\";\n   const escaped = domain.replace(/\\./g, \"\\\\.\");\n   new RegExp(`^https://${escaped}$`);\n   ```\n\n3. **Combine with Allow Lists**\n\n   ```typescript\n   const allowed = loadFromDB(); // ['trusted.com', ...]\n   cors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n   ```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex Patterns**\n\n```typescript\nconst testOrigin = \"https://app.staging.com\";\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(testOrigin)); // true\n```\n\n### **Log Matched Origins**\n\n```typescript\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n**Returns:** Middleware function\n\n**Flow:**\n\n1. Validates request origin\n2. Sets CORS response headers\n3. Short-circuits OPTIONS requests\n4. Proceeds to next middleware for non-OPTIONS\n\n---\n"
    },
    {
      "id": 23,
      "path": "helpers/load-environment",
      "name": "Load Environment",
      "folder": "Helpers",
      "content": "---\n\n## **Core Components**\n\n### **1. `loadEnv(basePath?: string)`**\n\n**Purpose:** Loads environment variables from `.env` files  \n**Parameters:**\n\n- `basePath` (optional): Directory containing `.env` files (default: current working directory)\n\n**Supported Files:**\n\n```js\n.env                # Base environment\n.env.local          # Local overrides\n.env.[mode]         # Environment-specific (e.g., .env.production)\n.env.[mode].local   # Mode-specific local overrides\n```\n\n**Return Type:**  \n\n```typescript\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: 'development' | 'production' | 'test';\n  PORT?: string;\n  API_KEY?: string;\n  // ... other variables\n}\n```\n\n**Example:**\n\n```typescript\n// Load from specific directory\nconst env = loadEnv('./config');\n\n// Access variables\nconst port = env.PORT || '3000';\n//or\n\nconst port = process.env.PORT\n```\n\n---\n\n### **2. `CustomContext` Interface**\n\n**Extends base context with application-specific properties:**\n\n```typescript\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n**Usage in Middleware:**\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n---\n\n### **3. Server Initialization**\n\n**Type-Safe Configuration:**\n\n```typescript\nconst server = new Accelero<CustomContext>({\n  env: loadEnv(),\n  // Other options\n});\n```\n\n**Configuration Options:**\n\n| Option | Type           | Default                     | Description                     |\n| ------ | -------------- | --------------------------- | ------------------------------- |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Environment variables container |\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```typescript\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst server = new Accelero({\n  env,\n  logger: logger,\n});\n\n// Access env in middleware\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n### **2. Advanced Context Usage**\n\n```typescript\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst server = new Accelero<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware to extend context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\n```typescript\n// .env.production\nNODE_ENV = production;\nPORT = 443;\nAPI_KEY = prod_abcdef;\n\n// .env.development\nNODE_ENV = development;\nPORT = 3000;\nAPI_KEY = dev_123456;\n```\n\n### **2. Security**\n\n```text\n# .gitignore\n.env.local\n.env.*.local\n```\n\n---\n\n**Example:**\n\n```typescript\nif (env.DEBUG) enableDebugging();\n```\n\n---\n"
    },
    {
      "id": 24,
      "path": "helpers/logger",
      "name": "Logger",
      "folder": "Helpers",
      "content": "# Logger Function\n\nThe `TezX` logger provides a flexible logging system that integrates with request/response cycles and supports custom log levels. It follows the **LoggerFnType** interface for structured logging.\n\n---\n\n## **Quick Start**\n\n### **Basic Setup**\n\n```typescript\nimport { TezX, loadEnv, logger } from \"tezx\";\n\nconst server = new TezX({\n  logger: logger,\n  env: loadEnv(),\n});\n```\n\n---\n\n## **Logger Configuration**\n\n### **LoggerFnType Interface**\n\n```typescript\ntype LoggerFnType = () => {\n  request?: (method: HTTPMethod, pathname: string) => void;\n  response?: (method: HTTPMethod, pathname: string, status?: number) => void;\n  info?: (msg: string, ...args: unknown[]) => void;\n  warn?: (msg: string, ...args: unknown[]) => void;\n  error?: (msg: string, ...args: unknown[]) => void;\n  debug?: (msg: string, ...args: unknown[]) => void;\n  success?: (msg: string, ...args: unknown[]) => void;\n};\n```\n\n```ts\napp.post(\"/products\", async (ctx) => {\n  logger().debug(\"Successful\");\n  return ctx.json({ success: true, message: \"Created Successful\" });\n});\n```\n\n---\n\n## **Core Methods**\n\n### **1. Request/Response Tracking**\n\n| Method     | Parameters                     | Description              |\n| ---------- | ------------------------------ | ------------------------ |\n| `request`  | `method`, `pathname`           | Logs incoming requests   |\n| `response` | `method`, `pathname`, `status` | Logs completed responses |\n\n**Example:**\n\n```typescript\nconst logger = () => ({\n  request: (method, path) => {\n    console.log(`‚ûî ${method} ${path}`);\n  },\n  response: (method, path, status) => {\n    console.log(`‚Üê ${status} ${method} ${path}`);\n  },\n});\n```\n\n### **2. Log Levels**\n\n| Method    | Use Case            | Example Output                       |\n| --------- | ------------------- | ------------------------------------ |\n| `info`    | General information | `[INFO] Server started on port 3000` |\n| `warn`    | Non-critical issues | `[WARN] High memory usage detected`  |\n| `error`   | Critical errors     | `[ERROR] Database connection failed` |\n| `debug`   | Debugging details   | `[DEBUG] Route matched: /api/users`  |\n| `success` | Positive outcomes   | `[SUCCESS] User created: ID-123`     |\n\n---\n\n### **Custom Log Format**\n\n```typescript\nconst logger = () => ({\n  info: (msg, ...args) => {\n    const timestamp = new Date().toISOString();\n    console.log(`[${timestamp}] INFO: ${msg}`, ...args);\n  },\n  error: (msg, ...args) => {\n    const timestamp = new Date().toISOString();\n    console.error(`[${timestamp}] ERROR: ${msg}`, ...args);\n  },\n});\n```\n\n---\n"
    },
    {
      "id": 25,
      "path": "examples/basic",
      "name": "Basic",
      "folder": "Examples",
      "content": ""
    },
    {
      "id": 26,
      "path": "examples/uploader",
      "name": "Uploader",
      "folder": "Examples",
      "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
    },
    {
      "id": 27,
      "path": "m",
      "name": "M",
      "folder": ".",
      "content": "Ei function `addMiddleware` ekta **Trie-based middleware system** er part, jetar kaj **nested middlewares ke root middleware tree te merge kora**. Ei function **TrieRouter er motoi kaj kore, but middlewares niye**.\n\n---\n\n### **üîç Function Breakdown with Comments**\n\n```ts\nfunction addMiddleware(\n  children: Map<string, TriMiddleware>,\n  node: TriMiddleware,\n) {\n  let n = node; // Root node ke current node hisebe set kora\n\n  // Looping through all middleware children\n  for (const [path, middlewareNode] of children) {\n    // Jodi already path ta parent node e thake\n    if (n.children.has(path)) {\n      let findNode = n.children.get(path)!; // Existing node ta retrieve kori\n\n      // **Middleware Merge:** New middlewares ke existing node er sathe add kori\n      findNode.middlewares.push(...middlewareNode.middlewares);\n\n      // **Clearing Old Middlewares:** Jeno duplicate na thake\n      middlewareNode.middlewares.length = 0;\n\n      // **Recursive Merge:** Jodi nested middleware children thake, tahole abar call kori\n      if (middlewareNode.children.size) {\n        addMiddleware(middlewareNode.children, findNode);\n      }\n    } else {\n      // Jodi path root e na thake, tahole direct add kori\n      n.children.set(path, middlewareNode);\n\n      // **Clearing Middlewares & Children:** Jeno extra memory na use hoy\n      middlewareNode.middlewares.length = 0;\n      middlewareNode.children.clear();\n    }\n  }\n}\n```\n\n---\n\n### **üöÄ Merging Middlewares**\n\nEi function **nested middleware gulo ke parent Trie er sathe merge kore**.\n\n1Ô∏è‚É£ **Before merging:**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n2Ô∏è‚É£ **New RouterMiddlewares (To Merge)**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n3Ô∏è‚É£ **After merging:**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  <-- Merged!\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  <-- New Middleware Added\n```\n\n---\n\n### **üîë Key Takeaways**\n\n‚úÖ **Same middleware path hole merge hoy** (duplicate avoid kore)  \n‚úÖ **Nested middlewares recursively merge hoy**  \n‚úÖ **Clearing middleware arrays** memory optimize kore  \n‚úÖ **TrieRouter er motoi middleware tree structure handle kore**\n\n---\n\n### **üåü Final Summary**\n\n- Ei function **Hono.js er middleware merging er moto kaj kore**.\n- Recursive method diye **nested middlewares ke Trie structure e merge kore**.\n- **Optimized memory** rakhar jonne `middlewares.length = 0` and `children.clear()` kora hoy.\n\nAro details lagle bolo! üöÄüî•\n"
    }
  ]
}
