{
  "structure": [
    {
      "originalPath": "2. Benchmarking.md",
      "id": 1,
      "name": "Benchmarking",
      "type": "file",
      "path": "benchmarking",
      "content": "# ğŸš€ Benchmarking Performance: TezX Across Runtimes\n\nTezX is built for speed and efficiency, supporting multiple JavaScript runtimes. This section highlights real-world HTTP server benchmarks comparing TezX performance on **Bun**, **Deno**, and **Node.js** using `wrk`, a popular HTTP benchmarking tool.\n\n---\n\n## âš™ï¸ Test Setup\n\n* **Benchmark Tool:** [wrk](https://github.com/wg/wrk) (v4.1+)\n* **Test Duration:** 10 seconds\n* **Threads:** 12\n* **Concurrent Connections:** 400\n* **Endpoint:** `/` (simple text response)\n* **Ports:** Bun & Deno on `3001`, Node.js on `3000`\n\n---\n\n## ğŸ“Š Benchmark Summary\n\n| Runtime     | Requests/sec     | Avg Latency | Transfer Rate |\n| ----------- | ---------------- | ----------- | ------------- |\n| **Bun**     | **69,367 req/s** | 5.66 ms     | 9.59 MB/s     |\n| **Deno**    | 58,061 req/s     | 6.76 ms     | 9.30 MB/s     |\n| **Node.js** | 13,859 req/s     | 28.63 ms    | 2.17 MB/s     |\n\n---\n\n## ğŸ” Detailed Output\n\n### ğŸŸ¢ Bun\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 5.66 ms | Stdev: 663.46 Âµs | Max: 12.62 ms\nRequests/sec Avg: 5.86k | Max peak: 35.51k\nTotal Requests: 700,594 | Transfer: 96.88 MB\n```\n\n### ğŸŸ¡ Deno\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 6.76 ms | Stdev: 791.19 Âµs | Max: 13.53 ms\nRequests/sec Avg: 4.91k | Max peak: 62.61k\nTotal Requests: 586,419 | Transfer: 93.95 MB\n```\n\n### ğŸ”´ Node.js\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3000\n\nLatency     Avg: 28.63 ms | Stdev: 5.89 ms | Max: 120 ms\nRequests/sec Avg: 1.16k | Max peak: 1.38k\nTotal Requests: 138,852 | Transfer: 21.72 MB\n```\n\n---\n\n## ğŸ’¡ Insights\n\n* **Bun** demonstrates exceptional throughput and low latency, benefiting from its highly optimized JavaScript runtime and native HTTP server.\n* **Deno** performs admirably, striking a balance between speed and robustness with modern runtime features.\n* **Node.js** remains a solid choice but shows higher latency and lower request capacity under heavy concurrency.\n\n---\n\n## ğŸ“ˆ Why Does This Matter?\n\n* **High Throughput:** Enables TezX to handle thousands of requests per second, ideal for real-time apps and APIs.\n* **Low Latency:** Improves user experience by reducing response delays.\n* **Runtime Flexibility:** TezX runs efficiently on multiple platforms â€” choose the runtime that best fits your deployment needs.\n\n---\n\n## ğŸ”— Further Reading\n\n* [Bun Official Website](https://bun.sh)\n* [Deno Official Website](https://deno.land)\n* [Node.js Official Website](https://nodejs.org)\n* [wrk Benchmark Tool](https://github.com/wg/wrk)\n"
    },
    {
      "originalPath": "3. Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Create app.md",
          "id": 2,
          "name": "Create app",
          "type": "file",
          "path": "getting-started/create-app",
          "content": "# âš¡ Create TezX\n\nEasily scaffold a new [TezX](https://github.com/tezxjs/tezx) project using official starter templates. Whether you're building a backend with WebSocket support or a TypeScript-powered server, `create-tezx` gets you started fast.\n\n---\n\n## ğŸš€ Quick Start\n\nStarter templates are available for common runtimes and package managers. Run one of the following commands:\n\n```bash\n# npm\nnpm create tezx@latest\nnpx create-tezx-app@latest\n# yarn\nyarn create tezx\n\n# pnpm\npnpm create tezx@latest\n\n# bun\nbun create tezx@latest\n\n# deno\ndeno run -A npm:create-tezx@latest\n````\n\nThis will launch an interactive setup. You can also skip prompts using CLI flags.\n\n---\n\n## âš™ï¸ CLI Options\n\nYou can skip interactive prompts by passing options directly via the command line.\n\n### `-t`, `--template <template>`\n\nUse a specific template by name.\n\n```bash\nnpm create tezx@latest my-app -- --template minimal\n```\n\n---\n\n### `-i`, `--install`\n\nAutomatically install dependencies after project setup.\n\n```bash\nnpm create tezx@latest my-app -- --install\n```\n\n---\n\n### `-p`, `--pm <npm|pnpm|bun|yarn>`\n\nChoose a package manager.\n\n```bash\nnpm create tezx@latest my-app -- --pm bun\n```\n\n---\n\n### `--ts`, `-ts`\n\nEnable TypeScript in the scaffolded project.\n\n```bash\nnpm create tezx@latest my-app -- --ts\n```\n\n---\n\n### `--env`, `--runtime`, `-env`, `-runtime`\n\nSet the runtime environment: `node`, `bun`, or `deno`.\n\n```bash\nnpm create tezx@latest my-app -- --runtime bun\n```\n\n---\n\n### `--y`, `--yes`, `-y`, `-yes`\n\nSkip all prompts using sensible defaults.\n\n```bash\nnpm create tezx@latest my-app -- --yes\n```\n\n---\n\n## ğŸ“ Supported Templates\n\n> âœ… More templates coming soon!\n\n| Template        | Description                     | Flag Example               |\n| --------------- | ------------------------------- | -------------------------- |\n| `minimal`       | Minimal TypeScript setup        | `--template minimal`       |\n| `ws`            | WebSocket support (Node or Bun) | `--template ws`            |\n| `google-oauth2` | Google OAuth2 integration       | `--template google-oauth2` |\n| `github-oauth2` | GitHub OAuth2 integration       | `--template github-oauth2` |\n\n---\n\n## ğŸ§ª Example Usage\n\n```bash\nnpm create tezx@latest my-app -- --template ws --ts --runtime node --install\n```\n\n```bash\nbun create tezx@latest auth-app -- --template google-oauth2 --pm bun --yes\n```\n\n---\n\n## ğŸ§‘â€ğŸ’» Author\n\nBuilt by [Rakibul Islam](https://github.com/srakib17)\nand [TezX](https://github.com/tezxjs/tezx) contributors.\n\n---\n"
        },
        {
          "originalPath": "1. Installation.md",
          "id": 3,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "# âš¡ TezX â€” High-Performance Backend Framework\n\n**TezX** is a modern, ultra-fast, and lightweight JavaScript framework built for **Node.js, Bun, and Deno**. It offers blazing speed, clean APIs, and built-in tools for routing, middleware, and static file handling â€” perfect for scalable backend applications.\n\n---\n\n## âœ¨ Features\n\n* ğŸš€ **High Performance** â€“ Built for speed and concurrency\n* âš™ï¸ **Simple API** â€“ Clean and minimalistic\n* ğŸ›¡ï¸ **Security First** â€“ Follows best practices\n* ğŸ§© **Middleware System** â€“ Modular and powerful\n* ğŸ—‚ï¸ **Static File Serving** â€“ Just plug and go\n* ğŸŒ **Universal Runtime** â€“ Works on **Node**, **Bun**, and **Deno**\n\n---\n\n## ğŸ“¦ Quick Start\n\n### 1. Setup Project\n\n```bash\nmkdir my-tezx-app && cd my-tezx-app\nnpm init -y              # or bun init\nnpm install tezx         # or bun add tezx\n```\n\n### 2. Project Structure\n\n```\n.\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ index.ts      # App entry point\nâ”œâ”€â”€ public/           # Static files\nâ”œâ”€â”€ .env              # Environment variables\nâ””â”€â”€ tsconfig.json     # TypeScript config\n```\n\n### 3. Create `.env`\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key\n```\n\n---\n\n## ğŸ–¥ï¸ Basic Server (Node.js)\n\n```ts\n// src/index.ts\nimport { TezX } from \"tezx\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { logger } from \"tezx/logger\";\nimport { createServer } from \"http\";\n\nconst env = loadEnv();\nconst app = new TezX({ env });\n\napp.use(logger());\napp.get(\"/\", (ctx) => ctx.text(\"Hello TezX!\"));\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(env.PORT || 3000, () => {\n  console.log(`ğŸš€ Running at http://localhost:${env.PORT || 3000}`);\n});\n```\n\n---\n\n## âš™ Runtime-Specific Setup\n\n### â–¶ï¸ Bun\n\n```ts\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: {\n    open(ws) { (ws.data as any)?.open?.(ws); },\n    message(ws, msg) { (ws.data as any)?.message?.(ws, msg); },\n    close(ws, code, reason) { (ws.data as any)?.close?.(ws, { code, reason }); },\n    ping(ws, data) { (ws.data as any)?.ping?.(ws, data); },\n    pong(ws, data) { (ws.data as any)?.pong?.(ws, data); },\n    drain(ws) { (ws.data as any)?.drain?.(ws); },\n  },\n});\n```\n\n### â–¶ï¸ Deno\n\n```ts\nDeno.serve({ port: 3001 }, (req, connInfo) => app.serve(req, connInfo));\n```\n\n---\n\n## ğŸ› ï¸ Dev Scripts\n\n### Node (`package.json`)\n\n```json\n\"scripts\": {\n  \"dev\": \"tsx watch src/index.ts\",\n  \"build\": \"tsc\",\n  \"start\": \"node dist/index.js\"\n}\n```\n\n### Bun\n\n```json\n\"scripts\": {\n  \"dev\": \"bun run --hot src/index.ts\"\n}\n```\n\n### Deno\n\n```json\n\"scripts\": {\n  \"dev\": \"deno run --watch --allow-all src/index.ts\"\n}\n```\n\n---\n\n## ğŸ”§ Common Middleware & Features\n\n### Static Files\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: { \"X-Custom-Header\": \"static\" }\n});\n```\n\n### CORS\n\n```ts\nimport { cors } from \"tezx/cors\";\napp.use(cors({ origin: [\"http://localhost:3000\"], methods: [\"GET\", \"POST\"] }));\n```\n\n### Logger\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## ğŸ“¦ TypeScript Build\n\n```bash\ntsc\n```\n\n### Sample `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n---\n\n## ğŸ› ï¸ Troubleshooting\n\n| Issue                       | Fix                              |\n| --------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'` | Run `npm install` or `bun add`   |\n| `Port already in use`       | Change `PORT` in `.env`          |\n| `TypeScript errors`         | Check `tsconfig.json`            |\n| `.env not loading`          | Verify file location/permissions |\n\n---\n\n## ğŸ§  Tip\n\nWant to create a high-concurrency server with minimal memory footprint? **TezX** + **Bun** is an ideal combo for real-time apps and serverless workloads.\n\n---\n"
        },
        {
          "originalPath": "2. Configuration.md",
          "id": 4,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "# ğŸš€ TezX Configuration Guide\n\nThe `TezX` framework is highly configurable, enabling you to tailor routing, environment variables, middleware, and path handling. This guide details all configuration options available via the `TezX` constructor â€” including how to plug in your own custom router (`routeRegistry`).\n\n---\n\n## ğŸ“Œ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/bun\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  debugMode: true,\n  env,\n  basePath: \"/api\",\n});\n```\n\n---\n\n## ğŸ§  Understanding `TezXConfig`\n\nThe `TezXConfig` type defines the options you can pass to the framework, including routing options inherited from `RouterConfig`:\n\n```ts\nexport type TezXConfig = {\n  debugMode?: boolean;\n  onPathResolve?: (pathname: string) => string;\n  routeRegistry?: RouteRegistry;  // <--- Add your custom router here\n} & RouterConfig;\n\nexport type RouterConfig = {\n  env?: Record<string, string | number>;\n  basePath?: string;\n};\n```\n\n---\n\n## âš™ï¸ Configuration Options\n\n### 1. `debugMode`\n\n* **Type**: `boolean`\n* **Default**: `false`\n* **Description**: Enables verbose logging for development and debugging.\n\n```ts\nconst app = new TezX({ debugMode: true });\n```\n\n---\n\n### 2. `env`\n\n* **Type**: `Record<string, string | number>`\n* **Description**: Supplies environment variables to your app.\n\n```ts\nconst env = { PORT: \"3001\", API_KEY: \"secret\" };\nconst app = new TezX({ env });\nconsole.log(app.config.env.PORT); // \"3001\"\n```\n\n---\n\n### 3. `basePath`\n\n* **Type**: `string`\n* **Description**: Adds a global prefix to all routes (useful for API versioning or grouping).\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\napp.get(\"/users\", (ctx) => ctx.text(\"v1 Users\"));\n// Available at /v1/users\n```\n\n---\n\n### 4. `onPathResolve`\n\n* **Type**: `(pathname: string) => string`\n* **Description**: Custom hook to rewrite or normalize incoming request paths before routing.\n\n```ts\nconst app = new TezX({\n  onPathResolve: (path) => path.toLowerCase().replace(/\\/+$/, \"\"),\n});\n```\n\n---\n\n### 5. `routeRegistry` (Custom Router)\n\n* **Type**: `RouteRegistry`\n* **Description**: Inject your own custom router implementation to fully control route resolution and middleware layering.\n\n---\n\n## ğŸ§© How to Add a Custom `routeRegistry`\n\nYou can supply any router implementing the `RouteRegistry` interface as the `routeRegistry` property in your `TezX` config. This enables complete customization of routing behavior.\n\n### Example: Using a Custom Router with TezX\n\n```ts\nimport { TezX } from \"tezx\";\nimport { PowerfulCustomRouter } from \"./PowerfulCustomRouter\";\n\nconst customRouter = new PowerfulCustomRouter();\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: customRouter,\n});\n```\n\n### How it works\n\n* TezX will call `routeRegistry.search(method, path)` internally to resolve routes.\n* You can register routes and middleware **directly on your custom router** using its API.\n* Middleware registered with method `\"ALL\"` runs before method-specific handlers.\n* Supports all HTTP methods and route param extraction.\n\n---\n\n## ğŸ›  Real-World Example with Sub-Routing and Custom Router\n\n```ts\nimport { TezX } from \"tezx\";\nimport { PowerfulCustomRouter } from \"./PowerfulCustomRouter\";\n\nconst router = new PowerfulCustomRouter();\n\nrouter.addRoute(\"GET\", \"/hello\", [\n  async (ctx) => ctx.text(\"Hello from custom router!\"),\n]);\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: router,\n  basePath: \"/api\",\n});\n\napp.use(\"/api\", async (ctx, next) => {\n  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n\n// Start your server here with Bun, Deno, or Node.js\n\n```\n\n---\n\n## ğŸ“¦ Summary of Configuration Options\n\n| Option          | Type                               | Description                                |\n| --------------- | ---------------------------------- | ------------------------------------------ |\n| `debugMode`     | `boolean`                          | Enables verbose request and error logging  |\n| `env`           | `Record<string, string \\| number>` | Provides environment variables             |\n| `basePath`      | `string`                           | Global prefix added to all routes          |\n| `onPathResolve` | `(pathname: string) => string`     | Hook to rewrite or normalize request paths |\n| `routeRegistry` | `RouteRegistry`                    | Your custom router instance                |\n\n---\n\n## âœ… Best Practices\n\n* Use `basePath` for API versioning or grouping routes.\n* Inject a powerful custom router for fine-grained routing and middleware control.\n* Utilize `onPathResolve` for path normalization or localization needs.\n* Pass your environment variables with `env` for consistent config across environments.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "4. Environment",
      "name": "Environment",
      "path": "environment",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. node",
          "name": "node",
          "path": "environment/1-node",
          "type": "folder",
          "children": [
            {
              "originalPath": "Configure.md",
              "id": 5,
              "name": "Configure",
              "type": "file",
              "path": "environment/node/configure",
              "content": "\n# ğŸ”§ TezX with Node.js â€“ Full Integration Guide (`mountTezXOnNode`)\n\nBuild modern, middleware-driven APIs in Node.js using **TezX**, a lightweight server framework with first-class support for the Fetch API and native HTTP integration.\n\n---\n\n## âœ… Prerequisites\n\n* [Node.js](https://nodejs.org/) v16 or higher\n* TezX installed via `npm`, `yarn`, or `pnpm`\n\n```bash\n# Choose your preferred package manager\nnpm install tezx\n# or\nyarn add tezx\n# or\npnpm add tezx\n```\n\n---\n\n## ğŸ—‚ï¸ Recommended Project Structure\n\n```bash\nproject/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ app.ts          # TezX app instance\nâ”œâ”€â”€ server.ts           # Native Node.js HTTP server\nâ”œâ”€â”€ .env                # Environment config\n```\n\n---\n\n## ğŸš€ Setting Up the Server (`server.ts`)\n\n```ts\nimport { createServer } from \"http\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { app } from \"./src/app\";\n\n// Load environment variables from `.env` into process.env\nloadEnv();\n\n// Create a native HTTP server\nconst server = createServer();\n\n// Mount TezX to handle requests\nmountTezXOnNode(app, server);\n\n// Start listening on the defined port\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(`ğŸš€ TezX is running at http://localhost:${PORT}`);\n});\n```\n\n---\n\n## ğŸ“„ Example `.env`\n\n```env\nPORT=3000\n```\n\n> Loaded via `loadEnv()` and available as `process.env.PORT`\n\n---\n\n## ğŸ§ª Running the Server\n\n```bash\nnode server.ts\n# or with live-reloading (recommended for dev)\nnpx nodemon server.ts\n```\n\n---\n\n## ğŸ§  What Does `mountTezXOnNode` Do?\n\n`mountTezXOnNode(app, server)` enables TezX to work natively with Node.js by:\n\n* ğŸ” **Transforming** Nodeâ€™s `IncomingMessage` into a Fetch-compatible `Request`\n* ğŸ“¤ **Passing** the request to your TezX app via `app.serve()`\n* ğŸ“¥ **Converting** the Fetch `Response` back into a native HTTP response\n* ğŸš° **Supporting** streaming (files, JSON, Server-Sent Events)\n* ğŸ›¡ï¸ **Handling** edge cases like errors and connection aborts cleanly\n\n---\n\n## ğŸ“š Feature Breakdown\n\n| Feature                        | Description                                                          |\n| ------------------------------ | -------------------------------------------------------------------- |\n| `createServer()`               | Standard Node.js HTTP server                                         |\n| `mountTezXOnNode(app, server)` | Binds your TezX app to the server                                    |\n| Request conversion             | `IncomingMessage` â†’ Fetch `Request`                                  |\n| Response conversion            | Fetch `Response` â†’ `ServerResponse` (with stream support)            |\n| Streaming & SSE support        | Handles large or continuous data (e.g., file download, live updates) |\n| Error handling                 | Graceful 500 responses and logging                                   |\n| `.env` support via `loadEnv()` | Automatically loads environment variables                            |\n| Compatibility                  | Works with HTTP/1.x and HTTP/2 servers in Node.js                    |\n\n---\n\n## âœ… Benefits\n\n* ğŸ”§ Native Node.js support without needing adapters\n* âœ¨ Clean Fetch API interface (like Deno or Bun)\n* ğŸ§± Minimal boilerplate, ideal for microservices or APIs\n* ğŸŒŠ Streaming-ready (e.g., `ctx.stream()`, SSE, large files)\n* ğŸ§© Works with existing Node.js tooling (e.g., Nodemon, PM2, ts-node)\n\n---\n\n## ğŸ” Next Steps\n\n* Add routes using `.get()`, `.post()`, `.use()` on your `app` instance\n* Integrate `middleware`, `env`, and `logging` for full control\n* Explore WebSocket support (if using Bun/Deno) or custom WS handlers for Node.js\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "2. bun",
          "name": "bun",
          "path": "environment/2-bun",
          "type": "folder",
          "children": [
            {
              "originalPath": "Configure.md",
              "id": 6,
              "name": "Configure",
              "type": "file",
              "path": "environment/bun/configure",
              "content": "\n# ğŸ”§ TezX + Bun Integration Guide\n\n## âœ… Prerequisites\n\nBefore you begin, ensure the following tools are installed:\n\n* [Bun](https://bun.sh) â€” A modern all-in-one JavaScript runtime\n* [`tezx`](https://www.npmjs.com/package/tezx) â€” TezX framework for Bun\n\nInstall `tezx` via Bun:\n\n```bash\nbun add tezx\n```\n\n---\n\n## ğŸ“ Project Structure (Example)\n\n```bash\nproject/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ app.ts       # Application logic (TezX app instance)\nâ”œâ”€â”€ server.ts        # Main server entry point\nâ”œâ”€â”€ .env             # Environment variables\n```\n\n---\n\n## ğŸŒ Server Setup (with WebSocket Support)\n\n### `server.ts`\n\n```ts\nimport { loadEnv } from \"tezx/bun\";\nimport { app } from \"./src/app\"; // TezX app instance\n\n// Load environment variables\nloadEnv();\n\nBun.serve({\n  port: 3001,\n  reusePort: true, // Enables clustering support\n  fetch(req, server) {\n    return app.serve(req, server); // TezX handles the request\n  },\n  websocket: {\n    open(ws) {\n      console.log(\"WebSocket connected\");\n      return (ws.data as any)?.open?.(ws);\n    },\n    message(ws, msg) {\n      return (ws.data as any)?.message?.(ws, msg);\n    },\n    close(ws, code, reason) {\n      return (ws.data as any)?.close?.(ws, { code, reason });\n    },\n    ping(ws, data) {\n      return (ws.data as any)?.ping?.(ws, data);\n    },\n    pong(ws, data) {\n      return (ws.data as any)?.pong?.(ws, data);\n    },\n    drain(ws) {\n      return (ws.data as any)?.drain?.(ws);\n    },\n  },\n});\n\nconsole.log(`ğŸš€ Server running at http://localhost:${process.env.PORT}`);\n```\n\n---\n\n## ğŸ“„ `.env` Example\n\n```env\nPORT=3001\n```\n\n---\n\n## ğŸ§ª Running the Server\n\nStart the server using Bun:\n\n```bash\nbun run --watch server.ts\n```\n\nOr simply:\n\n```bash\nbun run server.ts\n```\n\n---\n\n## ğŸ“š Key Concepts\n\n| Feature            | Description                                                                   |\n| ------------------ | ----------------------------------------------------------------------------- |\n| `Bun.serve()`      | Launches the HTTP server (analogous to Node.js' `createServer`)               |\n| `reusePort: true`  | Enables multi-process (cluster) support for improved scalability              |\n| `fetch()` handler  | Main entry point for handling HTTP requests using TezX's `app.serve()`        |\n| `websocket` config | Manages the WebSocket lifecycle events such as `open`, `message`, and `close` |\n| `ws.data` usage    | Custom logic can be attached per WebSocket session through the `data` field   |\n| `loadEnv()`        | Automatically loads environment variables from the `.env` file                |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. deno",
          "name": "deno",
          "path": "environment/3-deno",
          "type": "folder",
          "children": [
            {
              "originalPath": "Configure.md",
              "id": 7,
              "name": "Configure",
              "type": "file",
              "path": "environment/deno/configure",
              "content": "# ğŸš€ TezX with Deno â€” Developer Guide\n\nBuild modern, high-performance HTTP applications using the TezX framework on Deno.\n\n---\n\n## âœ… Prerequisites\n\n* [Deno](https://deno.land) installed (v1.44+ recommended)\n* Basic knowledge of Denoâ€™s permissions and module system\n* TezX app instance (`app`) created in `src/index.ts`\n\n---\n\n## ğŸ› ï¸ Setup: `server.ts`\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { app } from \"./src/index.ts\";\n\n// Load environment variables from `.env` and `.env.local`\nawait loadEnv();\n\n// Start the HTTP server\nDeno.serve({ port: Number(Deno.env.get(\"PORT\") || 5000) }, (req, connInfo) => {\n  return app.serve(req, connInfo);\n});\n```\n\n---\n\n## ğŸ“ Project Structure\n\n```\nmy-tezx-project/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ index.ts        # Your TezX app instance\nâ”œâ”€â”€ .env                # Environment variables\nâ”œâ”€â”€ server.ts           # Entry point\n```\n\n---\n\n## ğŸ“¦ Environment Variables (`.env`)\n\n```env\nPORT=5000\nAPP_NAME=MyDenoTezXApp\n```\n\nTezX will automatically load:\n\n* `.env`\n* `.env.local` (if exists)\n\nThese are injected into both `Deno.env` and `process.env` (polyfilled where applicable).\n\n---\n\n## ğŸ“Œ Accessing Env Variables\n\n```ts\nconst port = Number(Deno.env.get(\"PORT\") || 5000);\nconst appName = Deno.env.get(\"APP_NAME\");\n```\n\n---\n\n## ğŸ“ Deno Permissions\n\nTo use `.env` and serve HTTP, ensure the following permissions:\n\n```bash\ndeno run --allow-net --allow-env --allow-read server.ts\n```\n\nAlternatively, for full access during development:\n\n```bash\ndeno run --allow-all server.ts\n```\n\n---\n\n## ğŸ” Live Development (with Watch)\n\n```bash\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## ğŸ“¦ Optional: Use with NPM via `npm:` specifier\n\nIf you're integrating with an NPM-style toolchain or writing hybrid code:\n\n```ts\nimport { loadEnv } from \"npm:tezx/deno\";\n```\n\n---\n\n## ğŸ”§ Pro Tip: Create a Run Script\n\nAdd to your `deno.json` for easier use:\n\n```json\n{\n  \"tasks\": {\n    \"dev\": \"deno run --watch --allow-all server.ts\",\n    \"start\": \"deno run --allow-all server.ts\"\n  }\n}\n```\n\nThen run with:\n\n```bash\ndeno task dev\n```\n\n---\n\n## ğŸ“š Additional Docs\n\n* TezX Docs: *coming soon*\n* Deno Docs: [https://deno.land/manual](https://deno.land/manual)\n* Deno Permissions: [https://deno.land/manual@latest/basics/permissions](https://deno.land/manual@latest/basics/permissions)\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "5. Route Registry",
      "name": "Route Registry",
      "path": "route-registry",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Radix Router.md",
          "id": 8,
          "name": "Radix Router",
          "type": "file",
          "path": "route-registry/radix-router",
          "content": "# ğŸ“¦ RadixRouter\n\n`RadixRouter` is a high-performance, memory-efficient HTTP routing system inspired by radix trees. Designed for flexibility and speed, it supports advanced routing patterns and middleware composition, making it ideal for scalable backend frameworks.\n\n---\n\n## ğŸ” Overview\n\n* **Static Routes:** Match exact paths like `/users`\n* **Dynamic Parameters:** Capture URL segments (`/users/:id`)\n* **Optional Parameters:** Support routes like `/users/:id?`\n* **Wildcards:** Handle catch-all paths (`/files/*path`)\n* **Middleware Stacking:** Support for global and route-specific middleware\n* **Router Composition:** Merge routers for modular, maintainable routing\n\n---\n\n## ğŸ“„ Class: `RadixRouter`\n\n### Constructor\n\n```ts\nimport { RadixRouter } from \"tezx/registry\";\n\nconst router = new RadixRouter();\n```\n\nInstantiates a new router with an optimized radix tree for path matching.\n\n---\n\n## âš™ï¸ API Methods\n\n### `addRoute`\n\n```ts\naddRoute(method: HTTPMethod, path: string, handlers: (Callback | Middleware)[]): void;\n```\n\nRegisters a route with the specified HTTP method, path pattern, and middleware/handlers.\n\n* **`method`**: HTTP method (e.g., `\"GET\"`, `\"POST\"`, `\"PUT\"`, `\"DELETE\"`)\n* **`path`**: Route path, supporting dynamic (`:param`), optional (`:param?`), and wildcard (`*`, `*name`) segments\n* **`handlers`**: Array of middleware or handler functions to execute on match\n\n**Example:**\n\n```ts\nrouter.addRoute(\"GET\", \"/users/:id\", [getUserHandler]);\nrouter.addRoute(\"GET\", \"/files/*path\", [serveFileHandler]);\n```\n\n---\n\n### `search`\n\n```ts\nsearch(method: HTTPMethod, path: string): RouteMatchResult;\n```\n\nFinds and returns the route matching the given HTTP method and URL path.\n\n**Returns:**\n\n```ts\n{\n  method: HTTPMethod;\n  middlewares: Middleware[];\n  handlers: (Callback | Middleware)[];\n  params: Record<string, string | null>;\n}\n```\n\n**Example:**\n\n```ts\nconst match = router.search(\"GET\", \"/users/42\");\n/*\n{\n  method: \"GET\",\n  params: { id: \"42\" },\n  handlers: [...],\n  middlewares: [...]\n}\n*/\n```\n\n---\n\n### `mergeRouter`\n\n```ts\nmergeRouter(basePath: string, childRouter: RadixRouter): void;\n```\n\nComposes a child router under a specified base path, enabling modular route organization.\n\n**Use Case:**\n\nCreate feature-specific routers and merge under a common prefix.\n\n**Example:**\n\n```ts\nconst apiRouter = new RadixRouter();\napiRouter.addRoute(\"GET\", \"/users\", [usersHandler]);\n\nrouter.mergeRouter(\"/api\", apiRouter);\n// Now `/api/users` is handled by usersHandler\n```\n\n---\n\n## ğŸ§© Internal: `parsePattern`\n\nTransforms route patterns into segments for efficient radix tree insertion and matching.\n\n```ts\ntype Segment = {\n  type: \"static\" | \"dynamic\" | \"wildcard\";\n  value?: string;\n  paramName?: string;\n  isOptional?: boolean;\n};\n```\n\n---\n\n## âš¡ Matching Priority\n\nRoutes are matched in the following order to ensure deterministic behavior:\n\n1. **Static segments** (`/users`)\n2. **Dynamic segments** (`/users/:id`)\n3. **Optional dynamic segments** (`/users/:id?`)\n4. **Wildcard segments** (`/files/*path`)\n\nBacktracking allows optional segments to gracefully fallback when no match is found.\n\n---\n\n## ğŸ“Š Performance Metrics\n\n`RadixRouter` delivers blazing fast route resolution even with hundreds of routes:\n\n```text\nBenchmark:\n431 routes Ã— 100,000 matches = 43.1 million matches\nCompleted in ~11,983 ms (~278 ns per match)\n```\n\nThis performance makes it suitable for high-traffic, latency-sensitive applications.\n\n---\n\n## ğŸ›  Types\n\n### `RouteMatchResult<T>`\n\n```ts\n{\n  method: HTTPMethod;\n  middlewares: Middleware<T>[];\n  handlers: HandlerType<T>;\n  params: Record<string, string | null | undefined>;\n}\n```\n\n### `RouteRegistry`\n\n```ts\ninterface RouteRegistry {\n  name: string;\n  addRoute<T = any>(method: HTTPMethod, path: string, handler: HandlerType<T>): void;\n  search(method: HTTPMethod, path: string): RouteMatchResult<T>;\n  mergeRouter?(path: string, router: this): void;\n}\n```\n\n---\n\n## ğŸš€ Example Usage\n\n```ts\nconst router = new RadixRouter();\n\nrouter.addRoute(\"GET\", \"/hello\", [\n  (ctx) => ctx.text(\"Hello World\"),\n]);\n\nrouter.addRoute(\"GET\", \"/user/:id?\", [\n  (ctx) => ctx.text(`User ID: ${ctx.params.id ?? \"Guest\"}`),\n]);\n\nconst match = router.search(\"GET\", \"/user/123\");\nawait match.handlers[0](context); // Executes matched handler\n```\n"
        },
        {
          "originalPath": "99. Custom Router.md",
          "id": 9,
          "name": "Custom Router",
          "type": "file",
          "path": "route-registry/custom-router",
          "content": "# ğŸ“š Custom Routers & Middleware in TezX\n\nTezX offers you **full control** over routing by allowing custom routers implementing the `RouteRegistry` interface. This flexibility lets you define your routing strategy, middleware layering, and parameter parsing â€” all while seamlessly integrating with TezX's request lifecycle.\n\n---\n\n## ğŸš€ Overview\n\n* Implement route registration per HTTP method (GET, POST, etc.)\n* Register global middleware for **all methods** (`\"ALL\"` method)\n* Support dynamic route parameters (e.g., `/user/:id`, `/post/:id?`)\n* Combine middleware and method-specific handlers at runtime\n* Enable modular router composition with `mergeRouter()`\n* Clear TypeScript typings for maintainability and clarity\n* Normalize and match paths robustly with param extraction\n\n---\n\n## ğŸ”§ Powerful Custom Router Implementation\n\n```ts\nimport {\n  HTTPMethod,\n  RouteMatchResult,\n  HandlerType,\n  Middleware,\n  Callback,\n  RouteRegistry,\n} from \"tezx\";\n\ntype Segment = {\n  type: \"static\" | \"param\" | \"paramOptional\" | \"wildcard\";\n  value: string;\n};\n\n/**\n * Parses a URL path into segments with type info:\n * static segments, params, optional params, wildcards.\n */\nfunction parsePath(path: string): Segment[] {\n  return path\n    .split(\"/\")\n    .filter(Boolean)\n    .map((segment) => {\n      if (segment.startsWith(\":\")) {\n        if (segment.endsWith(\"?\")) {\n          return { type: \"paramOptional\", value: segment.slice(1, -1) };\n        }\n        return { type: \"param\", value: segment.slice(1) };\n      }\n      if (segment.startsWith(\"*\")) {\n        return { type: \"wildcard\", value: segment.slice(1) || \"*\" };\n      }\n      return { type: \"static\", value: segment };\n    });\n}\n\n/**\n * Matches a registered routeâ€™s segments against request path segments,\n * returning whether it matches and extracted parameters.\n */\nfunction matchPath(\n  routeSegments: Segment[],\n  requestSegments: string[],\n): { matched: boolean; params: Record<string, string | null> } {\n  const params: Record<string, string | null> = {};\n  let i = 0,\n    j = 0;\n\n  while (i < routeSegments.length && j < requestSegments.length) {\n    const routeSeg = routeSegments[i];\n    const reqSeg = requestSegments[j];\n\n    if (routeSeg.type === \"static\") {\n      if (routeSeg.value !== reqSeg) {\n        return { matched: false, params: {} };\n      }\n      i++;\n      j++;\n    } else if (routeSeg.type === \"param\") {\n      params[routeSeg.value] = reqSeg;\n      i++;\n      j++;\n    } else if (routeSeg.type === \"paramOptional\") {\n      params[routeSeg.value] = reqSeg;\n      i++;\n      j++;\n    } else if (routeSeg.type === \"wildcard\") {\n      params[routeSeg.value] = requestSegments.slice(j).join(\"/\");\n      i++;\n      j = requestSegments.length;\n    }\n  }\n\n  // Allow trailing optional params without matching segments\n  while (i < routeSegments.length) {\n    if (routeSegments[i].type === \"paramOptional\") {\n      params[routeSegments[i].value] = null;\n      i++;\n    } else {\n      break;\n    }\n  }\n\n  // Match only if all route & request segments accounted for\n  return { matched: i === routeSegments.length && j === requestSegments.length, params };\n}\n\nexport class CustomRouter implements RouteRegistry {\n  name = \"CustomRouter\";\n\n  private routes = new Map<\n    HTTPMethod,\n    { path: string; segments: Segment[]; handlers: HandlerType }[]\n  >();\n\n  constructor() {\n    // Initialize all HTTP methods + ALL for middleware\n    [\n      \"ALL\",\n      \"GET\",\n      \"POST\",\n      \"PUT\",\n      \"DELETE\",\n      \"PATCH\",\n      \"OPTIONS\",\n      \"HEAD\",\n    ].forEach((method) => this.routes.set(method as HTTPMethod, []));\n  }\n\n  /**\n   * Register route or middleware stack for a method + path.\n   * Middlewares use method = \"ALL\".\n   */\n  addRoute(method: HTTPMethod, path: string, handlers: HandlerType): void {\n    const normalizedPath = path.startsWith(\"/\") ? path : \"/\" + path;\n    const segments = parsePath(normalizedPath);\n    this.routes.get(method)!.push({ path: normalizedPath, segments, handlers });\n  }\n\n  /**\n   * Find matching middleware + handlers for a given method + path.\n   */\n  search(method: HTTPMethod, path: string): RouteMatchResult {\n    const normalizedPath = path.startsWith(\"/\") ? path : \"/\" + path;\n    const requestSegments = normalizedPath.split(\"/\").filter(Boolean);\n\n    // Collect all middlewares registered under \"ALL\" matching this path\n    const allMiddlewares = this.routes.get(\"ALL\") ?? [];\n    const middlewares: Middleware[] = [];\n    for (const route of allMiddlewares) {\n      if (matchPath(route.segments, requestSegments).matched) {\n        middlewares.push(...route.handlers);\n      }\n    }\n\n    // Find first matching route for this method\n    const methodRoutes = this.routes.get(method) ?? [];\n    let matchedRoute:\n      | { handlers: HandlerType; params: Record<string, string | null> }\n      | null = null;\n\n    for (const route of methodRoutes) {\n      const { matched, params } = matchPath(route.segments, requestSegments);\n      if (matched) {\n        matchedRoute = { handlers: route.handlers, params };\n        break;\n      }\n    }\n\n    if (!matchedRoute) {\n      // Return empty handlers if no match, but include middleware\n      return {\n        method,\n        middlewares,\n        handlers: [],\n        params: {},\n      };\n    }\n\n    return {\n      method,\n      middlewares,\n      handlers: matchedRoute.handlers,\n      params: matchedRoute.params,\n    };\n  }\n\n  /**\n   * Merge another router under a base path prefix.\n   * Useful for modular route composition.\n   */\n  mergeRouter(basePath: string, router: this): void {\n    if (!basePath.startsWith(\"/\")) basePath = \"/\" + basePath;\n    for (const [method, routes] of router.routes.entries()) {\n      for (const route of routes) {\n        // Combine base path and child route path cleanly\n        const combinedPath =\n          basePath === \"/\"\n            ? route.path\n            : basePath.endsWith(\"/\")\n            ? basePath.slice(0, -1) + route.path\n            : basePath + route.path;\n        this.addRoute(method, combinedPath, route.handlers);\n      }\n    }\n  }\n}\n```\n\n---\n\n## ğŸ›  How to Use with TezX â€” Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { CustomRouter } from \"./CustomRouter\";\n\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),\n  debugMode: true,\n});\n\n// Register global middleware on all methods for /api routes\napp.use(\"/api\", async (ctx, next) => {\n  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n\n// Define GET handler with dynamic param\napp.get(\"/api/users/:id\", async (ctx) => {\n  return ctx.json({ userId: ctx.params.id });\n});\n\n// Define POST handler for user creation\napp.post(\"/api/users\", async (ctx) => {\n  const data = await ctx.body.json();\n  return ctx.json({ created: data });\n});\n\n// Modular router example: admin routes\nconst adminRouter = new Router();\nadminRouter.get(\"/dashboard\", [\n  async (ctx) => ctx.text(\"Admin Dashboard\"),\n]);\napp.use(\"/admin\", adminRouter);\n```\n\n---\n\n## ğŸ’¡ Summary of Features\n\n| Feature                        | Description                                                   |\n| ------------------------------ | ------------------------------------------------------------- |\n| **Dynamic Params**             | Support for `:param`, `:param?` (optional), and `*wildcard`   |\n| **Middleware for ALL Methods** | Global middleware runs before method-specific handlers        |\n| **Modular Router Composition** | Combine multiple routers under base paths via `mergeRouter()` |\n| **Path Normalization**         | Ensures consistent matching with leading slashes              |\n| **Efficient Lookup**           | Matches by comparing segmented paths with param extraction    |\n| **Strict Typing**              | Full TypeScript support for safety and clarity                |\n| **Easy to Extend**             | Add validation, param coercion, and logging as needed         |\n\n---\n\n## âš™ï¸ Execution Flow in TezX\n\n1. **Route Registration:** You add routes or middleware via `addRoute()` or `app.use()`.\n2. **Incoming Request:** TezX calls `search(method, path)` on your router.\n3. **Route Matching:** Your router returns middleware + handlers with extracted params.\n4. **Middleware Execution:** Middleware registered on `\"ALL\"` runs first, controlling flow with `await next()`.\n5. **Handler Execution:** Matched route handlers execute after middleware completes.\n6. **Response Generation:** Handlers generate response; middleware can modify `ctx` at any step.\n\n---\n\n## ğŸ§© Middleware and `use()` Method\n\n* Middleware registered with `app.use(path, handler)` internally uses the `\"ALL\"` HTTP method.\n* This means middleware runs for **every HTTP method** on matching paths.\n* Middleware stacks can be layered, reusable, and scoped to sub-paths.\n* Supports async flow control with `next()`.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "5.API",
      "name": "API",
      "path": "api",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. TezX",
          "name": "TezX",
          "path": "api/1-tezx",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. App.md",
              "id": 10,
              "name": "App",
              "type": "file",
              "path": "api/tezx/app",
              "content": "\n# âœ… `TezX` - Application Initialization\n\n`TezX` is a high-performance, middleware-based server and router framework designed for **Deno**, **Bun**, and **Node.js** environments. It offers first-class support for route handling, request lifecycle hooks, and elegant middleware chaining â€” built for speed and flexibility.\n\n---\n\n## ğŸš€ Quick Start: `server.ts`\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { TezX } from \"tezx/core\";\nimport { CustomRouter } from \"./router.ts\"; // your custom route tree\nimport { logger } from \"tezx/logger\";\n\n// Optional: Load environment variables\nawait loadEnv();\n\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),   // ğŸš¦ Route tree definition\n  debugMode: true,                     // ğŸ Enables detailed debugging logs\n  onPathResolve: (path) => path.replace(/\\/+$/, \"\").toLowerCase(), // Optional\n});\n\n// ğŸ”Œ Register global middleware (optional)\napp.use(logger);\n\n// ğŸŒ Start TezX on Deno\nDeno.serve({ port: 5000 }, app.serve);\n```\n\n---\n\n## ğŸ“¦ Folder Structure Example\n\n```bash\nproject/\nâ”œâ”€â”€ middlewares/\nâ”‚   â””â”€â”€ logger.ts\nâ”œâ”€â”€ router.ts\nâ”œâ”€â”€ server.ts\nâ”œâ”€â”€ .env\nâ””â”€â”€ src/\n    â””â”€â”€ handlers/\n        â””â”€â”€ home.ts\n```\n\n---\n\n## âš™ï¸ `TezXConfig` Options\n\n| Option          | Type                       | Description                                                           |\n| --------------- | -------------------------- | --------------------------------------------------------------------- |\n| `routeRegistry` | `Router`                   | Custom route registry implementing `Router` interface                 |\n| `debugMode`     | `boolean`                  | Enable middleware-level debug logging                                 |\n| `onPathResolve` | `(path: string) => string` | Hook to normalize paths (e.g., trim trailing slashes, lowercase URLs) |\n| `basePath`      | `string`                   | Optional base path for all routes (defaults to `/`)                   |\n| `env`           | `Record<string, any>`      | Custom environment object passed into each context                    |\n\n---\n\n## ğŸ›¡ Global Middleware Support\n\n`TezX` allows chaining global middleware using the `.use()` method (inherited from `Router`). Each middleware gets access to the context and `next()` function.\n\n```ts\nimport { Middleware } from \"tezx/types\";\n\nexport const loggerMiddleware: Middleware = async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n};\n```\n\n### Registering Global Middleware\n\n```ts\napp.use(loggerMiddleware);\n```\n\n---\n\n## â• Route-Level Middleware (All Methods)\n\nIf you define a middleware-only route (without `.get()`, `.post()` etc.), `TezX` treats it as an `ALL` method handler â€” perfect for interceptors, guards, or prefix-based matching:\n\n```ts\napp.addRoute({\n  method: \"ALL\", // Intercepts all methods (GET, POST, etc.)\n  path: \"/admin/:section\",\n  handler: adminAuthMiddleware,\n});\n```\n\n---\n\n## âŒ Custom 404 Handler\n\n```ts\napp.notFound((ctx) => ctx.status(404).text(\"ğŸ” Not Found\"));\n```\n\n---\n\n## ğŸ›  Custom Error Handler\n\n```ts\napp.onError((err, ctx) => {\n  console.error(\"Unhandled error:\", err.message);\n  return ctx.status(500).text(\"ğŸ”¥ Internal Server Error\");\n});\n```\n\n---\n\n## ğŸ“¦ Environment Variables (`.env`)\n\n```bash\nPORT=5000\nAPP_NAME=TezXApp\n```\n\n```ts\n// Access anywhere\nconst port = Deno.env.get(\"PORT\");\n```\n\n---\n\n## ğŸ§ª Running the Server\n\n```bash\ndeno run --allow-net --allow-read --allow-env server.ts\n```\n\nor with live reload:\n\n```bash\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## ğŸ§¬ Runtime Compatibility\n\n| Feature    | Deno       | Bun        | Node.js   |\n| ---------- | ---------- | ---------- | --------- |\n| `.serve()` | âœ… Native   | âœ… Native   | âœ… Adapter |\n| Middleware | âœ… Yes      | âœ… Yes      | âœ… Yes     |\n| WebSocket  | âœ… Built-in | âœ… Built-in | â– Custom  |\n\n---\n\n## ğŸ’¡ Summary\n\n| Feature      | Description                                       |\n| ------------ | ------------------------------------------------- |\n| `TezX`       | Main app handler & runtime-agnostic router        |\n| `use()`      | Register global middleware                        |\n| `addRoute()` | Register routes dynamically, including ALL method |\n| `notFound()` | Custom 404 handler                                |\n| `onError()`  | Global error handler                              |\n| `serve()`    | Entry point for Deno/Bun/Node servers             |\n\n---\n"
            },
            {
              "originalPath": "2. Serve.md",
              "id": 11,
              "name": "Serve",
              "type": "file",
              "path": "api/tezx/serve",
              "content": "# ğŸ“¡ `app.serve()` â€” TezX Runtime-Agnostic Request Handler\n\nThe `app.serve()` method is the **core universal handler** for processing HTTP requests in **TezX**. It adapts itself to different JavaScript runtimes by internally delegating requests to the appropriate logic.\n\n---\n\n## ğŸ§  What It Does\n\n* Accepts a native `Request` object (based on the Fetch API).\n* Optionally accepts runtime-specific arguments like `connInfo` (Deno), `req, res, server` (Node.js), or `server` (Bun).\n* Processes the request using your defined middleware and routes.\n* Returns a `Response` object.\n\nThis method allows you to **integrate TezX into any runtime** with **zero extra configuration**.\n\n---\n\n## âš™ï¸ How It Works Internally\n\n```ts\npublic async serve(req: Request, ...args: any[]): Promise<Response>\n```\n\n* `req`: A standard `Request` object.\n* `args`: Optional values like response objects, connections, or server instances.\n\n  * Parses the request.\n  * Creates a context.\n  * Executes middleware chain.\n  * Calls route handlers.\n  * Returns a finalized `Response`.\n\n---\n\n## âœ… Usage Examples\n\n### ğŸ”· Bun\n\n```ts\n// Simple usage\napp.serve(req, server);\n\n// Full Bun server with WebSocket support\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: {\n    open(ws) {\n      return ws.data?.open?.(ws);\n    },\n    message(ws, msg) {\n      return ws.data?.message?.(ws, msg);\n    },\n    close(ws, code, reason) {\n      return ws.data?.close?.(ws, { code, reason });\n    },\n  },\n});\n```\n\n---\n\n### ğŸŸ¨ Deno\n\n```ts\n// Basic serve function\nimport { serve } from \"https://deno.land/std/http/server.ts\";\n\nserve((req, connInfo) => app.serve(req, connInfo));\n\n// Or using modern API\nDeno.serve({ port: 8080 }, app.serve);\n```\n\n---\n\n### ğŸŸ¦ Node.js\n\n```ts\nimport { createServer } from \"http\";\nimport { mountTezXOnNode } from \"tezx/node\";\n\n// Simple server mounting\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n\n// OR: manual conversion if needed\nconst response = await app.serve(toWebRequest(req), req, res, server);\n```\n\n---\n\n## ğŸ”„ When to Use `app.serve()`\n\n| Scenario                       | Use `app.serve()`? |\n| ------------------------------ | ------------------ |\n| Bunâ€™s `Bun.serve`              | âœ… Yes              |\n| Deno's `serve` or `Deno.serve` | âœ… Yes              |\n| Node's `http.createServer`     | âœ… Yes              |\n| Edge runtimes (like Vercel)    | âœ… Yes              |\n| Cloudflare Workers             | âœ… Yes              |\n\n---\n\n## ğŸ“ Example\n\n```ts\nconst res = await app.serve(\n  new Request(\"http://localhost/hello\", { method: \"GET\" })\n);\nconsole.log(await res.text()); // â†’ \"Hello TezX!\" (if route is defined)\n```\n\n---\n\n## ğŸ›  Tip for TypeScript Users\n\nSince `...args: any[]` can vary between environments, you can narrow down types like:\n\n```ts\n// For Deno\napp.serve(req, connInfo as Deno.ServeHandlerInfo);\n\n// For Node\napp.serve(req, res, server);\n```\n\n---\n\n## ğŸ§ª Debugging Middleware Chain\n\nWant to trace how `app.serve()` is executing?\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Incoming request:\", ctx.method, ctx.url);\n  await next();\n});\n```\n\n---\n\n## ğŸ”š Summary\n\n* âœ… Cross-runtime request handler\n* ğŸ“¦ Accepts Fetch API-compatible `Request`\n* ğŸ” Handles middleware, routes, and returns `Response`\n* ğŸ’¡ Plug-and-play with Node, Deno, and Bun\n\n> `app.serve()` is the glue between the **runtime** and your **application logic**.\n"
            }
          ]
        },
        {
          "originalPath": "2. Context",
          "name": "Context",
          "path": "api/2-context",
          "type": "folder",
          "children": [
            {
              "originalPath": "2. Context.md",
              "id": 12,
              "name": "Context",
              "type": "file",
              "path": "api/context/context",
              "content": "\n# ğŸ“˜ TezX `Context` â€” Developer Guide\n\nThe `Context` object in TezX encapsulates the HTTP request and response, providing convenient methods to access request data, manipulate headers, send various types of responses, and manage files â€” all within the lifecycle of a single HTTP transaction.\n\n---\n\n## ğŸ” Request Handling\n\n### `ctx.req` â€” The Wrapped Request Object\n\nProvides high-level access to incoming HTTP request data:\n\n```ts\nctx.req.query;       // Parsed query parameters as an object\nawait ctx.req.json();      // Parse JSON body\nawait ctx.req.formData();  // Parse form data (including multipart/form-data)\nctx.req.header(name);      // Get header by name (case-insensitive)\nctx.req.method;       // HTTP method (GET, POST, etc.)\nctx.req.url;          // Full request URL string\nctx.req.params;       // Route parameters (e.g., from /user/:id)\n```\n\n---\n\n## ğŸ·ï¸ Header Utilities\n\n### Get All Headers\n\n```ts\nconst headers = ctx.header();\nconsole.log(headers);\n// Output: { 'content-type': 'application/json', ... }\n```\n\n### Get Specific Header (Case-Insensitive)\n\n```ts\nconst contentType = ctx.header(\"content-type\");\nconsole.log(contentType); // e.g. 'application/json'\n```\n\n### Set or Append Response Headers\n\n```ts\nctx.setHeader(\"x-powered-by\", \"TezX\");\nctx.setHeader(\"x-custom\", \"value\", { append: true });\n```\n\n* The `append` option appends the header value instead of overwriting.\n\n---\n\n## ğŸ“¡ Response Helpers\n\n### Set HTTP Status Code\n\n```ts\nctx.status(404); // Chainable\n```\n\n### Send Response with Automatic Content-Type Detection\n\n```ts\nctx.send({ message: \"OK\" });        // Sends JSON by default\nctx.send(\"<h1>Hello</h1>\");         // Sends HTML content\nctx.send(\"Plain text response\");    // Sends plain text\n```\n\n### Send JSON Response\n\n```ts\nctx.json({ success: true });\n```\n\n### Send Plain Text Response\n\n```ts\nctx.text(\"Hello World\");\n```\n\n### Send HTML Response\n\n```ts\nctx.html(\"<h1>Welcome</h1>\");\n```\n\nOr using tagged template literal syntax:\n\n```ts\nctx.html`<h1>Hello, ${username}</h1>`;\n```\n\n### Send XML Response\n\n```ts\nctx.xml(`<user><name>John</name></user>`);\n```\n\n### Redirect Client\n\n```ts\nctx.redirect(\"/login\");       // Defaults to HTTP 302 Found\nctx.redirect(\"/admin\", 301);  // Permanent redirect\n```\n\n---\n\n## ğŸ“ File Streaming & Downloads\n\n### Send File (Streaming)\n\n```ts\nawait ctx.sendFile(\"/public/image.png\");\n```\n\nWith additional headers or custom filename:\n\n```ts\nawait ctx.sendFile(\"/docs/manual.pdf\", {\n  filename: \"UserManual.pdf\",\n  headers: { \"X-Sent-By\": \"TezX\" },\n});\n```\n\n### Force File Download with Custom Filename\n\n```ts\nawait ctx.download(\"/files/invoice.pdf\", \"Invoice-2024.pdf\");\n```\n\n---\n\n## ğŸ“¦ Complete Example\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX();\n\napp.get(\"/\", (ctx) => ctx.text(\"Welcome to TezX\"));\n\napp.post(\"/data\", async (ctx) => {\n  const body = await ctx.req.json();\n  return ctx.json({ received: body });\n});\n\napp.get(\"/user/:id\", (ctx) => {\n  const userId = ctx.req.params.id;\n  return ctx.json({ userId });\n});\n\napp.get(\"/download\", async (ctx) => {\n  return await ctx.download(\"./files/sample.pdf\", \"sample.pdf\");\n});\n\napp.get(\"/html\", (ctx) => {\n  return ctx.html`<h1>Hello ${ctx.env.username || \"Guest\"}</h1>`;\n});\n\nexport default app;\n```\n\n---\n\n## ğŸ§ª Handling Form Data (Multipart)\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData.get(\"image\");\n  const username = formData.get(\"username\");\n  return ctx.json({ uploadedBy: username });\n});\n```\n\n**HTML form example for testing:**\n\n```html\n<form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"username\" placeholder=\"Your Name\" />\n  <input type=\"file\" name=\"image\" />\n  <button type=\"submit\">Upload</button>\n</form>\n```\n\n---\n\n## ğŸ§  Pro Tip: Chainable Methods\n\nMost context methods are chainable for concise response building:\n\n```ts\nctx.status(201)\n   .setHeader(\"x-token\", \"abc123\")\n   .json({ message: \"Resource created\" });\n```\n\n---\n\n# Summary\n\n| Feature          | Description                                 | Usage Example                                  |\n| ---------------- | ------------------------------------------- | ---------------------------------------------- |\n| Request Query    | Access parsed query parameters              | `ctx.req.query`                                |\n| Request Body     | Parse JSON or form data                     | `await ctx.req.json()`                         |\n| Headers          | Get/set response headers                    | `ctx.header()`, `ctx.setHeader()`              |\n| Response Types   | Send JSON, text, HTML, XML, redirects       | `ctx.json()`, `ctx.text()`, `ctx.redirect()`   |\n| File Streaming   | Send or download files with custom headers  | `await ctx.sendFile()`, `await ctx.download()` |\n| Middleware Ready | Context flows through middleware with async | `await next()` in handlers                     |\n"
            },
            {
              "originalPath": "3. Context Propagation.md",
              "id": 13,
              "name": "Context Propagation",
              "type": "file",
              "path": "api/context/context-propagation",
              "content": "# ğŸ§© **Context Propagation**\n\nContext propagation in **TezX** allows **type-safe**, **request-scoped state sharing** across middleware and route handlers. Built on TypeScript, it enables fine-grained control, promotes modular architecture, and enhances developer productivity through strict typing and tooling support.\n\n---\n\n## ğŸ§  **Conceptual Overview**\n\n* **Type-safe context shape**\n* **Scoped to individual requests**\n* **Mutable across middleware**\n* **Extended through type composition**\n\n---\n\n## 1ï¸âƒ£ **Defining a Typed Context**\n\nCreate a strongly-typed interface to define the structure of your request context.\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required unique identifier per request\n}\n```\n\n---\n\n## 2ï¸âƒ£ **Typed Router Instantiation**\n\nPass the context type to `Router` or `TezX` for strict type enforcement.\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX<CustomContext>();\n```\n\n---\n\n## 3ï¸âƒ£ **Injecting Data via Middleware**\n\nUse middleware to enrich the context during the request lifecycle.\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.user = await authenticate(ctx.req);\n  return next();\n});\n\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n## 4ï¸âƒ£ **Typed Context Access in Handlers**\n\nSafely access your context properties in any handler with full IntelliSense support.\n\n```ts\napp.get(\"/me\", (ctx) => {\n  return ctx.json({\n    requestId: ctx.requestId,\n    email: ctx.user?.email ?? \"Anonymous\",\n  });\n});\n```\n\n---\n\n## ğŸ” **Context Composition**\n\nScale your context by composing smaller types:\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface MetricsContext {\n  logger: Logger;\n  startTime: number;\n}\n\ntype AppContext = AuthContext & MetricsContext;\n\nconst app = new TezX<AppContext>();\n```\n\n---\n\n## ğŸ›¡ï¸ **Validation Middleware**\n\nEnsure the presence of critical fields during runtime:\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Missing request ID\");\n  return next();\n});\n```\n\n---\n\n## âŒ **Type Safety Guards**\n\nTypeScript prevents invalid usage and ensures refactor-safe access:\n\n```ts\n// âŒ Property 'newProp' does not exist\nctx.newProp = \"value\";\n\n// âŒ Type mismatch\nctx.requestId = 123; // should be a string\n```\n\n---\n\n## ğŸ§© **Optional Properties Handling**\n\nUse safe access patterns for optional context data:\n\n```ts\napp.get(\"/dashboard\", (ctx) => {\n  if (!ctx.user) return ctx.status(401).json({ error: \"Unauthorized\" });\n\n  return ctx.json({ email: ctx.user.email });\n});\n```\n\n---\n\n## ğŸ“Œ **Best Practices**\n\n### âœ… **Order Matters**\n\nSet required context early and validate immediately after.\n\n```ts\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Missing ID\");\n  return next();\n});\n```\n\n---\n\n### âœ… **Immutability**\n\nPrefer immutable patterns when modifying nested context objects.\n\n```ts\n// Prefer\nctx.user = { ...ctx.user, email: \"updated@example.com\" };\n```\n\n---\n\n### âœ… **Testing with Mock Context**\n\nTest your logic in isolation with mock context objects.\n\n```ts\nconst mockCtx: CustomContext = {\n  requestId: \"req-test-001\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\nconst response = await handler(mockCtx);\n```\n\n---\n\n## ğŸ”„ **Context Lifecycle Overview**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Incoming Request\n  Server->>Middleware A: Inject requestId\n  Middleware A->>Middleware B: Attach user\n  Middleware B->>Handler: Execute route\n  Handler->>Server: Prepare response\n  Server->>Client: Send response\n```\n\n---\n\n## ğŸ¯ **Why Context Propagation?**\n\n| Benefit            | Description                                                            |\n| ------------------ | ---------------------------------------------------------------------- |\n| ğŸ” Type Safety     | Compile-time validation prevents access errors and invalid mutations   |\n| ğŸ§© Modularity      | Enables context slicing and extension across layers                    |\n| âš™ï¸ Maintainability | Clear structure for evolving app concerns like auth, logging, sessions |\n| ğŸš€ Scalability     | Composable and predictable patterns for large applications             |\n\n---\n\n## ğŸ§µ Extendability Tips\n\n* Extend context per domain: `AuthContext`, `TraceContext`, `FeatureFlagContext`, etc.\n* Use utility types for safer extensions: `Partial<>`, `Pick<>`, etc.\n* Compose middlewares using domain isolation and shared contracts.\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Middleware",
          "name": "Middleware",
          "path": "api/3-middleware",
          "type": "folder",
          "children": [
            {
              "originalPath": "0. Merging Middlewares.md",
              "id": 14,
              "name": "Merging Middlewares",
              "type": "file",
              "path": "api/middleware/merging-middlewares",
              "content": "# âœ… Middleware Merging Strategy\n\nThis outlines how two router trees with nested middlewares are **intelligently merged** to preserve execution order and structure.\n\n---\n\n## ğŸ”¹ **Before Merging**\n\n### ğŸ§­ **Root Router Tree (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\nâ””â”€â”€ \"/test\"                             # path\n    â”œâ”€â”€ middlewares: [m1]              # existing middleware\n    â””â”€â”€ children:\n        â””â”€â”€ \"/test/1\"\n            â”œâ”€â”€ middlewares: [m2]\n```\n\n* `/test`: Contains middleware `[m1]`.\n* `/test/1`: A subroute with its own middleware `[m2]`.\n\n---\n\n## ğŸ”¹ **New Router Tree to Merge (`RouterMiddlewares`)**\n\n### ğŸŒ± **Incoming Subrouter**\n\n```plaintext\nRouterMiddlewares\nâ””â”€â”€ \"/test\"\n    â”œâ”€â”€ middlewares: [m3]              # additional middleware to merge\n    â””â”€â”€ children:\n        â””â”€â”€ \"/test/2\"\n            â”œâ”€â”€ middlewares: [m4]\n```\n\n* `/test`: New middleware `[m3]` for same path.\n* `/test/2`: New child route under `/test`.\n\n---\n\n## ğŸ” **After Merging (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\nâ””â”€â”€ \"/test\"\n    â”œâ”€â”€ middlewares: [m1, m3]          # merged middlewares\n    â””â”€â”€ children:\n        â”œâ”€â”€ \"/test/1\"\n        â”‚   â”œâ”€â”€ middlewares: [m2]\n        â””â”€â”€ \"/test/2\"\n            â”œâ”€â”€ middlewares: [m4]      # newly added\n```\n\n* Middleware arrays are **merged**: `[m1] + [m3] â†’ [m1, m3]`.\n* All existing children remain untouched (`/test/1`).\n* New children are **appended** (`/test/2`).\n\n---\n\n## ğŸ§  **Implementation Behavior**\n\n### ğŸ”§ `addRoute` API\n\n```ts\n/**\n * Registers a route or middleware stack for a specific HTTP method.\n *\n * @param method - HTTP method (e.g., \"GET\", \"POST\", \"ALL\" for middleware).\n * @param path - Path to match (e.g., \"/api\", \"/test\").\n * @param handlers - Array of middleware or route handler functions.\n */\naddRoute(method: HttpMethod | \"ALL\", path: string, handlers: Handler[]): void;\n```\n\n* `method = \"ALL\"` implies middleware, applied to all requests for that path.\n* Used internally when adding reusable or nested routers.\n\n---\n\n## ğŸ§± **Automatic Middleware Registration Logic**\n\nWhen merging routes via a registry:\n\n```ts\nif (middlewares?.length) {\n  this.#addRoute(\"ALL\", path, middlewares);\n}\n```\n\n* Ensures **all middleware layers** from incoming routers are preserved.\n* Middleware at the same path is concatenated, not replaced.\n\n---\n"
            },
            {
              "originalPath": "2. Middleware.md",
              "id": 15,
              "name": "Middleware",
              "type": "file",
              "path": "api/middleware/middleware",
              "content": "# ğŸ§© `use()` â€“ Register Middlewares or Routers\n\nThe `use()` method in `TezX.Router` is a powerful, flexible API for registering middlewares and sub-routers â€” either globally or scoped to a specific path.\n\n---\n\n## ğŸ“š **Function Signature**\n\n```ts\nuse(...args: any[]): this;\n```\n\nInternally supports overloads like:\n\n```ts\n// Global middleware\nuse(middleware);\nuse([middleware1, middleware2]);\n\n// Scoped middleware\nuse(\"/path\", middleware);\nuse(\"/path\", [middleware1, middleware2]);\n\n// Middleware + handler or router\nuse(\"/path\", middleware, callback);\nuse(\"/path\", [middleware1], subRouter);\nuse(middleware, callback);\nuse([middleware], subRouter);\n```\n\n---\n\n## ğŸ“¦ **Middleware Type**\n\n```ts\ntype Middleware<T = {}, Path extends string = any> = (\n  ctx: Ctx<T, Path>,\n  next: () => Promise<void>\n) => Response | Promise<Response | void>;\n```\n\n* Receives a request context (`ctx`) and a `next()` callback.\n* Can **modify `ctx`**, **short-circuit**, or **continue** the chain with `await next()`.\n\n---\n\n## ğŸ§ª **Usage Examples**\n\n### 1. **Global Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Request started\");\n  await next();\n  console.log(\"Request ended\");\n});\n```\n\n### 2. **Multiple Global Middlewares**\n\n```ts\napp.use([\n  loggerMiddleware,\n  requestIDMiddleware,\n  timingMiddleware\n]);\n```\n\n---\n\n### 3. **Scoped Middleware by Path**\n\n```ts\napp.use(\"/admin\", async (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    return ctx.status(403).text(\"Forbidden\");\n  }\n  return next();\n});\n```\n\n> Middleware will only run for requests under `/admin`.\n\n---\n\n### 4. **Scoped Middleware with Sub-Router**\n\n```ts\nconst authRouter = new Router();\n\nauthRouter.get(\"/login\", (ctx) => ctx.text(\"Login page\"));\n\napp.use(\"/auth\", authMiddleware, authRouter);\n```\n\n> Middleware runs before any subroutes inside `/auth`.\n\n---\n\n## ğŸ§  **How It Works Internally**\n\nThe `use()` function:\n\n* Normalizes arguments into `path`, `middlewares`, and optional `router`.\n* Registers middlewares using:\n\n```ts\nthis.#addRoute(\"ALL\", path, middlewares);\n```\n\n* If a `Router` is passed, itâ€™s mounted using:\n\n```ts\nthis.addRouter(path, router);\n```\n\n---\n\n## ğŸ” **Middleware Chaining**\n\nAll middleware functions follow a **chainable model** via `next()`:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.startTime = Date.now();\n  await next();\n  const ms = Date.now() - ctx.startTime;\n  console.log(`${ctx.method} ${ctx.path} - ${ms}ms`);\n});\n```\n\n* Each middleware may perform actions **before or after** the next one.\n* If `next()` is not called, the chain stops.\n\n---\n\n## ğŸ§± **Router Composition**\n\nMultiple routers can be composed with isolated or shared middleware:\n\n```ts\nconst v1 = new Router();\nv1.use(\"/users\", authMiddleware, userRouter);\n\nconst v2 = new Router();\nv2.use(\"/products\", productRouter);\n\napp.use(\"/api\", [loggerMiddleware], v1);\napp.use(\"/api\", v2);\n```\n\n---\n\n## ğŸ›¡ï¸ **Best Practices**\n\n| Tip                           | Description                                        |\n| ----------------------------- | -------------------------------------------------- |\n| âœ… Use scoped middleware       | For route-specific logic like authentication       |\n| âœ… Keep global middleware pure | Logging, CORS, rate limiting, etc.                 |\n| âœ… Chain with `next()`         | Enables layered composition                        |\n| âœ… Compose routers             | Modularize APIs or feature groups                  |\n| âœ… Handle errors               | Wrap logic in try/catch or global error middleware |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "4. Router",
          "name": "Router",
          "path": "api/4-router",
          "type": "folder",
          "children": [
            {
              "originalPath": "3. Router.md",
              "id": 16,
              "name": "Router",
              "type": "file",
              "path": "api/router/router",
              "content": "\n# ğŸš€ TezX Router â€” Complete Developer Guide\n\n`Router` is the heart of the **tezx** web framework, providing a modern, flexible, and high-performance way to handle HTTP routing, middleware, static assets, sub-routing, and even Server-Sent Events (SSE).\n\n---\n\n## Import & Initialization\n\n```ts\nimport { Router } from \"tezx\";\n\n// Create a new Router instance\nconst app = new Router({\n  basePath: \"/\",           // Base path for all routes (default: \"/\")\n  env: { NODE_ENV: \"prod\" } // Optional environment variables accessible in middleware\n});\n```\n\n---\n\n## Core Concepts\n\n* **Route registration:** Define endpoints with HTTP methods (`GET`, `POST`, etc.).\n* **Middleware support:** Chain multiple middlewares per route.\n* **Route grouping:** Organize routes under common prefixes.\n* **Sub-routers:** Modularize your API by mounting routers under paths.\n* **Static files:** Serve assets like images, CSS, JS seamlessly.\n* **SSE (Server-Sent Events):** Real-time server push via HTTP.\n\n---\n\n## 1. Defining Routes\n\n### Basic Route Handler\n\n```ts\napp.get(\"/hello\", (ctx) => {\n  ctx.body = \"Hello from TezX!\";\n});\n```\n\n* `ctx` is the request context, including request info, response methods, params, and more.\n* Set response by assigning to `ctx.body`.\n\n### Route with Middleware\n\n```ts\nconst auth = async (ctx, next) => {\n  if (!ctx.user) {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  await next(); // Proceed to next middleware or handler\n};\n\napp.get(\"/profile\", auth, (ctx) => {\n return ctx.json({ user: ctx.user });\n});\n```\n\n* Middleware intercepts the request and can halt or continue the chain.\n* Middleware functions accept `(ctx, next)` and must call `await next()` to continue.\n\n### Multiple Middlewares\n\n```ts\nconst log = (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  return next();\n};\n\nconst adminOnly = (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    ctx.setStatus = 403;\n    return ctx.text(\"Forbidden\");\n  }\n  return next();\n};\n\napp.get(\"/admin/dashboard\", [auth, log, adminOnly], (ctx) => {\n  return {\n    body: \"Admin Dashboard\"\n  }\n});\n```\n\n---\n\n## 2. HTTP Methods Supported\n\nUse methods matching HTTP verbs:\n\n* `.get(path, ...middleware, handler)`\n* `.post(path, ...middleware, handler)`\n* `.put(path, ...middleware, handler)`\n* `.patch(path, ...middleware, handler)`\n* `.delete(path, ...middleware, handler)`\n* `.options(path, ...middleware, handler)`\n* `.all(path, ...middleware, handler)` â€” match all HTTP methods\n\nExample:\n\n```ts\napp.post(\"/submit\", (ctx) => {\n  const data = ctx.request.body;\n  return ctx.json({ received: data });\n});\n```\n\n---\n\n## 3. Static File Serving\n\nServe files from a local folder under a route:\n\n```ts\napp.static(\"/assets\", \"./public/assets\");\n```\n\n* Supports directory-based static serving.\n* Use for images, CSS, JS, or any public assets.\n* You can also serve at root:\n\n```ts\napp.static(\"./public\");\n```\n\n---\n\n## 4. Grouping Routes for Cleaner Code\n\nGroup related routes under a common prefix:\n\n```ts\napp.group(\"/api/v1\", (router) => {\n  router.get(\"/users\", (ctx) => { /*...*/ });\n  router.post(\"/users\", (ctx) => { /*...*/ });\n});\n```\n\n* `group` creates a new sub-router scoped to the prefix.\n* Improves modularity and readability.\n\n---\n\n## 5. Mounting Sub-Routers\n\nBuild modular routers and mount them at a path:\n\n```ts\nconst adminRouter = new Router();\n\nadminRouter.use(auth); // Apply auth middleware to all admin routes\n\nadminRouter.get(\"/dashboard\", (ctx) => {\n  return ctx.text(\"Welcome, admin!\")\n});\n\napp.addRouter(\"/admin\", adminRouter);\n```\n\n* `addRouter` mounts another router at the specified base path.\n* Sub-routers can have their own middleware, routes, and groups.\n\n---\n\n## 6. Middleware Usage & Notes\n\n* Middleware signature: `async (ctx, next) => { ... }`\n* Call `await next()` to pass control.\n* Can short-circuit by not calling `next()`.\n* Can attach data to `ctx` (e.g., `ctx.user = ...`).\n* Supports arrays of middlewares for routes or groups.\n\n---\n\n## 8. Example: Full Mini App\n\n```ts\nimport { Router } from \"tezx\";\n\nconst app = new Router();\n\nconst logger = async (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  await next();\n};\n\nconst auth = async (ctx, next) => {\n  const token = ctx.headers[\"authorization\"];\n  if (token !== \"secret-token\") {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  ctx.user = { name: \"Alice\" };\n  await next();\n};\n\napp.use(logger);\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Welcome to TezX Router!\");\n});\n\napp.group(\"/api\", (api) => {\n  api.get(\"/public\", (ctx) => {\n    return ctx.text(\"Public API data\");\n  });\n\n  api.get(\"/private\", auth, (ctx) => {\n    return ctx.text(`Hello ${ctx.user.name}, this is private data.`);\n  });\n});\n\napp.static(\"/static\", \"./public\");\n\nexport default app;\n```\n\n---\n\n## 9. Tips for Success\n\n* Use `.group()` and `.addRouter()` to keep routes modular and maintainable.\n* Always validate input in middleware before reaching handlers.\n* Use static serving for your frontend assets or uploads.\n* Compose middlewares to reuse authentication, logging, or error handling.\n* Use `.all()` to apply middleware or handlers for all HTTP methods on a path.\n\n---\n"
            },
            {
              "originalPath": "4. Router Merging.md",
              "id": 17,
              "name": "Router Merging",
              "type": "file",
              "path": "api/router/router-merging",
              "content": "\n# ğŸ”€ **Router Merging â€” TezX**\n\n## ğŸ“˜ Overview\n\n**Router merging** enables seamless integration of multiple routers into a parent application, preserving route hierarchy and avoiding accidental collisions by design.\n\n---\n\n## ğŸ§­ Terminology\n\n| Term              | Meaning                                                     |\n| ----------------- | ----------------------------------------------------------- |\n| **Parent Router** | Your primary app instance (`TezX` or `Router`)              |\n| **Sub-Router**    | A child router with its own routes and middleware           |\n| **Merged Router** | The resulting router structure after `.use()` or `.merge()` |\n\n---\n\n## ğŸ“‚ Pre-Merge Example\n\n```bash\nParent Router:\nâ”œâ”€â”€ /test\nâ”‚   â”œâ”€â”€ GET â†’ handler1\nâ”‚   â””â”€â”€ /1\nâ”‚       â”œâ”€â”€ GET â†’ handler2\n```\n\n---\n\n## â• Adding a Sub-Router\n\n```bash\nSub-Router:\nâ”œâ”€â”€ /products\nâ”‚   â””â”€â”€ /2\nâ”‚       â”œâ”€â”€ GET â†’ handler3\n```\n\n---\n\n## âœ… After Merge\n\n```bash\nMerged Router:\nâ”œâ”€â”€ /test\nâ”‚   â”œâ”€â”€ GET â†’ handler1\nâ”‚   â””â”€â”€ /1\nâ”‚       â”œâ”€â”€ GET â†’ handler2\nâ”œâ”€â”€ /products\nâ”‚   â””â”€â”€ /2\nâ”‚       â”œâ”€â”€ GET â†’ handler3\n```\n\n> âœ… All routes remain intact and merge **non-destructively**.\n\n---\n\n## ğŸ§ª Code Example\n\n```ts\nimport { TezX, Router } from \"tezx\";\n\n// Parent router\nconst app = new TezX();\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// Sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge the routers\napp.use(\"/\", productRouter);\n```\n\n---\n\n## ğŸ§‘â€ğŸ’» Best Practices\n\n### 1. **Use Unique Prefixes**\n\nAvoid route conflicts by assigning distinct prefixes:\n\n```ts\nconst authRouter = new Router();\nauthRouter.get(\"/login\", ...);\napp.use(\"/auth\", authRouter); // Routes like /auth/login\n```\n\n---\n\n### 2. **Middleware Hygiene**\n\nEach sub-router can register its own middleware chain:\n\n```ts\nconst api = new Router();\n\napi.use((ctx, next) => {\n  ctx.setHeader(\"x-api\", \"v1\");\n  return next();\n});\n\napi.get(\"/status\", (ctx) => ctx.json({ ok: true }));\n\napp.use(\"/api\", api);\n```\n\n---\n\n### 3. **Inspect Route Tree**\n\nUse dev logs to inspect routes:\n\n```ts\nconsole.log(app.routes); // Tree-style structure if exposed\n```\n\n---\n\n### 4. **Safe Re-Merge Patterns**\n\nAvoid defining the same path in multiple routers unless intended.\n\n```ts\n// Avoid this\nrouter1.get(\"/ping\", ...);\nrouter2.get(\"/ping\", ...);\n\n// Instead, use a prefix\napp.use(\"/api\", router1);\napp.use(\"/public\", router2);\n```\n\n---\n\n## ğŸ” Debug Tip\n\n```ts\napp.get(\"/example\", (ctx) => {\n  console.log(\"Routing to /example\");\n  return ctx.text(\"Logged\");\n});\n```\n"
            }
          ]
        },
        {
          "originalPath": "5. Request",
          "name": "Request",
          "path": "api/5-request",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Request.md",
              "id": 18,
              "name": "Request",
              "type": "file",
              "path": "api/request/request",
              "content": "# ğŸ“¦ TezXRequest â€” Request Wrapper\n\n`TezXRequest` wraps the native `Request` and provides convenient access to:\n\n* Query parameters\n* Route parameters\n* Headers\n* Body parsing (JSON, FormData, file uploads)\n* Remote address info (via middleware)\n\n---\n\n## ğŸ”¹ Properties\n\n### `url: string`\n\nFull request URL.\n\n```ts\nctx.req.url; // e.g. \"https://example.com/api/user?id=5\"\n```\n\n---\n\n### `method: HTTPMethod`\n\nHTTP method (GET, POST, etc).\n\n```ts\nctx.req.method; // e.g. \"POST\"\n```\n\n---\n\n### `pathname: string`\n\nURL path without query string.\n\n```ts\nctx.req.pathname; // e.g. \"/api/user\"\n```\n\n---\n\n### `params: Record<string, string>`\n\nRoute parameters extracted dynamically.\n\n```ts\n// For route `/user/:id`\nctx.req.params.id; // e.g. \"123\"\n```\n\n---\n\n### `query: Record<string, string>`\n\nParsed query string parameters.\n\n```ts\n// URL: /search?q=js&page=2\nctx.req.query.q;    // \"js\"\nctx.req.query.page; // \"2\"\n```\n\n---\n\n## ğŸ”¸ Methods\n\n### `header(): Record<string, string>`\n\nGet all request headers.\n\n```ts\nconst headers = ctx.req.header();\nconsole.log(headers[\"content-type\"]); // \"application/json\"\n```\n\n---\n\n### `header(name: string): string | undefined`\n\nGet a specific header (case-insensitive).\n\n```ts\nconst contentType = ctx.req.header(\"content-type\");\nconsole.log(contentType); // \"application/json\"\n```\n\n---\n\n### `text(): Promise<string>`\n\nRead raw request body as text.\n\n```ts\nconst body = await ctx.req.text();\nconsole.log(body); // raw string body\n```\n\n---\n\n### `json<T = any>(): Promise<T>`\n\nParse request body as JSON.\n\nReturns `{}` if content-type isnâ€™t JSON or parse fails.\n\n```ts\nconst data = await ctx.req.json();\nconsole.log(data.username); // \"john\"\n```\n\n---\n\n### `formData(): Promise<FormData>`\n\nParse request body as FormData (supports `application/x-www-form-urlencoded` and `multipart/form-data`).\n\n```ts\nconst form = await ctx.req.formData();\nconsole.log(form.get(\"name\"));    // \"John\"\nconsole.log(form.getAll(\"skills\")); // [\"js\", \"ts\"]\n```\n\n---\n\n### âœ… `useFormData<T extends Record<string, string | File | (string | File)[]>>(ctx: Context, options?:FormDataOptions): Promise<T>`\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nimport { useFormData } from \"tezx/helper\";\nconst data = await useFormData<{ name: string; file: File }>(ctx);\ndata.name; // \"Rakib\"\ndata.file; // File object\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "6. Response",
          "name": "Response",
          "path": "api/6-response",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Response.md",
              "id": 19,
              "name": "Response",
              "type": "file",
              "path": "api/response/response",
              "content": "# ğŸ” **Response Handling in TezX**\n\nThe TezX framework provides a rich and extensible response system through the `ctx` object. This system supports typed utilities for sending structured responses, including JSON, HTML, plain text, file downloads, redirects, and more.\n\n---\n\n## ğŸ§© **Core Type Definitions**\n\n```ts\n/**\n * Callback to continue the middleware chain.\n */\nexport type NextCallback = () => Promise<void>;\n\n/**\n * A valid return type from any route handler or middleware.\n */\nexport type HttpBaseResponse = Response | Promise<Response>;\n\n/**\n * Context object passed to routes/middleware.\n * @template T - Extended application state.\n * @template Path - Typed path string.\n */\nexport type Ctx<T extends Record<string, any> = {}, Path extends string = any> =\n  Context<T, Path> & T & Record<string, any>;\n\n/**\n * Route callback signature.\n */\nexport type Callback<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>) => HttpBaseResponse;\n\n/**\n * TezX middleware function signature.\n */\nexport type Middleware<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>, next: NextCallback) =>\n    HttpBaseResponse | Promise<HttpBaseResponse | void> | NextCallback;\n\n/**\n * Error-handling callback.\n */\nexport type ErrorHandler<T = {}> =\n  (err: Error, ctx: Ctx<T>) => HttpBaseResponse;\n```\n\n---\n\n## âœ… **Custom Response (Native Response Object)**\n\nFor full control, return a native `Response` directly:\n\n```ts\napp.get(\"/data\", (ctx) => {\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: { \"Content-Type\": \"text/plain\" },\n  });\n});\n```\n\n---\n\n## ğŸš€ **Response Utilities on `ctx`**\n\n### `ctx.json(body, status?, headers?)`\n\nSends a JSON response.\n\n```ts\napp.get(\"/json\", (ctx) => {\n  return ctx.json({ success: true }, 200);\n});\n```\n\n* **Content-Type**: `application/json`\n* **Returns**: `Response`\n\n---\n\n### `ctx.html(html, status?, headers?)`\n\nReturns an HTML response.\n\n```ts\napp.get(\"/html\", (ctx) => {\n  return ctx.html(\"<h1>Welcome</h1>\");\n});\n```\n\n* **Content-Type**: `text/html`\n\n---\n\n### `ctx.text(text, status?, headers?)`\n\nReturns plain text.\n\n```ts\napp.get(\"/plain\", (ctx) => {\n  return ctx.text(\"Just a plain message.\");\n});\n```\n\n* **Content-Type**: `text/plain`\n\n---\n\n### `ctx.xml(xml, status?, headers?)`\n\nSends XML content.\n\n```ts\napp.get(\"/xml\", (ctx) => {\n  return ctx.xml(\"<note><msg>Hi</msg></note>\");\n});\n```\n\n* **Content-Type**: `application/xml`\n\n---\n\n### `ctx.send(body, status?, headers?)`\n\nSmart responder. Infers content type:\n\n```ts\napp.get(\"/send\", (ctx) => {\n  return ctx.send({ user: \"admin\" });\n});\n```\n\n* **Content-Type** inferred from `body` type:\n\n  * `object` â†’ `application/json`\n  * `string` â†’ `text/plain`\n  * `Buffer`/`Uint8Array` â†’ `application/octet-stream`\n\n---\n\n### `ctx.redirect(url, status?, headers?)`\n\nRedirects to a target URL.\n\n```ts\napp.get(\"/go\", (ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n```\n\n* **Default Status**: `302`\n* **Header**: `Location`\n\n---\n\n### `ctx.download(filePath, fileName)`\n\nTriggers a file download with a custom file name.\n\n```ts\napp.get(\"/download\", (ctx) => {\n  return ctx.download(\"/files/report.pdf\", \"Monthly-Report.pdf\");\n});\n```\n\n* **Header**: `Content-Disposition: attachment`\n\n---\n\n### `ctx.sendFile(filePath, fileName?)`\n\nServes a static file directly.\n\n```ts\napp.get(\"/image\", (ctx) => {\n  return ctx.sendFile(\"/assets/banner.jpg\");\n});\n```\n\n* Automatically sets `Content-Type` and streams file.\n* Optional custom file name.\n\n---\n\n## ğŸ› ï¸ Best Practices\n\n| Use Case                | Recommended Method |\n| ----------------------- | ------------------ |\n| JSON API response       | `ctx.json()`       |\n| HTML rendering          | `ctx.html()`       |\n| Serving static assets   | `ctx.sendFile()`   |\n| Secure file download    | `ctx.download()`   |\n| External redirects      | `ctx.redirect()`   |\n| Manual response control | Native `Response`  |\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "6. Middleware",
      "name": "Middleware",
      "path": "middleware",
      "type": "folder",
      "children": [
        {
          "originalPath": " Logger.md",
          "id": 20,
          "name": "Logger",
          "type": "file",
          "path": "middleware/-logger",
          "content": "# ğŸ“˜ Logger Middleware â€” `@tezx/logger`\n\n## ğŸ§© Overview\n\nThe `logger` middleware provides structured, real-time logging of HTTP requests and responses for applications built with the TezX framework. It captures request lifecycle data, including method, path, status code, and response time, and prints them in a color-coded format to enhance debugging and monitoring.\n\n---\n\n## âœ… Key Features\n\n* ğŸ“¥ Logs every incoming HTTP request with method and path.\n* â± Measures and logs the execution time for each request.\n* ğŸ¯ Displays status codes and response completion details.\n* âš ï¸ Gracefully handles and logs runtime errors in middleware or handlers.\n* ğŸ¨ Color-coded output for enhanced readability (method, status, errors).\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nbun add tezx\n```\n\n*Or if already using `tezx`, it's built-in.*\n\n---\n\n## ğŸš€ Usage\n\n### 1. Import the Middleware\n\n```ts\nimport { logger } from \"tezx/logger\";\n```\n\n### 2. Apply to Your App\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/logger\";\n\nconst app = new TezX();\napp.use(logger());\n```\n\nOr inside a `createApp` bootstrap function:\n\n```ts\nexport function createApp() {\n  const app = new TezX();\n  app.use(logger());\n  return app;\n}\n```\n\n---\n\n## âš™ï¸ Middleware Behavior\n\n### Lifecycle\n\n1. Logs: `--> METHOD PATH` when a request starts.\n2. Tracks start time with `performance.now()`.\n3. Waits for `await next()` to execute downstream logic.\n4. After response: calculates duration and logs:\n\n   ```\n   <-- METHOD PATH STATUS_CODE TIMEms\n   ```\n\n5. On error: logs the error stack in red and rethrows it.\n\n---\n\n## ğŸ§ª Example Output\n\n```bash\n--> GET /api/list\n<-- GET /api/list 200 22.63ms\n\n--> POST /auth/login\n<-- POST /auth/login 401 13.71ms\n\n--> GET /unknown\n<-- GET /unknown 404 5.02ms\n\n[x] Error: Invalid JSON\n```\n\n---\n\n## ğŸ§± Middleware Return Signature\n\n```ts\nfunction logger(): Middleware;\n```\n\nReturns a `Middleware` function compatible with `.use()` or `addRoute()`.\n\n---\n\n## ğŸ“¦ Integration Example with Full TezX Setup\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/logger\";\nimport { CustomRouter } from \"./router\";\n\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),\n  debugMode: true,\n});\n\napp.use(logger());\n```\n\nYou can also attach it to all methods using `addRoute`:\n\n```ts\napp.addRoute({\n  method: \"ALL\",\n  path: \"*\",\n  handler: logger(),\n});\n```\n\n---\n\n## ğŸ›¡ Error Handling\n\nIf any unhandled exception is thrown inside a middleware or route handler, `logger()`:\n\n* Logs the stack trace in red (highlighted).\n* Preserves stack for higher-level error middleware.\n* Does not interfere with downstream error catchers.\n\n---\n\n## ğŸ“„ Related\n\n* `@tezx/core` â€” core HTTP server utilities.\n* `@tezx/router` â€” custom route registry support.\n* `@tezx/middleware` â€” more built-in middleware (e.g., CORS, compression, JSON parser).\n\n---\n"
        },
        {
          "originalPath": "Basic Auth.md",
          "id": 21,
          "name": "Basic Auth",
          "type": "file",
          "path": "middleware/basic-auth",
          "content": "\n# `basicAuth` Middleware\n\n## Overview\n\n`basicAuth` is a flexible authentication middleware supporting multiple methods:\n\n* **Basic Authentication**\n* **Bearer Token**\n* **API Key**\n\nIt also supports:\n\n* Rate limiting (optional)\n* Role-Based Access Control (RBAC) checks (optional)\n* Custom unauthorized handlers\n* Dynamic realm name generation\n\n---\n\n## Usage\n\n### Basic Setup\n\n```ts\nimport {basicAuth} from \"tezx/basic-auth\";\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      // Implement your validation logic per method and credentials here\n      // Return true if valid, false otherwise\n    },\n  })\n);\n```\n\n### Optional Configurations\n\n```ts\nbasicAuth({\n  validateCredentials,\n  \n  // Customize the HTTP Basic auth realm shown on prompt (default: \"Restricted Area\")\n  getRealm: (ctx) => \"My Protected API\",\n\n  // Customize response for unauthorized access\n  onUnauthorized: (ctx, error) => {\n    ctx.setStatus = 401;\n    ctx.setHeader(\"WWW-Authenticate\", `Basic realm=\"${getRealm(ctx)}\"`);\n    ctx.body = { error: error?.message || \"Unauthorized\" };\n  },\n\n  // Rate limiting configuration (optional)\n  rateLimit: {\n    maxRequests: 100,\n    windowMs: 60000,\n    // Optional: Provide custom storage; default storage created if omitted\n    // storage: customStorage,\n  },\n\n  // Supported methods to accept (default: all three)\n  supportedMethods: [\"basic\", \"api-key\", \"bearer-token\"],\n\n  // Optional RBAC check for access control\n  checkAccess: async (ctx, credentials) => {\n    // Return true if user is authorized, false otherwise\n  },\n});\n```\n\n---\n\n## Important Notes\n\n### 1. Node.js Buffer Requirement\n\n* For Node.js, the middleware uses:\n\n  ```ts\n  import { Buffer } from \"node:buffer\";\n  ```\n\n* This is necessary to decode Base64 Basic Auth credentials.\n\n### 2. Rate Limiting Requires `getConnInfo`\n\n* To enable rate limiting, you **must** add the `getConnInfo` middleware **before** `basicAuth`.\n\n* This middleware populates `ctx.req.remoteAddress` which `basicAuth` uses to track IPs for rate limiting.\n\nExample:\n\n```ts\nimport { getConnInfo } from \"tezx/bun\";\n// or\nimport { getConnInfo } from \"tezx/deno\";\n// or\nimport { getConnInfo } from \"tezx/node\";\n\napp.use(getConnInfo());\napp.use(\n  basicAuth({\n    rateLimit: {\n      maxRequests: 50,\n      windowMs: 60000,\n    },\n    validateCredentials,\n  }),\n);\n```\n\n---\n\n## TypeScript Types\n\n```ts\nexport type AuthMethod = \"basic\" | \"api-key\" | \"bearer-token\";\n\nexport type AuthCredential = {\n  username?: any;\n  password?: any;\n  token?: any;\n  apiKey?: any;\n};\n\nexport type DynamicBasicAuthOptions = {\n  validateCredentials: (\n    method: AuthMethod,\n    credentials: AuthCredential,\n    ctx: Context,\n  ) => boolean | Promise<boolean>;\n\n  getRealm?: (ctx: Context) => string;\n\n  onUnauthorized?: (ctx: Context, error?: Error) => HttpBaseResponse;\n\n  rateLimit?: {\n    storage?: {\n      get: (key: string) => { count: number; resetTime: number } | undefined;\n      set: (key: string, value: { count: number; resetTime: number }) => void;\n      clearExpired: () => void;\n    };\n    maxRequests: number;\n    windowMs: number;\n  };\n\n  supportedMethods?: AuthMethod[];\n\n  checkAccess?: (\n    ctx: Context,\n    credentials: AuthCredential,\n  ) => boolean | Promise<boolean>;\n};\n```\n\n---\n\n## Summary\n\n| Feature                     | Notes                                                   |\n| --------------------------- | ------------------------------------------------------- |\n| Basic Auth                  | Decodes Base64 credentials using `Buffer`               |\n| Bearer Token & API Key      | Reads from `Authorization` header or `x-api-key` header |\n| Rate Limiting               | Requires `injectRemoteAddress` middleware               |\n| Custom Unauthorized Handler | Use `onUnauthorized` option                             |\n| RBAC                        | Use `checkAccess` option for access control             |\n"
        },
        {
          "originalPath": "CORS.md",
          "id": 22,
          "name": "CORS",
          "type": "file",
          "path": "middleware/cors",
          "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```ts\nimport { cors } from \"tezx/cors\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```ts\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```ts\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```ts\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```bash\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```bash\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```ts\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```ts\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```ts\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```ts\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```ts\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n```ts\n// âŒ Avoid in production\ncors({ origin: \"*\" });\n// âœ… Secure setup\ncors({ origin: process.env.ALLOWED_ORIGINS });\n```\n\n2. **Limit Exposed Headers**\n\n```ts\ncors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n```\n\n3. **Use Credentials Judiciously**\n\n```ts\ncors({ credentials: true }); // Enable only when required\n```\n\n4. **Pair with Rate Limiting**\n\n```ts\napp.use(rateLimiter());\napp.use(cors());\n```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```ts\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```ts\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```bash\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```ts\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```ts\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```ts\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```ts\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```ts\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n```ts\n   // âŒ Vulnerable\n   /example\\.com/\n   // âœ… Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n```\n\n2. **Escape Characters**\n\n```ts\nconst domain = \"special.domain.com\";\nconst escaped = domain.replace(/\\./g, \"\\\\.\");\nnew RegExp(`^https://${escaped}$`);\n```\n\n3. **Use Allow Lists**\n\n```ts\nconst allowed = loadFromDB();\ncors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```ts\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.req.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
        },
        {
          "originalPath": "Cache Control.md",
          "id": 23,
          "name": "Cache Control",
          "type": "file",
          "path": "middleware/cache-control",
          "content": "# ğŸ§Š `cacheControl` Middleware\n\n## ğŸ“˜ Overview\n\nThe `cacheControl` middleware manages HTTP caching headers intelligently, improving performance and reducing unnecessary server load. It supports fine-grained control over client and intermediary caching behavior.\n\n---\n\n## âœ¨ Key Features\n\n* ğŸ”§ Dynamic `Cache-Control` headers (`max-age`, `public`/`private`)\n* ğŸ“… Sets accurate `Expires` headers\n* â™»ï¸ Supports the `Vary` header for smart client-side caching\n* ğŸ” Generates ETags (strong or weak) and handles `If-None-Match`\n* ğŸ“‰ Automatically returns `304 Not Modified` if ETag matches\n* ğŸ§  Rule-based configuration per request path/context\n* ğŸ“¢ Customizable event logging for cache hits/misses/errors\n\n---\n\n## ğŸ“¦ Installation\n\n```ts\nimport { cacheControl } from \"tezx/cache-control\";\n```\n\n> âš ï¸ Requires **Node.js**, as it uses `node:crypto` for hashing.\n\n---\n\n## âš™ï¸ Configuration\n\n### Middleware Initialization\n\n```ts\napp.use(cacheControl({\n  defaultSettings: {\n    maxAge: 120,\n    scope: \"public\",\n    enableETag: true,\n    vary: [\"Accept-Encoding\"]\n  },\n  useWeakETag: true,\n  rules: [...],\n  logEvent: (event, ctx, error) => {\n    if (event === \"error\") {\n      console.error(`[CACHE ERROR] ${error?.message}`);\n    } else {\n      console.log(`[CACHE ${event.toUpperCase()}] ${ctx.method} ${ctx.pathname}`);\n    }\n  },\n}));\n```\n\n---\n\n## ğŸ”§ Options\n\n| Option            | Type                                      | Description                                                            |\n| ----------------- | ----------------------------------------- | ---------------------------------------------------------------------- |\n| `defaultSettings` | `CacheSettings` (required)                | Fallback cache behavior if no rule matches.                            |\n| `rules`           | `CacheRule[]` (optional)                  | Conditional caching rules per request.                                 |\n| `useWeakETag`     | `boolean` (optional)                      | Generate weak ETags (`W/`) instead of strong ones.                     |\n| `logEvent`        | `(event, ctx, error?) => void` (optional) | Logs events: `\"cached\"`, `\"no-cache\"`, or `\"error\"` during processing. |\n\n---\n\n## ğŸ“˜ `CacheRule` Type\n\n```ts\ntype CacheRule = {\n  condition: (ctx: Context) => boolean;\n  maxAge: number;\n  scope: \"public\" | \"private\";\n  enableETag: boolean;\n  vary?: string[];\n};\n```\n\n> First matching rule is applied.\n\n---\n\n## ğŸ§ª Usage Examples\n\n### Basic Setup with Default Caching\n\n```ts\ncacheControl({\n  defaultSettings: {\n    maxAge: 60, // 1 minute\n    scope: \"public\",\n    enableETag: true,\n  }\n});\n```\n\n### Advanced with Rules\n\n```ts\ncacheControl({\n  defaultSettings: {\n    maxAge: 120,\n    scope: \"public\",\n    enableETag: true,\n    vary: [\"Accept-Encoding\"]\n  },\n  rules: [\n    {\n      condition: ctx => ctx.pathname.startsWith(\"/api/private\"),\n      maxAge: 0,\n      scope: \"private\",\n      enableETag: false\n    },\n    {\n      condition: ctx => ctx.pathname.startsWith(\"/static\"),\n      maxAge: 86400,\n      scope: \"public\",\n      enableETag: true,\n      vary: [\"Accept-Encoding\"]\n    }\n  ]\n});\n```\n\n---\n\n## âš™ï¸ How It Works\n\n1. **Request Type Check**\n\n   * Only processes `GET` and `HEAD` methods.\n   * Others bypass cache logic.\n\n2. **Rule Evaluation**\n\n   * Scans `rules` and applies the first match.\n   * If none, uses `defaultSettings`.\n\n3. **Header Generation**\n\n   * `Cache-Control`: Based on `maxAge` and `scope`.\n   * `Expires`: Based on current time + `maxAge`.\n   * `Vary`: If provided.\n\n4. **ETag Handling**\n\n   * Generates hash of the response body.\n   * Compares against `If-None-Match`.\n   * Returns `304 Not Modified` if matched.\n\n5. **Logging**\n\n   * Calls `logEvent` if provided.\n\n---\n\n## âš ï¸ Limitations & Notes\n\n* **Node.js only**: Uses `crypto` for hashing.\n* **GET/HEAD only**: Avoids side effects on other methods.\n* **Performance tip**: Avoid ETag on large dynamic responses to reduce hash load.\n* **ETag is generated post-body**: Middleware must run after body is set.\n\n---\n\n## ğŸš¨ Error Handling\n\nIf an error occurs (e.g., during hashing):\n\n* Logs using `logEvent` with type `\"error\"`.\n* Responds with `500 Internal Server Error` and JSON:\n\n```json\n{ \"error\": \"Failed to set cache headers.\" }\n```\n\n---\n\n## ğŸ“‹ Summary Table\n\n| Feature             | Support                        |\n| ------------------- | ------------------------------ |\n| Cache-Control       | âœ… Dynamic max-age + scope      |\n| Expires             | âœ… Set with `Date.now + maxAge` |\n| ETag                | âœ… Strong & weak supported      |\n| Conditional Request | âœ… Returns 304 when matched     |\n| Vary Header         | âœ… Optional per rule            |\n| Rules Support       | âœ… Context-aware strategy       |\n| Logging             | âœ… Via `logEvent()`             |\n| Platform            | â— Node.js required             |\n\n---\n"
        },
        {
          "originalPath": "Detect Locale.md",
          "id": 24,
          "name": "Detect Locale",
          "type": "file",
          "path": "middleware/detect-locale",
          "content": "\n# `detectLocale` Middleware\n\n## Overview\n\nThe `detectLocale` middleware detects and sets a userâ€™s preferred locale in web applications. It supports detection via query parameters, cookies, `Accept-Language` headers, and custom logic. The detected locale is attached to the request context, enabling localized responses downstream.\n\nBuilt with TypeScript, it works seamlessly across Node.js, Bun, and Deno runtimes.\n\n---\n\n## Configuration Options\n\n| Option                 | Type                                    | Description                                                       | Default    | Required |\n| ---------------------- | --------------------------------------- | ----------------------------------------------------------------- | ---------- | -------- |\n| `supportedLocales`     | `string[]`                              | Allowed locale codes (e.g., `[\"en\", \"fr\", \"bn\"]`).                | â€”          | Yes      |\n| `defaultLocale`        | `string`                                | Fallback locale if detection fails.                               | `\"en\"`     | No       |\n| `queryKeyLocale`       | `string`                                | Query parameter key for locale (e.g., `lang` in `/?lang=fr`).     | `\"lang\"`   | No       |\n| `cookieKeyLocale`      | `string`                                | Cookie name storing locale preference.                            | `\"locale\"` | No       |\n| `localeContextKey`     | `string`                                | Context key where detected locale is stored (e.g., `ctx.locale`). | `\"locale\"` | No       |\n| `customLocaleDetector` | `(ctx: Context) => string \\| undefined` | Custom function for programmatic locale detection.                | â€”          | No       |\n\n---\n\n## Middleware Detection Workflow\n\n1. **Query Parameter:** Checks for locale in the query string and validates against `supportedLocales`.\n2. **Cookie:** Looks for locale cookie, validating the value.\n3. **Accept-Language Header:** Parses and selects the first matching locale from the header.\n4. **Custom Detector:** If provided, invokes the custom function for locale detection.\n5. **Fallback:** Defaults to `defaultLocale` if no valid locale is found.\n\nFinally, the detected locale is assigned to `ctx[localeContextKey]`, and the middleware proceeds by calling `next()`.\n\n---\n\n## Usage Examples\n\n### 1. Query Parameter Detection\n\n```ts\nimport { detectLocale } from \"tezx/detect-locale\";\n\napp.get(\n  \"/welcome\",\n  detectLocale({ supportedLocales: [\"en\", \"fr\", \"bn\"], queryKeyLocale: \"lang\" }),\n  (ctx) => {\n    return ctx.json({\n      message: {\n        en: \"Welcome!\",\n        fr: \"Bienvenue !\",\n        bn: \"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!\",\n      }[ctx.locale],\n    });\n  }\n);\n```\n\n---\n\n### 2. Cookie-Based Detection\n\n```ts\napp.get(\n  \"/welcome\",\n  detectLocale({ supportedLocales: [\"en\", \"fr\", \"bn\"], cookieKeyLocale: \"locale\" }),\n  (ctx) => {\n    return ctx.json({ message: { en: \"Welcome!\", fr: \"Bienvenue !\", bn: \"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!\" }[ctx.locale] });\n  }\n);\n```\n\n---\n\n### 3. Accept-Language Header Detection\n\n```ts\napp.get(\n  \"/welcome\",\n  detectLocale({ supportedLocales: [\"en\", \"fr\", \"bn\"] }),\n  (ctx) => {\n    return ctx.json({ message: { en: \"Welcome!\", fr: \"Bienvenue !\", bn: \"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!\" }[ctx.locale] });\n  }\n);\n```\n\n---\n\n### 4. Custom Locale Detector\n\n```ts\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  customLocaleDetector: (ctx) => {\n    const userId = ctx.req.headers.get(\"x-user-id\");\n    const userLocales = { user123: \"bn\" };\n    return userLocales[userId] || undefined;\n  },\n});\n```\n\n---\n\n### 5. Default Locale Fallback\n\n```ts\ndetectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"fr\",\n});\n```\n\n---\n\n### 6. Custom Context Key and Combining All\n\n```ts\ndetectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"en\",\n  queryKeyLocale: \"language\",\n  cookieKeyLocale: \"user_locale\",\n  localeContextKey: \"userLocale\",\n  customLocaleDetector: (ctx) => {\n    // Your logic here\n  },\n});\n```\n\n---\n\n## Best Practices\n\n* Ensure `supportedLocales` covers all locales your app supports.\n* Use consistent and clear names for keys (`queryKeyLocale`, `cookieKeyLocale`, `localeContextKey`).\n* Implement `customLocaleDetector` for complex scenarios like DB lookups or geolocation.\n* Enable logging/debugging during development to troubleshoot detection.\n* Secure cookies storing locale preferences (HTTP-only, Secure flags).\n* Handle malformed or complex `Accept-Language` headers gracefully.\n\n---\n\n## Error Handling and Robustness\n\n* Unsupported or invalid query param and cookie values are ignored.\n* Malformed `Accept-Language` headers are safely filtered.\n* Invalid results from custom detectors fall back to `defaultLocale`.\n* Always guarantees a valid locale is set in context.\n\n---\n\n## Type Definitions\n\n```ts\ntype DetectLocaleOptions = {\n  supportedLocales: string[];\n  defaultLocale?: string;\n  queryKeyLocale?: string;\n  cookieKeyLocale?: string;\n  localeContextKey?: string;\n  customLocaleDetector?: (ctx: Context) => string | undefined;\n};\n\ndeclare function detectLocale(options: DetectLocaleOptions): Middleware;\n```\n\n---\n"
        },
        {
          "originalPath": "Detect bot.md",
          "id": 25,
          "name": "Detect bot",
          "type": "file",
          "path": "middleware/detect-bot",
          "content": "# DetectBot Middleware\n\n`detectBot` is a powerful and extensible middleware designed to detect and handle bot traffic in your web applications. It combines multiple detection techniques like User-Agent analysis, IP blacklisting, query parameter flags, rate limiting, and custom logic to identify bots effectively.\n\n---\n\n## âš ï¸ Important Prerequisite: Use `getConnInfo()` Middleware First\n\nTo enable accurate IP detection (used for IP blacklisting and rate limiting), you **must** register the `getConnInfo()` middleware **before** `detectBot()`:\n\n```ts\nimport { getConnInfo } from \"tezx/node\"; // or \"tezx/bun\", \"tezx/deno\" depending on runtime\nimport { detectBot } from \"tezx/detect-bot\";\n\napp.use(getConnInfo()); // <-- Injects IP info into ctx.req.remoteAddress\napp.use(detectBot());\n```\n\nFailing to do so will cause IP-based detections to malfunction.\n\n---\n\n## Installation\n\n```bash\nnpm install tezx\n```\n\n---\n\n## Import\n\n```ts\nimport { detectBot } from \"tezx/detect-bot\";\nimport { getConnInfo } from \"tezx/node\"; // or bun / deno\n```\n\n---\n\n## Configuration Options\n\n| Option                  | Type                                                                          | Default Value                         | Description                                                            |\n| ----------------------- | ----------------------------------------------------------------------------- | ------------------------------------- | ---------------------------------------------------------------------- |\n| `botUserAgents`         | `string[]`                                                                    | `[\"bot\", \"spider\", \"crawl\", \"slurp\"]` | User-Agent substrings to detect bots                                   |\n| `maxRequests`           | `number`                                                                      | `30`                                  | Max requests allowed within the rate-limit window                      |\n| `windowMs`              | `number`                                                                      | `60000` (1 minute)                    | Rate limit window duration in milliseconds                             |\n| `isBlacklisted`         | `(ctx: Context, ip: string) => boolean \\| Promise<boolean>`                   | `() => false`                         | Async check to determine if an IP is blacklisted                       |\n| `queryKeyBot`           | `string`                                                                      | `\"bot\"`                               | Query parameter key to flag bot traffic (e.g., `?bot=true`)            |\n| `onBotDetected`         | `\"block\" \\| ((ctx: Context, result: BotDetectionResult) => HttpBaseResponse)` | `\"block\"`                             | Action on bot detection: `\"block\"` or custom callback                  |\n| `enableRateLimiting`    | `boolean`                                                                     | `false`                               | Enable rate limiting-based bot detection                               |\n| `customBotDetector`     | `(ctx: Context) => boolean \\| Promise<boolean>`                               | `() => false`                         | Custom asynchronous function to detect bots                            |\n| `customBlockedResponse` | `(ctx: Context, result: BotDetectionResult) => HttpBaseResponse`              | Default 403 JSON error                | Custom response returned when bot is blocked                           |\n| `storage`               | Custom storage with `get/set/clearExpired` for rate limiting state            | In-memory Map                         | Custom storage implementation, e.g., Redis, for rate limit persistence |\n| `confidenceThreshold`   | `number` (0-1)                                                                | `0.5`                                 | Confidence threshold to mark as bot when multiple indicators are found |\n\n---\n\n## How It Works\n\n1. **User-Agent Check**\n   Scans the User-Agent header against common bot substrings.\n\n2. **IP Blacklist Check**\n   Checks if the client IP is blacklisted (customizable).\n\n3. **Query Parameter**\n   Detects bot traffic flagged by query params like `?bot=true`.\n\n4. **Rate Limiting**\n   Optionally tracks and limits requests per IP over a time window.\n\n5. **Custom Detection Logic**\n   Supports user-defined async functions for bespoke bot detection.\n\n6. **Confidence Score**\n   Combines multiple indicators to calculate a confidence score for nuanced detection.\n\n7. **Response Handling**\n   Blocks detected bots or triggers custom response handlers.\n\n---\n\n## Usage Examples\n\n### Basic Usage (Block bots by User-Agent)\n\n```ts\nimport { getConnInfo } from \"tezx/node\";\nimport { detectBot } from \"tezx/detect-bot\";\n\napp.use(getConnInfo());\napp.use(detectBot());\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, human!\");\n});\n```\n\n---\n\n### Advanced Usage with IP Blacklist and Rate Limiting\n\n```ts\napp.use(getConnInfo());\n\napp.use(\n  detectBot({\n    botUserAgents: [\"bot\", \"crawler\", \"spider\"],\n    maxRequests: 15,\n    windowMs: 60000,\n    enableRateLimiting: true,\n    isBlacklisted: async (ctx, ip) => {\n      const blacklist = [\"10.0.0.1\", \"192.168.0.5\"];\n      return blacklist.includes(ip);\n    },\n    customBotDetector: async (ctx) => !ctx.headers.get(\"referer\"),\n    onBotDetected: (ctx, { reason, indicators }) => {\n      ctx.setStatus = 403;\n      return ctx.json({ error: \"Bot blocked\", reason, indicators });\n    },\n  }),\n);\n```\n\n---\n\n### Using Redis for Distributed Rate Limiting\n\n```ts\nimport Redis from \"ioredis\";\n\nconst redis = new Redis();\n\nconst redisStorage = {\n  get: async (key) => {\n    const val = await redis.get(key);\n    return val ? JSON.parse(val) : undefined;\n  },\n  set: async (key, value) => {\n    await redis.set(key, JSON.stringify(value), \"PX\", value.resetTime - Date.now());\n  },\n  clearExpired: () => {}, // Redis handles expiration automatically\n};\n\napp.use(getConnInfo());\n\napp.use(\n  detectBot({\n    enableRateLimiting: true,\n    storage: redisStorage,\n    maxRequests: 50,\n    windowMs: 60000,\n  }),\n);\n```\n\n---\n\n## Best Practices\n\n* Always register `getConnInfo()` **before** `detectBot`.\n* Tune `maxRequests` and `windowMs` based on your app traffic patterns.\n* Use `customBotDetector` for domain-specific bot patterns.\n* Enable `GlobalConfig.debugging` to track bot detections during development.\n* For production or multiple server instances, use a distributed store (Redis, etc.) for rate limiting.\n\n---\n\n## Sample Bot Detection Response\n\n```json\n{\n  \"error\": \"Bot blocked\",\n  \"reason\": \"Multiple Indicators\",\n  \"indicators\": [\"User-Agent\", \"Blacklisted IP\", \"Query Parameter\"]\n}\n```\n\n---\n"
        },
        {
          "originalPath": "Lazy Loader.md",
          "id": 26,
          "name": "Lazy Loader",
          "type": "file",
          "path": "middleware/lazy-loader",
          "content": "# `lazyLoader` Middleware\n\nThe `lazyLoader` middleware enables dynamic, lazy loading of modules in a `tezx` application based on route or query parameters. It supports caching, lifecycle hooks, and module validation to optimize performance and ensure reliability.\n\n## Overview\n\nThe `lazyLoader` middleware enables dynamic, lazy loading of modules in a `tezx/lazy-loader` application based on runtime parameters (e.g., query, route, or custom logic). It supports caching, lifecycle hooks, module validation, and an optional `init` function for module-specific initialization. The `init` function is a critical feature, allowing modules to perform asynchronous setup, validate prerequisites, or short-circuit the request lifecycle. This document provides a unified explanation of the `init` functionâ€™s work procedure, its integration with the middleware, and a consolidated example that incorporates the diverse use cases from four demos.\n\n### Key Features\n\n- **Dynamic Module Loading**: Load modules on-demand via configurable loaders.\n- **Caching**: Cache modules with customizable TTL and storage (e.g., `Map`, Redis).\n- **Lifecycle Hooks**: Execute custom logic at stages like load, cache hit, or error.\n- **Module Validation**: Ensure modules meet structural or behavioral criteria.\n- **Initialization via `init`**: Perform asynchronous setup or early responses per module.\n- **Flexible Module Identification**: Support query parameters, route parameters, or custom logic.\n\nImport the middleware and related types:\n\n```typescript\nimport { lazyLoader } from \"tezx/lazy-loader\";\n```\n\n### Type Definitions\n\n```typescript\nexport type LazyModuleLoader<T> = () => Promise<T>;\nexport interface CacheItem<T = any> {\n  module: T;\n  expiresAt: number;\n}\ninterface LazyLoadOptions<T> {\n  moduleKey?: (ctx: Context) => string;\n  getModuleLoader: (\n    ctx: Context,\n  ) => Promise<LazyModuleLoader<T> | null> | null | LazyModuleLoader<T>;\n  queryKeyModule?: string;\n  moduleContextKey?: string;\n  enableCache?: boolean;\n  cacheStorage?: {\n    get: (key: string) => CacheItem<T> | undefined;\n    set: (key: string, value: CacheItem<T>) => void;\n    delete: (key: string) => void;\n  };\n  cacheTTL?: number;\n  lifecycleHooks?: {\n    onLoad?: (moduleName: string, ctx: Context) => void;\n    onError?: (moduleName: string, error: Error, ctx: Context) => void;\n    onComplete?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheHit?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheSet?: (moduleName: string, module: T, ctx: Context) => void;\n  };\n  validateModule?: (module: T) => boolean;\n}\n```\n\n### Middleware Signature\n\n```typescript\nexport const lazyLoader = <T = any>(options: LazyLoadOptions<T>): Middleware;\n```\n\n---\n\n## Work Procedure of the `init` Function\n\n### Purpose\n\nThe `init` function is an optional, asynchronous method exported by a module to:\n\n- Perform setup tasks (e.g., initializing resources, fetching configurations).\n- Validate request-specific prerequisites (e.g., API keys, tokens).\n- Modify the `Context` object for downstream use.\n- Return early responses to short-circuit the middleware chain (e.g., errors, redirects).\n\n### Code Context\n\nThe `init` function is invoked in the middleware as follows:\n\n```typescript\nif (module.init && typeof module.init === \"function\") {\n  const initResult = await module.init(ctx);\n  if (initResult) {\n    return initResult;\n  }\n}\n```\n\n### Operational Workflow\n\nThe `init` function is processed within the middleware pipeline as follows:\n\n1. **Module Identification**:\n\n   - The middleware determines the module name using `moduleKey`, `queryKeyModule`, or route parameters.\n   - Example: `ctx.req.query.module` (Demo 1, 3), `ctx.req.params.module` (Demo 2), or `ctx.req.body.moduleName` (Demo 4).\n\n2. **Module Loading**:\n\n   - The `getModuleLoader` function returns a `LazyModuleLoader`, which dynamically imports the module.\n   - The loaded module is validated using `validateModule` (if provided).\n\n3. **init Function Detection**:\n\n   - The middleware checks if the module exports an `init` function (`module.init && typeof module.init === \"function\"`).\n   - If absent, the middleware skips to caching or context attachment.\n\n4. **init Invocation**:\n\n   - The `init` function is called with the `Context` object (`ctx`):\n\n     ```typescript\n     const initResult = await module.init(ctx);\n     ```\n\n   - The `Context` provides access to `req`, `res`, and custom properties, enabling request-specific logic.\n   - Asynchronous operations (e.g., database queries, API calls) are awaited.\n\n5. **Result Processing**:\n\n   - **Truthy Result**: If `initResult` is non-falsy (e.g., `{ error: \"Unauthorized\" }`), the middleware returns it, halting further processing (e.g., no caching, no `next`).\n   - **Falsy Result**: If `initResult` is `null`, `undefined`, or absent, the middleware continues.\n   - The `Context` may be modified (e.g., `ctx.config = {...}`) for use by the module or downstream middleware.\n\n6. **Post-Initialization**:\n\n   - The module is cached (if `enableCache` is true) with the specified `cacheTTL`.\n   - The module is attached to the context (`ctx[moduleContextKey] = module`).\n   - The `onComplete` lifecycle hook is triggered.\n   - The middleware proceeds to `await next()`.\n\n7. **Error Handling**:\n   - Errors thrown by `init` are caught in the middlewareâ€™s `try-catch` block.\n   - The `onError` hook is invoked, and the response status is set to 500 (`ctx.setStatus = 500`).\n   - The error is re-thrown for upstream handling.\n\n### Integration Points\n\n- **Before `init`**: Module loading and validation ensure the module is valid.\n- **During `init`**: The function performs setup, validation, or early responses.\n- **After `init`**: Caching, context attachment, and lifecycle hooks complete the cycle.\n- **Short-Circuiting**: A truthy `initResult` bypasses caching, context attachment, and `next`.\n\n---\n\n#### `LazyLoadOptions<T>`\n\nConfiguration options for the `lazyLoader` middleware.\n\n| Property           | Description                                               | Default                                                                      |\n| ------------------ | --------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| `moduleKey`        | Function to extract the module name from the context.     | `(ctx) => ctx.req.params[queryKeyModule] \\|\\| ctx.req.query[queryKeyModule]` |\n| `getModuleLoader`  | Function to retrieve the module loader.                   | Required                                                                     |\n| `queryKeyModule`   | Query parameter name to select the module.                | `\"module\"`                                                                   |\n| `moduleContextKey` | Key to attach the loaded module to the context.           | `\"module\"`                                                                   |\n| `enableCache`      | Enable caching of loaded modules.                         | `true`                                                                       |\n| `cacheStorage`     | Custom cache storage implementation.                      | `Map<string, CacheItem<T>>`                                                  |\n| `cacheTTL`         | Cache Time-To-Live (TTL) in milliseconds.                 | `3600000` (1 hour)                                                           |\n| `lifecycleHooks`   | Lifecycle hooks for custom actions during module loading. | `{}`                                                                         |\n| `validateModule`   | Function to validate the loaded module.                   | `undefined`                                                                  |\n\n---\n\n## Consolidated Example: Unified Production-Ready Application\n\nThis example combines features from all four demos:\n\n- **Query-based loading** (Demo 1).\n- **Route-based loading** (Demo 2).\n- **Async `init` function** (Demo 3).\n- **Custom module key with validation** (Demo 4).\n\nIt demonstrates a production-ready setup with robust error handling, caching, lifecycle hooks, and a complex `init` function.\n\n### File Structure\n\n```bash\nproject/\nâ”œâ”€â”€ modules/\nâ”‚   â”œâ”€â”€ dashboard.js\nâ”‚   â”œâ”€â”€ orders.js\nâ”‚   â”œâ”€â”€ auth.js\nâ”‚   â”œâ”€â”€ report.js\nâ””â”€â”€ server.js\n```\n\n### Code\n\n**`server.js`**:\n\n```typescript\nimport { Context } from \"tezx\";\nimport { lazyLoader, CacheItem } from \"tezx/lazy-loader\";\n\n// Custom cache storage\nconst customCache = new Map<string, CacheItem>();\nconst cacheStorage = {\n  get: (key: string) => customCache.get(key),\n  set: (key: string, value: CacheItem) => customCache.set(key, value),\n  delete: (key: string) => customCache.delete(key),\n};\n\n// Module loader map\nconst moduleLoaders: Record<string, () => Promise<any>> = {\n  dashboard: () => import(\"./modules/dashboard.js\"),\n  orders: () => import(\"./modules/orders.js\"),\n  auth: () => import(\"./modules/auth.js\"),\n  report: () => import(\"./modules/report.js\"),\n};\n\n// Middleware configuration\nconst lazyLoadMiddleware = lazyLoader({\n  moduleKey: (ctx: Context) => {\n    // Prioritize body, then query, then params\n    return (\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module\n    );\n  },\n  getModuleLoader: async (ctx: Context) => {\n    const moduleName =\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module;\n    return moduleLoaders[moduleName] || null;\n  },\n  queryKeyModule: \"module\",\n  moduleContextKey: \"loadedModule\",\n  enableCache: true,\n  cacheTTL: 120000, // 2 minutes\n  cacheStorage,\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) =>\n      console.log(\n        `Loading ${moduleName} for request ID: ${ctx.req.id || \"unknown\"}`,\n      ),\n    onCacheHit: (moduleName, module, ctx) =>\n      console.log(`Cache hit for ${moduleName}`),\n    onCacheSet: (moduleName, module, ctx) =>\n      console.log(`Cached ${moduleName}`),\n    onComplete: (moduleName, module, ctx) =>\n      console.log(`Completed loading ${moduleName}`),\n    onError: (moduleName, error, ctx) =>\n      console.error(`Error in ${moduleName}: ${error.message}`),\n  },\n  validateModule: (module) => {\n    // Require handler function and version property\n    return (\n      typeof module.handler === \"function\" && typeof module.version === \"string\"\n    );\n  },\n});\n\n// Create Tezx app\napp.use(lazyLoadMiddleware);\n\n// Routes\napp.get(\"/api/query\", async (ctx: Context) => {\n  // Query-based (Demo 1, 3)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.get(\"/api/route/:module\", async (ctx: Context) => {\n  // Route-based (Demo 2)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.post(\"/api/body\", async (ctx: Context) => {\n  // Body-based (Demo 4)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 400;\n  return { error: \"Invalid or missing module\" };\n});\n```\n\n**`modules/dashboard.js`** (Demo 1-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Dashboard module\",\n  data: { widgets: [\"chart\", \"table\"] },\n});\n```\n\n**`modules/orders.js`** (Demo 2-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Orders module\",\n  data: { orderId: ctx.req.query.orderId || 123 },\n});\n```\n\n**`modules/auth.js`** (Demo 3-inspired, with complex `init`):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  const apiKey = ctx.req.headers[\"x-api-key\"];\n  if (!apiKey) {\n    return {\n      status: 401,\n      error: \"API key required\",\n    };\n  }\n  try {\n    // Simulate async config fetch\n    const config = await fetchConfig(apiKey);\n    ctx.authConfig = config; // Attach to context\n    return null;\n  } catch (error) {\n    return {\n      status: 500,\n      error: `Auth initialization failed: ${error.message}`,\n    };\n  }\n};\nexport const handler = (ctx) => ({\n  message: \"Auth module\",\n  data: { token: \"abc123\", config: ctx.authConfig },\n});\n\n// Simulated async function\nasync function fetchConfig(apiKey) {\n  return { apiKey, settings: { scope: \"user\" } };\n}\n```\n\n**`modules/report.js`** (Demo 4-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  return null;\n};\nexport const handler = (ctx) => ({\n  message: \"Report module\",\n  data: { type: ctx.req.body?.reportType || \"sales\" },\n});\n```\n\n### Example Features\n\n- **Unified Module Identification**: Supports query (`/api/query?module=...`), route (`/api/route/:module`), and body (`POST /api/body`) inputs.\n- **Robust `init` Function**: The `auth` module demonstrates a complex `init` with API key validation, async configuration fetch, and context modification.\n- **Custom Cache Storage**: Uses a `Map`-based cache with a 2-minute TTL.\n- **Strict Validation**: Ensures modules have a `handler` function and `version` property.\n- **Comprehensive Lifecycle Hooks**: Logs all stages (load, cache hit, cache set, complete, error).\n- **Error Handling**: Gracefully handles missing modules, validation failures, and `init` errors.\n\n---\n"
        },
        {
          "originalPath": "Pagination.md",
          "id": 27,
          "name": "Pagination",
          "type": "file",
          "path": "middleware/pagination",
          "content": "\n# ğŸ“„ PaginationHandler Middleware\n\nThe `paginationHandler` middleware simplifies adding pagination support to your web app. It parses query params, fetches paginated data dynamically, and enriches responses with useful metadata.\n\n---\n\n## Key Features\n\n* âœ… Parses and sanitizes pagination query parameters (`page` & `limit`).\n* âœ… Supports dynamic data fetching via customizable data source function.\n* âœ… Attaches detailed pagination metadata (`totalPages`, `hasNextPage`, etc.).\n* âœ… Configurable defaults, limits, and response keys.\n* âœ… Graceful error handling and input validation.\n\n---\n\n## Installation\n\n```ts\nimport { paginationHandler } from \"tezx/pagination\";\n```\n\n---\n\n## Configuration Options\n\n| Option          | Type                                                                                                             | Default     | Description                                                   |\n| --------------- | ---------------------------------------------------------------------------------------------------------------- | ----------- | ------------------------------------------------------------- |\n| `defaultPage`   | `number`                                                                                                         | `1`         | Default page number if none provided.                         |\n| `defaultLimit`  | `number`                                                                                                         | `10`        | Default items per page if none provided.                      |\n| `maxLimit`      | `number`                                                                                                         | `100`       | Maximum allowed items per page.                               |\n| `queryKeyPage`  | `string`                                                                                                         | `\"page\"`    | Query param name for page number.                             |\n| `queryKeyLimit` | `string`                                                                                                         | `\"limit\"`   | Query param name for items per page.                          |\n| `countKey`      | `string`                                                                                                         | `\"total\"`   | Key in response containing total item count.                  |\n| `dataKey`       | `string`                                                                                                         | `\"data\"`    | Key in response containing the data array.                    |\n| `getDataSource` | `(ctx: Context, pagination: { page: number; limit: number; offset: number }) => Promise<{ [key: string]: any }>` | `undefined` | Function to fetch paginated data and total count dynamically. |\n\n---\n\n## Usage Examples\n\n### Basic Usage: Parsing Pagination Params Only\n\n```ts\napp.use(paginationHandler());\n\napp.get(\"/users\", (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  return ctx.json({ message: `Page ${page}, Limit ${limit}, Offset ${offset}` });\n});\n```\n\n*Request*: `GET /users?page=2&limit=20`\n\n*Response*:\n\n```json\n{\n  \"message\": \"Page 2, Limit 20, Offset 20\"\n}\n```\n\n---\n\n### Advanced Usage: With Dynamic Data Source\n\n```ts\nasync function fetchProducts(ctx, { page, limit, offset }) {\n  const products = await Product.findAll({ offset, limit });\n  const total = await Product.count();\n  return { items: products, totalCount: total };\n}\n\napp.get(\n  \"/products\",\n  paginationHandler({\n    defaultPage: 1,\n    defaultLimit: 5,\n    maxLimit: 50,\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n    countKey: \"totalCount\",\n    dataKey: \"items\",\n    getDataSource: fetchProducts,\n  }),\n  (ctx) => ctx.json(ctx.body),\n);\n```\n\n*Request*: `GET /products?p=2&size=10`\n\n*Response*:\n\n```json\n{\n  \"items\": [ /* 10 products */ ],\n  \"totalCount\": 25,\n  \"pagination\": {\n    \"page\": 2,\n    \"limit\": 10,\n    \"totalItems\": 25,\n    \"totalPages\": 3,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": true,\n    \"nextPage\": 3,\n    \"prevPage\": 1\n  }\n}\n```\n\n---\n\n### Custom Response Keys\n\n```ts\nasync function fetchUsers(ctx, { page, limit, offset }) {\n  const users = await User.findAll({ offset, limit });\n  const total = await User.count();\n  return { records: users, count: total };\n}\n\napp.get(\n  \"/users\",\n  paginationHandler({\n    countKey: \"count\",\n    dataKey: \"records\",\n    getDataSource: fetchUsers,\n  }),\n);\n```\n\n---\n\n## How It Works\n\n1. Reads `page` and `limit` from query parameters (customizable keys).\n2. Sanitizes values: enforces minimum `page = 1`, and `limit <= maxLimit`.\n3. Calculates offset = `(page - 1) * limit`.\n4. Calls `getDataSource` (if provided) with pagination info.\n5. Attaches paginated data and metadata to `ctx.body`.\n\n---\n\n## Pagination Metadata Included\n\n* `page` â€” current page number\n* `limit` â€” items per page\n* `totalItems` â€” total number of items available\n* `totalPages` â€” total pages calculated\n* `hasNextPage` â€” boolean, if next page exists\n* `hasPrevPage` â€” boolean, if previous page exists\n* `nextPage` â€” next page number or `null`\n* `prevPage` â€” previous page number or `null`\n\n---\n\n## Error Handling\n\n* Invalid or missing `page`/`limit` query params default to configured defaults.\n* Limits are clamped to `maxLimit`.\n* Missing `getDataSource` means only pagination info is attached; data fetching is manual.\n\n---\n\n## Best Practices\n\n* Set sensible `maxLimit` to prevent excessive data loads.\n* Use database-level pagination (`OFFSET`/`LIMIT`) in `getDataSource` for performance.\n* Customize response keys to integrate with existing APIs.\n* Test edge cases such as empty datasets or out-of-range pages.\n\n---\n\n## Sample Output (Page 3 of 5 items per page, total 13 items)\n\n```json\n{\n  \"items\": [ /* last 3 items */ ],\n  \"totalCount\": 13,\n  \"pagination\": {\n    \"page\": 3,\n    \"limit\": 5,\n    \"totalItems\": 13,\n    \"totalPages\": 3,\n    \"hasNextPage\": false,\n    \"hasPrevPage\": true,\n    \"nextPage\": null,\n    \"prevPage\": 2\n  }\n}\n```\n\n---\n"
        },
        {
          "originalPath": "Powered By.md",
          "id": 28,
          "name": "Powered By",
          "type": "file",
          "path": "middleware/powered-by",
          "content": "# ğŸš€ PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware adds an `X-Powered-By` HTTP header to every response, indicating your server or framework name. Itâ€™s lightweight and allows optional customization of the header value.\n\n---\n\n## Features\n\n* Adds `X-Powered-By` header to all responses.\n* Optional custom server name (defaults to `\"TezX\"`).\n* Simple and efficient middleware for Express-like environments.\n\n---\n\n## Installation\n\nMake sure your app supports middleware (e.g., Express, Koa, TezX).\n\n---\n\n## Usage\n\n### Import\n\n```ts\nimport { poweredBy } from \"tezx/powered-by\";\n```\n\n### Apply Middleware\n\n```ts\napp.use(poweredBy());           // Sets header to \"TezX\"\napp.use(poweredBy(\"MyServer\")); // Sets header to \"MyServer\"\n```\n\n---\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string) => Middleware;\n```\n\n* **`serverName`** *(optional)* â€” Custom string for `X-Powered-By` header. Default: `\"TezX\"`\n\n---\n\n## How it works\n\n1. Middleware sets `X-Powered-By` header on the response.\n2. Uses provided `serverName` or `\"TezX\"` by default.\n3. Calls `next()` to continue request handling.\n\n---\n\n## Example Response Header\n\n```http\nX-Powered-By: MyServer\n```\n\n---\n\n## Notes\n\n* Add this middleware early in your stack to ensure the header is included.\n* Changing the header value can help with branding or obscure server details for security.\n\n---\n"
        },
        {
          "originalPath": "Rate Limiter.md",
          "id": 29,
          "name": "Rate Limiter",
          "type": "file",
          "path": "middleware/rate-limiter",
          "content": "# Rate Limiting Middleware (`rateLimiter`)\n\nA robust, configurable middleware to throttle client requests and prevent abuse by limiting the number of requests per time window. Uses a sliding window strategy with in-memory storage by default (Redis support planned).\n\n---\n\n## âš ï¸ Important: Use `getConnInfo()` First\n\nTo detect client IPs correctly (`ctx.req.remoteAddress`), **always register `getConnInfo()` before `rateLimiter`**:\n\n```ts\nimport { getConnInfo } from \"tezx/node\"; // or \"tezx/bun\" / \"tezx/deno\"\nimport { rateLimiter } from \"tezx/middleware\";\n\napp.use(getConnInfo()); // REQUIRED for IP detection\napp.use(rateLimiter({ maxRequests: 100, windowMs: 60_000 }));\n```\n\n---\n\n## Installation\n\n```bash\nnpm install tezx\n```\n\nImport:\n\n```ts\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n---\n\n## Middleware Options (`RateLimiterOptions`)\n\n| Option         | Type                                           | Default              | Description                                                                    |\n| -------------- | ---------------------------------------------- | -------------------- | ------------------------------------------------------------------------------ |\n| `maxRequests`  | `number`                                       | **Required**         | Max requests allowed per client in the time window                             |\n| `windowMs`     | `number`                                       | **Required**         | Time window duration in milliseconds                                           |\n| `keyGenerator` | `(ctx: Context) => string`                     | Client IP and port   | Function to uniquely identify clients (e.g., user ID or IP)                    |\n| `storage`      | `{ get, set, clearExpired }`                   | In-memory Map        | Storage backend for tracking request counts (Redis support via custom storage) |\n| `onError`      | `(ctx, retryAfter, error) => HttpBaseResponse` | Sends 429 by default | Custom handler called when rate limit is exceeded                              |\n\n---\n\n## Usage Examples\n\n### Basic: Limit 100 requests per minute per IP\n\n```ts\nimport { getConnInfo } from \"tezx/node\";\nimport { rateLimiter } from \"tezx/middleware\";\n\napp.use(getConnInfo());\napp.use(rateLimiter({\n  maxRequests: 100,\n  windowMs: 60_000,\n}));\n```\n\n---\n\n### Custom client identification (e.g., user ID)\n\n```ts\napp.use(rateLimiter({\n  maxRequests: 10,\n  windowMs: 10_000,\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({\n      error: \"Too Many Requests\",\n      retryAfter: `${retryAfter} seconds`,\n    });\n  },\n}));\n```\n\n---\n\n### Using Redis for distributed rate limiting\n\n```ts\nimport Redis from \"ioredis\";\n\nconst redis = new Redis();\n\nconst redisStorage = {\n  get: async (key) => {\n    const val = await redis.get(key);\n    return val ? JSON.parse(val) : undefined;\n  },\n  set: async (key, value) => {\n    await redis.set(key, JSON.stringify(value), \"PX\", value.resetTime - Date.now());\n  },\n  clearExpired: () => {\n    // Redis auto-expires keys; no cleanup needed here\n  },\n};\n\napp.use(getConnInfo());\n\napp.use(rateLimiter({\n  maxRequests: 50,\n  windowMs: 60_000,\n  storage: redisStorage,\n}));\n```\n\n---\n\n## How It Works\n\n* Uses a **sliding window** algorithm counting requests per client key within `windowMs`.\n* Default client key is `ip:port` but customizable via `keyGenerator`.\n* Stores counts and reset times in a cache (default `Map` or custom storage).\n* On exceeding limits, responds with HTTP 429 and `Retry-After` header.\n* Adds these headers to every response:\n\n  * `X-RateLimit-Limit` â€” Max allowed requests\n  * `X-RateLimit-Remaining` â€” Remaining requests in current window\n  * `X-RateLimit-Reset` â€” Timestamp when window resets\n  * `Retry-After` â€” Seconds to wait before next allowed request (on 429)\n\n---\n\n## Best Practices\n\n* Always use `getConnInfo()` **before** `rateLimiter`.\n* Customize `keyGenerator` for authenticated users to rate limit by user ID.\n* Use a distributed storage backend (like Redis) for multi-instance deployments.\n* Adjust `maxRequests` and `windowMs` to fit your app's traffic and security needs.\n* Use stricter limits on sensitive endpoints (e.g., login).\n* Monitor and log rate limiting events to tune thresholds.\n\n---\n\n## Troubleshooting\n\n| Problem                   | Cause                                 | Solution                                  |\n| ------------------------- | ------------------------------------- | ----------------------------------------- |\n| Too many 429 responses    | Low `maxRequests` or short `windowMs` | Increase limits or widen window duration  |\n| Rate limiting not working | Missing `getConnInfo()` middleware    | Add `getConnInfo()` before `rateLimiter`  |\n| Growing memory usage      | Many unique keys in in-memory storage | Use Redis or periodically cleanup storage |\n| Unstable client keys      | Unstable/custom `keyGenerator` output | Ensure `keyGenerator` returns stable IDs  |\n\n---\n\n## Advanced: Different Limits by Route\n\n```ts\nconst apiLimiter = rateLimiter({ maxRequests: 100, windowMs: 15 * 60_000 });\nconst loginLimiter = rateLimiter({ maxRequests: 5, windowMs: 60_000 });\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/login\", loginLimiter);\n```\n\n---\n\n## Custom Error Handler Example\n\n```ts\napp.use(rateLimiter({\n  maxRequests: 100,\n  windowMs: 60_000,\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({\n      code: \"RATE_LIMITED\",\n      message: `Please wait ${retryAfter} seconds before retrying.`,\n      retryAfter,\n    });\n  },\n}));\n```\n\n---\n"
        },
        {
          "originalPath": "Request ID.md",
          "id": 30,
          "name": "Request ID",
          "type": "file",
          "path": "middleware/request-id",
          "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/request-id\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Adds the request ID to the response headers.\n4. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
        },
        {
          "originalPath": "Request Timeout.md",
          "id": 31,
          "name": "Request Timeout",
          "type": "file",
          "path": "middleware/request-timeout",
          "content": "# ğŸ•’ `requestTimeout` Middleware\n\nEnforce dynamic, per-request timeouts in your middleware stackâ€”complete with custom error handling, logging, and cleanup logic.\n\n---\n\n## ğŸ“Œ Overview\n\nThe `requestTimeout` middleware is designed for frameworks using a `Context`-based architecture (like `tezx`). It:\n\n* Dynamically sets timeouts per request.\n* Gracefully handles timeout errors.\n* Logs and cleans up after timeouts.\n* Works seamlessly with other middleware.\n\n---\n\n## ğŸ”§ API\n\n### `requestTimeout(options: TimeoutOptions): Middleware`\n\n#### `TimeoutOptions`\n\n| Option            | Type                                             | Required | Description                                                                      |\n| ----------------- | ------------------------------------------------ | -------- | -------------------------------------------------------------------------------- |\n| `getTimeout`      | `(ctx: Context) => number`                       | âœ…        | Returns timeout (in ms) based on the request context.                            |\n| `onTimeout`       | `(ctx: Context, error: Error) => CallbackReturn` | âŒ        | Called when request times out. Default: 504 + `{ error: \"Request timed out.\" }`. |\n| `logTimeoutEvent` | `(ctx: Context, error: Error) => void`           | âŒ        | Called when timeout happens. Default: logs warning via `debugging.warn`.         |\n| `cleanup`         | `(ctx: Context) => void`                         | âŒ        | Cleanup hook after timeout (DB, streams, etc). Default: no-op.                   |\n\n---\n\n## âœ¨ Features\n\n* â± Dynamic timeouts based on route, headers, or user state\n* ğŸ§  Custom handlers for timeout error response\n* ğŸ“œ Event logging for timeout diagnostics\n* ğŸ§¹ Reliable resource cleanup\n* ğŸ§© Easy integration with existing middleware\n\n---\n\n## ğŸš€ Usage Examples\n\n### âœ… Basic Timeout\n\n```ts\nimport { requestTimeout } from \"tezx/request-timeout\";\n\napp.use(requestTimeout({\n  getTimeout: () => 5000, // 5 seconds\n}));\n```\n\n> All requests timeout after 5 seconds.\n\n---\n\n### ğŸ“‚ Per-Path Timeout\n\n```ts\napp.use(requestTimeout({\n  getTimeout: (ctx) =>\n    ctx.path.startsWith(\"/api/slow\") ? 10000 : 3000,\n  onTimeout: (ctx, error) => {\n    ctx.setStatus = 504;\n    ctx.body = {\n      error: `Request to ${ctx.path} timed out.`,\n    };\n  },\n}));\n```\n\n> Custom response for slow API paths.\n\n---\n\n### ğŸ§¾ With Logging & Cleanup\n\n```ts\napp.use(requestTimeout({\n  getTimeout: () => 5000,\n  logTimeoutEvent: (ctx, err) => {\n    console.warn(`â± Timeout: ${ctx.method} ${ctx.path}`);\n  },\n  cleanup: (ctx) => {\n    releaseDB(ctx.state.connection);\n  },\n}));\n```\n\n> Logs timeouts and ensures database connections are released.\n\n---\n\n### ğŸ›¡ï¸ Auth-Aware Timeout\n\n```ts\napp.use(authenticate); // Sets ctx.user\n\napp.use(requestTimeout({\n  getTimeout: (ctx) => ctx.user ? 10000 : 3000,\n}));\n```\n\n> Authenticated users get more generous timeouts.\n\n---\n\n## ğŸ“¦ Behavior Summary\n\n| Behavior          | Description                                        |\n| ----------------- | -------------------------------------------------- |\n| `getTimeout`      | Called first to get the timeout duration           |\n| `onTimeout`       | Called only if timeout occurs                      |\n| `logTimeoutEvent` | Invoked on timeout for diagnostics                 |\n| `cleanup`         | Always runs in `finally`, even on error or timeout |\n\n---\n\n## â— Error Handling\n\n* Timeout âœ `onTimeout` called, response handled, middleware chain stops.\n* Normal error âœ Propagated normally.\n* `cleanup` always runsâ€”guaranteed by `finally`.\n\n---\n\n## ğŸ§  Best Practices\n\n* Use short timeouts on user-facing endpoints.\n* Customize `onTimeout` with helpful errors.\n* Always log and release resources in `cleanup`.\n* Test slow endpoints to verify timeout + cleanup.\n\n---\n\n## ğŸš« Limitations\n\n* Timer precision limited by JavaScript event loop.\n* Assumes `ctx.method`, `ctx.path`, `ctx.setStatus`, and `ctx.body` exist.\n* Doesn't automatically cancel long-running internal operations (e.g., DB queries).\n\n---\n\n## ğŸ“ Types Export\n\n```ts\nimport type {\n  TimeoutOptions,\n  requestTimeout,\n} from \"tezx/request-timeout\";\n```\n\n---\n"
        },
        {
          "originalPath": "Sanitize Headers.md",
          "id": 32,
          "name": "Sanitize Headers",
          "type": "file",
          "path": "middleware/sanitize-headers",
          "content": "# ğŸ§¼ `sanitizeHeaders` Middleware\n\nEnhance HTTP request header hygiene by normalizing, filtering, and sanitizing headers â€” designed for modern web security and compliance.\n\n---\n\n## ğŸ“Œ Overview\n\nThe `sanitizeHeaders` middleware provides a powerful mechanism to:\n\n* Enforce **header name and value sanitation**\n* Strip disallowed headers via **whitelist or blacklist**\n* Normalize header names for consistency\n* Defend against **header injection** attacks (e.g. CRLF)\n\n---\n\n## ğŸ“¦ Installation\n\n```ts\nimport { sanitizeHeaders } from \"tezx/sanitize-headers\";\n```\n\n---\n\n## ğŸš€ Basic Usage\n\n```ts\napp.use(sanitizeHeaders());\n```\n\n> All incoming request headers will be normalized and sanitized using default safe policies.\n\n---\n\n## âš™ï¸ Advanced Configuration\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n---\n\n## ğŸ”§ Configuration Options\n\n### `whitelist: string[]`\n\n* **Default:** `[]` (allows all headers)\n* Case-insensitive list of allowed header names.\n* When non-empty, **only these headers are preserved**.\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"];\n```\n\n---\n\n### `blacklist: string[]`\n\n* **Default:** `[]` (blocks none)\n* Case-insensitive list of header names to **explicitly remove**.\n\n```ts\nblacklist: [\"x-powered-by\", \"server\"];\n```\n\n---\n\n### `allowUnsafeCharacters: boolean`\n\n* **Default:** `false`\n* When `false`, removes **control characters (e.g., CR/LF)** from header values to mitigate injection attacks.\n\n```ts\nallowUnsafeCharacters: true; // Less secure\n```\n\n---\n\n## ğŸ›  Internal Processing Flow\n\n1. **Iterate headers** â†’ one-by-one\n2. **Normalize header names** (if enabled)\n3. **Apply whitelist / blacklist**\n4. **Validate header name format**: must match `/^[a-zA-Z0-9\\-_]+$/`\n5. **Sanitize values**:\n\n   * Trims whitespace\n   * Removes dangerous characters (unless allowed)\n6. **Rebuild headers**\n7. **Overwrite original request headers**\n\n---\n\n## ğŸ› Debug Logging\n\nWhen enabled, the global debugging utility reports:\n\n* ğŸš« Removed headers due to policy\n* âš ï¸ Invalid header names\n* âš ï¸ Suspicious or empty values\n\n---\n\n## ğŸ§  Best Practices\n\n### 1. Secure Defaults\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n  }),\n);\n```\n\n### 2. Hide Server Internals\n\n```ts\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n  }),\n);\n```\n\n### 3. Compatibility Assurance\n\n* Test against your client apps before enforcing strict whitelists.\n* Monitor which headers are stripped unexpectedly.\n\n### 4. Layered Security\n\n* Use in conjunction with:\n\n  * CORS middleware\n  * Content Security Policy (CSP)\n  * XSS/CSRF protection middleware\n\n---\n\n## âš¡ Performance Notes\n\n* Fast execution: single-pass header processing\n* Case-insensitive lookups are optimized\n* Tip: Normalize whitelist values for faster lookup:\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n```\n\n---\n\n## ğŸ” Security Highlights\n\n| Threat                  | Protection                                                            |\n| ----------------------- | --------------------------------------------------------------------- |\n| Header Injection (CRLF) | Stripped by default                                                   |\n| Technology exposure     | Use `blacklist` to hide `\"x-powered-by\"`, `\"server\"` headers          |\n| Unsafe values           | Control characters removed (unless `allowUnsafeCharacters` is `true`) |\n\n---\n\n## âœ… Client Compatibility\n\n* Compatible with all modern browsers and clients.\n* Changes affect server-side only.\n* Useful for:\n\n  * APIs serving untrusted clients\n  * Systems requiring strict request validation\n  * Compliance-heavy environments (e.g. PCI, HIPAA)\n\n---\n"
        },
        {
          "originalPath": "Secure Headers.md",
          "id": 33,
          "name": "Secure Headers",
          "type": "file",
          "path": "middleware/secure-headers",
          "content": "# ğŸ›¡ï¸ `secureHeaders` Middleware\n\nSecure your HTTP responses with modern, configurable security headers. Ideal for protecting web applications against common browser-based vulnerabilities.\n\n---\n\n## ğŸ“Œ Overview\n\nThe `secureHeaders` middleware dynamically sets HTTP security headers, applying best practices by default while allowing custom configurations per route or request.\n\n---\n\n## âœ¨ Features\n\n* âœ… Applies essential HTTP security headers\n* âš™ï¸ Fully customizable per header\n* ğŸ§  Supports dynamic values via functions (per request)\n* ğŸ§ª Environment-aware defaults (e.g. HSTS in production only)\n\n---\n\n## ğŸ“¦ Installation\n\n```ts\nimport { secureHeaders } from \"tezx/secure-headers\";\n```\n\n---\n\n## ğŸš€ Usage\n\n### Minimal Setup (Defaults Applied)\n\n```ts\napp.use(secureHeaders());\n```\n\n### With Custom Header Configuration\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n---\n\n## ğŸ”§ Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n* `options` *(optional)*: `SecurityHeaderOptions` â€“ object defining custom header values (strings, booleans, or functions).\n\n### Returns\n\nA middleware function that injects the configured security headers into HTTP responses.\n\n---\n\n## ğŸ§± Supported Security Headers\n\n| Header                      | Default Value                                                                              | Purpose                                 |\n| --------------------------- | ------------------------------------------------------------------------------------------ | --------------------------------------- |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` | Prevents resource injection (XSS, etc.) |\n| `X-Frame-Options`           | `DENY`                                                                                     | Blocks clickjacking                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains` *(only in production)*                               | Enforces HTTPS                          |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            | Enables legacy XSS protection           |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  | Prevents MIME-sniffing                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              | Controls what `Referer` is sent         |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 | Restricts browser APIs                  |\n\n---\n\n## ğŸ§  Dynamic Header Configuration\n\nEach option supports either:\n\n* A **static string or boolean** (enabled/disabled)\n* A **function**: `(ctx: Ctx) => string | undefined`\n\n### Example: Route-specific CSP\n\n```ts\nsecureHeaders({\n  contentSecurityPolicy: (ctx) =>\n    ctx.url.startsWith(\"/admin\")\n      ? \"default-src 'self'; script-src 'self';\"\n      : undefined, // fallback to default\n});\n```\n\n---\n\n## ğŸŒ Example\n\n```ts\nimport { secureHeaders } from \"tezx/secure-headers\";\n\napp.use(\n  secureHeaders({\n    hsts: false, // Disable HSTS\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.startsWith(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined,\n    referrerPolicy: \"strict-origin-when-cross-origin\",\n  }),\n);\n\napp.get(\"/\", (ctx) => ctx.send(\"Hello, World!\"));\napp.get(\"/admin\", (ctx) => ctx.send(\"Admin Dashboard\"));\n```\n\n---\n\n## ğŸ§ª Testing & Verification\n\n### 1. Default Route\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected:\n\n```\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n---\n\n### 2. Admin Route with Custom CSP\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected:\n\n```\nContent-Security-Policy: default-src 'self'; script-src 'self';\n```\n\n---\n\n### 3. HSTS Disabled\n\nNo `Strict-Transport-Security` header is present.\n\n---\n\n## âœ… Best Practices\n\n* âœ… Place early in middleware chain to ensure headers are applied globally.\n* âœ… Use dynamic rules for admin or sensitive routes.\n* âœ… Keep `unsafe-inline` to a minimum in CSP.\n* âœ… Use `hsts: true` only in production (enabled by default in prod).\n\n---\n\n## ğŸ” Security Summary\n\n| Threat                 | Defense Mechanism                  |\n| ---------------------- | ---------------------------------- |\n| XSS (script injection) | `Content-Security-Policy`, `X-XSS` |\n| Clickjacking           | `X-Frame-Options`                  |\n| Protocol downgrade     | `Strict-Transport-Security`        |\n| MIME sniffing          | `X-Content-Type-Options`           |\n| Over-sharing referrers | `Referrer-Policy`                  |\n| Feature abuse          | `Permissions-Policy`               |\n\n---\n"
        },
        {
          "originalPath": "XSS protection.md",
          "id": 34,
          "name": "XSS protection",
          "type": "file",
          "path": "middleware/xss-protection",
          "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```ts\nimport { xssProtection } from \"tezx/xss-protection\";\n```\n\n## Basic Usage\n\n```ts\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n* **Default:** `true`\n* Enables or disables the XSS protection.\n* Can be a static boolean or a function that evaluates dynamically based on request context.\n\n#### Examples\n\n```ts\nenabled: true; // Always enabled\nenabled: (ctx) => !ctx.url.startsWith(\"/admin\"); // Disabled for admin\n```\n\n---\n\n### `mode: \"block\" | \"filter\"`\n\n* **Default:** `\"block\"`\n* Defines the behavior when XSS is detected:\n\n  * `\"block\"`: Prevents page from rendering.\n  * `\"filter\"`: Tries to sanitize and allow rendering.\n\n#### Examples\n\n```ts\nmode: \"block\";  // More secure, stricter\nmode: \"filter\"; // More tolerant, user-friendly\n```\n\n---\n\n### `fallbackCSP: string`\n\n* **Default:** `\"default-src 'self'; script-src 'self';\"`\n* Fallback CSP applied only when no `Content-Security-Policy` header is already set.\n* Helps secure older browsers or edge cases.\n\n#### Example\n\n```ts\nfallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n```\n\n---\n\n## Technical Implementation Details\n\n### Headers Set\n\n| Header                    | Example Value          | Purpose                            |\n| ------------------------- | ---------------------- | ---------------------------------- |\n| `X-XSS-Protection`        | `1; mode=block` or `1` | Enables browser XSS filters        |\n| `Content-Security-Policy` | As configured          | Fallback policy for older browsers |\n\n### Flow\n\n1. Check if protection is enabled.\n2. Determine `X-XSS-Protection` mode based on config.\n3. Set fallback CSP if no existing CSP header exists.\n4. Proceed to the next middleware.\n\n---\n\n## Debug Logging\n\n* ğŸŸ  Skipped protection due to `enabled = false`\n* ğŸŸ¢ Set `X-XSS-Protection` header\n* ğŸŸ£ Applied fallback `Content-Security-Policy`\n\n---\n\n## Best Practices\n\n* âœ… Use `\"block\"` mode in production unless filtering is required.\n* âœ… Only disable protection for trusted internal/admin routes.\n* âœ… Complement this middleware with:\n\n  * Input sanitization\n  * Output escaping\n  * Proper CSP setup\n\n---\n\n## Browser Compatibility\n\n| Browser       | `X-XSS-Protection` Support | CSP Support  |\n| ------------- | -------------------------- | ------------ |\n| Chrome (â‰¤78)  | âœ…                          | âœ…            |\n| Edge (Legacy) | âœ…                          | âœ…            |\n| Firefox       | âŒ (ignores this header)    | âœ… (CSP only) |\n| Safari        | âœ…                          | âœ…            |\n\n* **Tip:** Rely on CSP as a long-term strategy â€” `X-XSS-Protection` is deprecated in some browsers.\n\n---\n\n## Security Considerations\n\n* \"Block\" mode is safest, but test for layout/content impact.\n* \"Filter\" mode offers more flexibility for legacy or complex UIs.\n* Always pair with CSP, validation, and escaping mechanisms.\n\n---\n\n## Example: Per-Route XSS Mode\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => ctx.url.startsWith(\"/public\"),\n    mode: \"filter\",\n  }),\n);\n```\n"
        },
        {
          "originalPath": "i18n.md",
          "id": 35,
          "name": "i18n",
          "type": "file",
          "path": "middleware/i18n",
          "content": "# ğŸŒ `i18n` Middleware for TezX\n\nAdvanced internationalization middleware supporting dynamic translation loading, fallback language chains, caching, and customizable message formatting.\n\n---\n\n## ğŸ“„ Basic Usage\n\n```ts\nimport { i18n } from \"tezx/i18n\";\n\napp.use(\n  i18n({\n    loadTranslations: (lang) => import(`./locales/${lang}.json`),\n    defaultLanguage: \"en\",\n  }),\n);\n```\n\n---\n\n## ğŸ”§ API: `i18n(options: I18nOptions): Middleware`\n\n### Configuration Options\n\n| Option                   | Type                                                                          | Default                           | Description                                          |\n| ------------------------ | ----------------------------------------------------------------------------- | --------------------------------- | ---------------------------------------------------- |\n| `loadTranslations`       | `(language: string) => Promise<{ translations: object, expiresAt?: number }>` | **Required**                      | Dynamically loads translations for a given language  |\n| `defaultCacheDuration`   | `number`                                                                      | `3600000` (1 hour)                | Cache expiration time in milliseconds                |\n| `isCacheValid`           | `(cached: object, language: string) => boolean`                               | `cached.expiresAt > Date.now()`   | Custom cache validation logic                        |\n| `detectLanguage`         | `(ctx: Context) => string`                                                    | Query > Cookie > Header > default | Custom language detection logic                      |\n| `defaultLanguage`        | `string`                                                                      | `'en'`                            | Fallback language if detection fails                 |\n| `fallbackChain`          | `string[]`                                                                    | `[]`                              | Array of fallback languages in priority order        |\n| `translationFunctionKey` | `string`                                                                      | `'t'`                             | Key on `ctx` where the translation function is added |\n| `formatMessage`          | `(msg: string, vars?: Record<string, any>) => string`                         | Basic `{{var}}` interpolation     | Custom message formatting/interpolation function     |\n| `cacheTranslations`      | `boolean`                                                                     | `true`                            | Enable or disable caching of translations            |\n\n---\n\n## ğŸ’¬ Translation Format\n\nTranslations can be structured as nested JSON objects:\n\n```json\n{\n  \"home\": {\n    \"title\": \"Welcome, {{name}}!\",\n    \"subtitle\": \"Your dashboard\"\n  },\n  \"common\": {\n    \"logout\": \"Log out\"\n  }\n}\n```\n\n---\n\n## ğŸ§  Features\n\n### 1. Language Detection\n\nDefault order: Query param (`?lang=fr`) â†’ Cookie (`lang=fr`) â†’ `Accept-Language` header â†’ `defaultLanguage`\n\nOverride with:\n\n```ts\ndetectLanguage: (ctx) => ctx.cookies.get(\"user_lang\") || \"en\";\n```\n\n### 2. Fallback Chain\n\nSupports fallback languages, e.g.:\n\n```ts\nfallbackChain: [\"fr-CA\", \"fr\", \"en\"];\n```\n\n### 3. Cache with Expiry\n\nTranslations can be cached with expiration either from `expiresAt` returned by loader or default duration.\n\n### 4. Message Interpolation\n\nSupports variable interpolation inside messages:\n\n```ts\nctx.t(\"home.title\", { name: \"Alice\" }); // â†’ \"Welcome, Alice!\"\n```\n\nCustom formatter example:\n\n```ts\nformatMessage: (msg, vars) => msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? \"\");\n```\n\n### 5. Nested Key Support\n\nSupports nested keys using dot notation:\n\n```ts\nctx.t('user.profile.greeting', { name: 'John' });\n```\n\n---\n\n## ğŸ§ª Advanced Example\n\n```ts\napp.use(\n  i18n({\n    loadTranslations: async (lang) => {\n      const res = await fetch(`https://api.example.com/lang/${lang}`);\n      const json = await res.json();\n      return { translations: json.data, expiresAt: json.expiresAt };\n    },\n    defaultLanguage: \"en\",\n    fallbackChain: [\"en-GB\", \"en\"],\n    detectLanguage: (ctx) => ctx.req.headers.get(\"x-custom-lang\") || \"en\",\n    translationFunctionKey: \"translate\",\n    formatMessage: (msg, vars) =>\n      msg.replace(/\\{\\{(.*?)\\}\\}/g, (_, key) => vars?.[key.trim()] ?? \"\"),\n    cacheTranslations: true,\n    isCacheValid: (cached) => cached.expiresAt > Date.now(),\n  }),\n);\n```\n\n---\n\n## ğŸ“Œ What `ctx` Provides After Middleware\n\n| Property            | Type                                      | Description                     |\n| ------------------- | ----------------------------------------- | ------------------------------- |\n| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function            |\n| `ctx.language`      | `string`                                  | Detected language               |\n| `ctx.languageChain` | `string[]`                                | Ordered fallback language chain |\n\n---\n\n## â— Error Handling\n\nIf translations are missing for all languages in the chain, the middleware throws an error and sets:\n\n```ts\nctx.setStatus = 500;\n```\n\n---\n\n## ğŸ“¤ Exported Types\n\nYou can import and use these types for strong typing:\n\n```ts\nimport type {\n  I18nOptions,\n  loadTranslations,\n  TranslationMap,\n} from \"tezx/i18n\";\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "7. Helpers",
      "name": "Helpers",
      "path": "helpers",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Cookie.md",
          "id": 36,
          "name": "Cookie",
          "type": "file",
          "path": "helpers/cookie",
          "content": "\n# ğŸª Cookie Utilities â€“ TezX Helper\n\nA utility module for managing HTTP cookies within TezX applications. This includes reading, setting, parsing, and deleting cookies in a type-safe and consistent manner.\n\n---\n\n## ğŸ“¦ Import\n\n```ts\nimport {\n  getCookie,\n  allCookies,\n  setCookie,\n  deleteCookie,\n  serializeOptions,\n} from \"tezx/helper\";\n```\n\n---\n\n## ğŸ§° API Reference\n\n### ğŸ” `getCookie(ctx: Context, name: string): string | undefined`\n\nRetrieve the value of a specific cookie from the incoming HTTP request.\n\n#### **Parameters for `getCookie`**\n\n* `ctx`: The request context.\n* `name`: The name of the cookie.\n\n#### **Returns**\n\n* The decoded cookie value if found, otherwise `undefined`.\n\n#### **Example**\n\n```ts\nconst session = getCookie(ctx, \"session_id\")\nif (session) {\n  console.log(\"Active session:\", session);\n}\n```\n\n---\n\n### ğŸ“‹ `allCookies(ctx: Context): Record<string, string>`\n\nParse all cookies from the request and return them as an object.\n\n#### **Parameters**\n\n* `ctx`: The request context.\n\n#### **Returns**\n\n* A key-value map of all cookies.\n\n#### **Example**\n\n```ts\nconst cookies = allCookies(ctx);\nconsole.log(\"Cookies:\", cookies);\n```\n\n---\n\n### â• `setCookie(ctx: Context, name: string, value: string, options?: CookieOptions): void`\n\nSet a cookie on the response using optional attributes.\n\n#### **Parameters for `setCookie`**\n\n* `ctx`: The response context.\n* `name`: The name of the cookie.\n* `value`: The value to store.\n* `options` *(optional)*: Configuration like expiration, security flags, etc.\n\n#### **Example**\n\n```ts\nsetCookie(ctx, \"session_id\", \"abc123\", {\n  httpOnly: true,\n  secure: true,\n  maxAge: 3600,\n  path: \"/\",\n});\n```\n\n---\n\n### âŒ `deleteCookie(ctx: Context, name: string, options?: CookieOptions): void`\n\nDelete a cookie by expiring it immediately.\n\n#### **Parameters for `deleteCookie`**\n\n* `ctx`: The response context.\n* `name`: The cookie to remove.\n* `options` *(optional)*: Must match original cookie attributes (e.g., `path`, `domain`) to ensure deletion.\n\n#### **Example**\n\n```ts\ndeleteCookie(ctx, \"session_id\", { path: \"/\" });\n```\n\n---\n\n### ğŸ› ï¸ `serializeOptions(options: CookieOptions): string`\n\nSerialize a cookie options object into a valid `Set-Cookie` string fragment.\n\n> Used internally, but available for custom header construction if needed.\n\n#### **Parameters for `serializeOptions`**\n\n* `options`: An object describing cookie settings.\n\n#### **Returns**\n\n* A string representation suitable for HTTP headers.\n\n#### **Example**\n\n```ts\nconst header = serializeOptions({ maxAge: 3600, httpOnly: true });\n// Output: \"Max-Age=3600; HttpOnly\"\n```\n\n---\n\n## ğŸ“‘ `CookieOptions` Interface\n\nUse this interface to configure cookie behavior:\n\n| Property   | Type                              | Description                                              |\n| ---------- | --------------------------------- | -------------------------------------------------------- |\n| `maxAge`   | `number`                          | Lifetime of the cookie (in seconds).                     |\n| `expires`  | `Date`                            | Absolute expiry timestamp.                               |\n| `path`     | `string`                          | Path scope of the cookie.                                |\n| `domain`   | `string`                          | Domain scope of the cookie.                              |\n| `secure`   | `boolean`                         | Send only over HTTPS.                                    |\n| `httpOnly` | `boolean`                         | Restrict access from JavaScript.                         |\n| `sameSite` | `'Strict'` \\| `'Lax'` \\| `'None'` | Restrict cross-site cookie behavior for CSRF protection. |\n\n---\n\n## âœ… Best Practices\n\n* Always use `httpOnly` and `secure` for sensitive cookies.\n* Use `path` and `domain` to avoid scope conflicts.\n* Set `sameSite: 'Strict'` or `'Lax'` for CSRF mitigation.\n* Call `deleteCookie()` with matching `path` and `domain` for successful removal.\n\n---\n"
        },
        {
          "originalPath": "2. useFormData.md",
          "id": 37,
          "name": "useFormData",
          "type": "file",
          "path": "helpers/useformdata",
          "content": "\n# ğŸš€ `useFormData` â€” Multipart Form & File Upload Handler\n\n`useFormData` is a powerful helper designed for efficient parsing, validation, and management of **multipart/form-data** HTTP requests in TezX applications. It simplifies handling complex file uploads combined with form fields while enforcing strict limits to protect your server from overload and security risks.\n\n---\n\n## ğŸ”§ Function Signature\n\n```ts\nimport { Context,FormDataOptions } from \"tezx\";\n\nexport async function useFormData(\n  ctx: Context,\n  options?: FormDataOptions\n): Promise<Record<string, string | File | (string | File)[]>>;\n```\n\n---\n\n## ğŸ”¥ Core Features\n\n* **Full multipart/form-data parsing** for text fields and file uploads\n* **Automatic merging** of repeated fields into arrays\n* **File validation:**\n\n  * MIME type whitelist\n  * Max file size per file\n  * Max number of files per field\n  * Max total upload size (combined all files)\n* **Text field validation:**\n\n  * Max size per text field (bytes/characters)\n  * Optional sanitization (trimming, escaping)\n* **Streaming-aware file processing** for large uploads (configurable)\n* Detailed **error handling** with descriptive messages\n* Easily **extensible** to add custom file processors or virus scanners\n\n---\n\n## ğŸ”¹ Parameters\n\n| Name      | Type              | Description                                                         |\n| --------- | ----------------- | ------------------------------------------------------------------- |\n| `ctx`     | `Context`         | TezX request context with the incoming multipart HTTP request       |\n| `options` | `FormDataOptions` | Optional configuration object to control validations and processing |\n\n---\n\n## ğŸ”¸ Returns\n\nPromise resolving to an object mapping field names to:\n\n* **string** â€” for text form fields\n* **File** â€” for single uploaded files\n* **Array\\<string | File>** â€” for repeated fields (multiple values/files)\n\n---\n\n## âš™ï¸ FormDataOptions Interface\n\n| Property       | Type       | Description                                                                     |\n| -------------- | ---------- | ------------------------------------------------------------------------------- |\n| `sanitized`    | `boolean`  | Enables sanitization of text inputs (trimming, escaping, etc.)                  |\n| `allowedTypes` | `string[]` | MIME types allowed for file uploads (e.g., `[\"image/jpeg\", \"application/pdf\"]`) |\n| `maxSize`      | `number`   | Maximum size (in bytes) allowed per individual file                             |\n| `maxFiles`     | `number`   | Maximum number of files accepted per single field                               |\n| `maxTotalSize` | `number`   | Maximum combined size (in bytes) allowed for all files in the request           |\n| `maxFieldSize` | `number`   | Maximum allowed length (characters or bytes) for text fields                    |\n\n---\n\n## ğŸ” Detailed Behavior\n\n### 1. **Multipart Form Parsing**\n\nThe function calls `ctx.req.formData()` internally to parse the multipart form. It then iterates over all fields and files, applying the configured validations.\n\n### 2. **File Handling**\n\n* **File Size:** Each file is checked against the `maxSize` option. Files exceeding this size are rejected immediately.\n* **File Count:** Enforces a strict maximum number of files per field via `maxFiles`.\n* **MIME Type Validation:** If `allowedTypes` is specified, files not matching allowed MIME types are rejected.\n* **Total Upload Size:** Keeps a running total of all uploaded file bytes and throws if the `maxTotalSize` is exceeded.\n* **Extensible Processing:** Internally calls a customizable `processFile` function for potential streaming, virus scanning, or on-the-fly compression.\n\n### 3. **Text Field Handling**\n\n* Checks each string field against `maxFieldSize` for length.\n* Optionally sanitizes text fields when `sanitized` is enabled (trimming whitespace, escaping dangerous chars).\n\n### 4. **Duplicate Field Names**\n\nFields with the same name are grouped into arrays, supporting inputs like:\n\n```html\n<input type=\"file\" name=\"photos\" multiple>\n<input type=\"text\" name=\"tags\">\n<input type=\"text\" name=\"tags\">\n```\n\n---\n\n## ğŸ›¡ï¸ Error Handling & Security\n\n* Throws clear, actionable errors on exceeding any configured limits (size, count, type).\n* Prevents large unexpected uploads from exhausting memory or disk space.\n* Supports input sanitization to prevent injection or XSS attacks from text fields.\n* Encourages defining strict `allowedTypes` and `maxSize` to avoid malicious uploads.\n\n---\n\n## âš¡ Example Usage (Robust File Upload)\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nasync function uploadHandler(ctx: Context) {\n  try {\n    const form = await useFormData(ctx, {\n      allowedTypes: [\"image/jpeg\", \"image/png\", \"application/pdf\"],\n      maxSize: 10 * 1024 * 1024,       // 10MB max per file\n      maxFiles: 5,                     // Max 5 files per field\n      maxTotalSize: 50 * 1024 * 1024, // 50MB combined limit\n      maxFieldSize: 2000,              // Max 2000 chars for text fields\n      sanitized: true,                 // Trim & sanitize text inputs\n    });\n\n    // Access text fields and files\n    const username = form[\"username\"];\n    const profilePics = form[\"photos\"]; // Array of File objects\n\n    // Process or store files\n    for (const file of Array.isArray(profilePics) ? profilePics : [profilePics]) {\n      // e.g. save to disk, cloud storage, virus scan, etc.\n      console.log(`Uploading file: ${file.name} (${file.size} bytes)`);\n    }\n\n    return ctx.text(\"Upload successful!\");\n  } catch (err) {\n    // Handle validation errors\n    return ctx.status(400).text(err.message);\n  }\n}\n```\n\n---\n"
        },
        {
          "originalPath": "3. Load Environment.md",
          "id": 38,
          "name": "Load Environment",
          "type": "file",
          "path": "helpers/load-environment",
          "content": "# `loadEnv(basePath?: string)`\n\n## Purpose\n\nLoads `.env` files into `process.env` (Node/Bun) or `Deno.env` and returns a typed object with environment variables for easy and type-safe access.\n\n---\n\n## Supported `.env` Files (Priority Order)\n\n```bash\n.env â†’ .env.local â†’ .env.[mode] â†’ .env.[mode].local\n```\n\n---\n\n## Return Type\n\n```ts\ntype EnvVariables = {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n};\n```\n\n---\n\n## Usage Example\n\n```ts\nimport { loadEnv } from \"tezx/node\"; // or \"tezx/bun\", \"tezx/deno\"\n\nconst env = loadEnv(\"./config\");\nconst port = env.PORT || process.env.PORT || \"3000\";\n```\n\n---\n\n# Custom Context in TezX\n\n## Purpose\n\nExtend TezXâ€™s base `Context` interface with your own typed properties to share data such as authenticated user info or request-specific metadata across middleware and routes.\n\n---\n\n## Example: Adding User and Request ID\n\n```ts\ninterface CustomContext {\n  user?: { id: string; roles: string[] };\n  requestId: string;\n}\n\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return next();\n});\n```\n\n---\n\n## Accessing Custom Context in Routes\n\n```ts\napp.get(\"/me\", (ctx) => ctx.json(ctx.user));\n```\n\n---\n\n# Server Initialization with Custom Context and Env\n\n```ts\nconst env = loadEnv();\n\nconst app = new TezX<CustomContext>({ env });\n\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n---\n\n# Configuration Options for `TezX`\n\n| Option | Type           | Description                    |\n| ------ | -------------- | ------------------------------ |\n| `env`  | `EnvVariables` | Injected environment variables |\n\nUse `ctx.env` in middleware/routes to access these variables safely.\n\n---\n\n# Best Practices\n\n* **.env Files Per Mode**\n\n```bash\n.env.development\n.env.production\n.env.production.local\n```\n\n* **Git Ignore**\n\n```bash\n.env.local\n.env.*.local\n```\n\n* **Feature Flags**\n\n```ts\nif (env.FEATURE_X === \"enabled\") {\n  enableExperimentalFeature();\n}\n```\n\n---\n\n## Advanced Context Usage\n\n```ts\ninterface AppContext {\n  user?: User;\n  analytics: Tracker;\n}\n\napp.use((ctx, next) => {\n  ctx.analytics = new Tracker(ctx.env.TRACKING_ID);\n  return next();\n});\n```\n\n---\n\nğŸ’¡ Combine `loadEnv()`, **custom typed contexts**, and `ctx.env` for a secure, clean, and scalable server foundation in TezX.\n"
        }
      ]
    },
    {
      "originalPath": "8. WebSocket.md",
      "id": 39,
      "name": "WebSocket",
      "type": "file",
      "path": "websocket",
      "content": "# ğŸ”Œ `upgradeWebSocket` Middleware\n\nTezX provides **first-class WebSocket support** via the `upgradeWebSocket` middleware, enabling seamless integration across **Node.js**, **Deno**, and **Bun** with runtime-specific optimizations.\n\n---\n\n## âœ… Prerequisites\n\n| Requirement          | Node.js          | Deno       | Bun        |\n| -------------------- | ---------------- | ---------- | ---------- |\n| Runtime Support      | âœ… Yes            | âœ… Native   | âœ… Native   |\n| WebSocket Dependency | âš ï¸ Requires `ws` | âœ… No       | âœ… No       |\n| TezX App             | âœ… Required       | âœ… Required | âœ… Required |\n\n```bash\n# For Node.js only\nnpm install ws\n```\n\n---\n\n## ğŸ“ Runtime-Specific Import\n\nImport the middleware from your target runtime package:\n\n```ts\n// Node.js\nimport { upgradeWebSocket } from \"tezx/node\";\n\n// Deno\nimport { upgradeWebSocket } from \"tezx/deno\";\n\n// Bun\nimport { upgradeWebSocket } from \"tezx/bun\";\n```\n\n---\n\n## ğŸ§© Type Definitions\n\n### `WebSocketEvent`\n\n```ts\ntype WebSocketEvent = {\n  open?: (ws: WebSocket, ctx?: Context) => void;\n  message?: (ws: WebSocket, data: string | Buffer | ArrayBuffer) => void;\n  close?: (ws: WebSocket, info: { code: number; reason: string }) => void;\n  error?: (ws: WebSocket, err: Error | any) => void;\n  ping?: (ws: WebSocket, data: Buffer) => void;\n  pong?: (ws: WebSocket, data: Buffer) => void;\n  drain?: (ws: WebSocket) => void;\n};\n```\n\n### `WebSocketCallback`\n\n```ts\ntype WebSocketCallback = (ctx: Context) => WebSocketEvent;\n```\n\n### `WebSocketOptions`\n\n```ts\ntype WebSocketOptions = {\n  onUpgradeError?: (err: Error, ctx: Context) => HttpBaseResponse;\n};\n```\n\n---\n\n## ğŸš€ Basic Usage\n\n```ts\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) {\n      console.log(\"WebSocket connected\");\n    },\n    message(ws, data) {\n      ws.send(`Echo: ${data}`);\n    },\n    close(ws, { code, reason }) {\n      console.log(\"Closed with\", code, reason);\n    },\n    error(ws, err) {\n      console.error(\"Error:\", err);\n    },\n  }))\n);\n```\n\n---\n\n## âš™ï¸ Runtime Setup\n\n### ğŸ§­ **Node.js + `ws`**\n\n```ts\nimport { createServer } from \"http\";\nimport { upgradeWebSocket, mountTezXOnNode } from \"tezx/node\";\n\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open: (ws) => console.log(\"Client connected\"),\n    message: (ws, msg) => ws.send(\"From Node: \" + msg),\n  }))\n);\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n```\n\n---\n\n### ğŸ¦• **Deno**\n\n```ts\nimport { upgradeWebSocket } from \"tezx/deno\";\n\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) {\n      console.log(\"WebSocket ready (Deno)\");\n    },\n    message(ws, msg) {\n      ws.send(\"From Deno: \" + msg);\n    },\n  }))\n);\n\nDeno.serve({ port: 3000 }, app.serve);\n```\n\n---\n\n### âš¡ **Bun**\n\n```ts\nimport { upgradeWebSocket } from \"tezx/bun\";\n\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) {\n      console.log(\"Client connected\");\n    },\n    message(ws, msg) {\n      ws.send(\"From Bun: \" + msg);\n    },\n  }))\n);\n\n// Required Bun.serve() handler for WebSocket routing\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  reusePort: true,\n  websocket: {\n    open(ws) {\n      return (ws.data as any)?.open?.(ws);\n    },\n    message(ws, msg) {\n      return (ws.data as any)?.message?.(ws, msg);\n    },\n    close(ws, code, reason) {\n      return (ws.data as any)?.close?.(ws, { code, reason });\n    },\n    ping(ws, data) {\n      return (ws.data as any)?.ping?.(ws, data);\n    },\n    pong(ws, data) {\n      return (ws.data as any)?.pong?.(ws, data);\n    },\n    drain(ws) {\n      return (ws.data as any)?.drain?.(ws);\n    },\n  },\n});\n```\n\n---\n\n## â— Upgrade Error Handling\n\nUse `onUpgradeError` to customize behavior when a connection fails:\n\n```ts\nupgradeWebSocket(callback, {\n  onUpgradeError: (err, ctx) => {\n    return ctx.text(\"Upgrade failed: \" + err.message, 400);\n  },\n});\n```\n\n---\n\n## ğŸ§ª Advanced Events\n\nYou can listen to lower-level events like `ping`, `pong`, or `drain` (Bun-only):\n\n```ts\nmessage(ws, data) {\n  ws.send(\"Hello\");\n},\nping(ws, buffer) {\n  console.log(\"Ping received:\", buffer);\n},\ndrain(ws) {\n  console.log(\"Backpressure relieved\");\n}\n```\n\n---\n\n## âœ… Runtime Compatibility Matrix\n\n| Feature                | Node.js (`ws`)  | Deno  | Bun        |\n| ---------------------- | --------------- | ----- | ---------- |\n| Native Upgrade         | âŒ Requires `ws` | âœ… Yes | âœ… Yes      |\n| `ctx.args[2]` Support  | âœ… Yes           | âŒ No  | âŒ No       |\n| `.data` Usage          | âŒ N/A           | âŒ N/A | âœ… Required |\n| `ping` / `pong` Events | âœ… Yes           | âŒ No  | âœ… Yes      |\n| `drain` Event          | âŒ No            | âŒ No  | âœ… Yes      |\n| Compression            | âœ… Via `ws`      | âŒ No  | âŒ No       |\n\n---\n\n## ğŸ›¡ Best Practices\n\n* Use `ping` and `pong` for health checks in Bun/Node.\n* In Bun, always return event handlers via `.data` to enable runtime delegation.\n* In Node, attach your server manually using `createServer()` and `mountTezXOnNode`.\n\n---\n"
    },
    {
      "originalPath": "9. Static File.md",
      "id": 40,
      "name": "Static File",
      "type": "file",
      "path": "static-file",
      "content": "# Static File Serving (`app.static()`)\n\n## Overview\n\nThe `static()` method enables efficient serving of static files (HTML, CSS, JS, images, videos, fonts) from a specified directory. You can serve files from the root (`/`) or a custom route, with full control over caching and response headers.\n\n---\n\n## Basic Usage\n\n### 1. Serve from Root\n\n```ts\napp.static(\"./public\");\n```\n\nğŸ“‚ `public/style.css` â†’ ğŸŒ `/style.css`\n\n---\n\n### 2. Serve from Custom Route\n\n```ts\napp.static(\"/static\", \"./assets\");\n```\n\nğŸ“‚ `assets/logo.png` â†’ ğŸŒ `/static/logo.png`\n\n---\n\n### 3. Serve with Options\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\nğŸ§  Files are cached for 1 hour.\n\n---\n\n## Method Signature\n\n```ts\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## Parameters\n\n| Name      | Type                             | Description                                     |\n| --------- | -------------------------------- | ----------------------------------------------- |\n| `route`   | `string` *(optional)*            | Base URL (e.g., `/static`). Defaults to `/`     |\n| `folder`  | `string`                         | Directory with static assets (e.g., `./public`) |\n| `options` | `StaticServeOption` *(optional)* | Configuration for caching, headers, etc.        |\n\n---\n\n## StaticServeOption\n\n| Option         | Type             | Default      | Description                         |\n| -------------- | ---------------- | ------------ | ----------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Sets `Cache-Control` header         |\n| `header`       | `HeaderResponse` | `undefined`  | Adds custom headers to the response |\n\n---\n\n## Examples\n\n### âœ… Long-Term Caching\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\", // 1 year\n});\n```\n\n---\n\n### ğŸ” Method Chaining\n\n```ts\napp.static(\"./public\").use(logger());\n```\n\n---\n\n### ğŸ”§ Override a Static File\n\n```ts\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/logo.png\", (ctx) => ctx.text(\"Overridden logo\"));\n```\n\n---\n\n## Features\n\n* âœ… **Automatic MIME types**\n* ğŸ” **Prevents directory traversal**\n* ğŸŒ **Works with Node.js, Bun, Deno**\n* ğŸ” **Supports method chaining**\n\n---\n\n## Best Practices\n\n* Use long-term `cacheControl` for versioned assets.\n* Prefix with `/static` to prevent route collisions.\n* Avoid serving sensitive or dynamic files.\n\n---\n\n## Learn More\n\n* [MDN â€“ Cache-Control Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)\n"
    },
    {
      "originalPath": "98.Toolkit",
      "name": "Toolkit",
      "path": "toolkit",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Middlewares",
          "name": "Middlewares",
          "path": "toolkit/1-middlewares",
          "type": "folder",
          "children": [
            {
              "originalPath": "Github Oauth2.md",
              "id": 41,
              "name": "Github Oauth2",
              "type": "file",
              "path": "toolkit/middlewares/github-oauth2",
              "content": "\n# ğŸ“¦ `@tezx/github-oauth2`\n\nGitHub OAuth2.0 middleware for the [TezX](https://github.com/tezxjs/TezX) web framework. Securely authenticate users via GitHub, and define custom sign-in, session, and token handling logic.\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/github-oauth2.svg)\n\n---\n\n## âœ… Setup GitHub OAuth App\n\nGo to: [https://github.com/settings/developers](https://github.com/settings/developers)\n\n1. Click **\"New OAuth App\"**\n2. Name: `My GitHub Login App`\n3. Homepage URL: `http://localhost:3000`\n4. Authorization callback URL: `http://localhost:3000/auth/github/callback`\n5. Save and copy `Client ID` and `Client Secret`\n\n## ğŸ“¥ Installation\n\n```bash\nnpm install @tezx/github-oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx github-auth -- --template github-oauth2 --y\n```\n\n---\n\n## ğŸ“„ Example Usage\n\n```ts\nimport { TezX } from 'tezx';\nimport {\n  GitHubOauthClient,\n  getGithubOAuthURL,\n  verifyGithubToken\n} from '@tezx/github-oauth2';\n\nconst app = new TezX({\n  debugMode: true\n});\n\n// Initialize OAuth client\nconst client = GitHubOauthClient({\n  clientId: process.env.GITHUB_CLIENT_ID!,\n  clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000'\n});\n\n// Step 1: Redirect user to GitHub login\napp.get('github', getGithubOAuthURL({\n  authClient: client,\n}), (ctx) => {\n  return ctx.redirect(ctx.github_oauth_url);\n});\n\n// Step 2: Verify GitHub token and handle user session\napp.get('/', verifyGithubToken({\n  authClient: client,\n  Callbacks: (ctx) => {\n    return {\n      session: async (session, user) => {\n        console.log('Session:', session);\n        console.log('User:', user);\n        return session;\n      }\n    };\n  }\n}), async (ctx) => {\n  return ctx.json({ success: true });\n});\n```\n\n---\n\n## ğŸ§© API Reference\n\n### `GitHubOauthClient(config: GithubOauthClient): GitHubAuthClient`\n\nCreates an OAuth client instance.\n\n#### Parameters\n\n| Name         | Type   | Description                    |\n| ------------ | ------ | ------------------------------ |\n| clientId     | string | GitHub OAuth App client ID     |\n| clientSecret | string | GitHub OAuth App client secret |\n| redirectUri  | string | URI GitHub should redirect to  |\n\n---\n\n### `getGithubOAuthURL(options: OAuthURLParams)`\n\nGenerates the GitHub OAuth URL and stores it in `ctx.state.get('github_oauth_url')`.\n\n#### Parameters\n\n| Name        | Type              | Description                                                      |\n| ----------- | ----------------- | ---------------------------------------------------------------- |\n| authClient  | GitHubOauthClient | The OAuth client instance                                        |\n| scopes      | string\\[]         | (Optional) OAuth scopes (default: `['read:user', 'user:email']`) |\n| state       | string            | (Optional) CSRF protection state value                           |\n| allowSignup | boolean           | (Optional) Allow GitHub signups (default: true)                  |\n\n---\n\n### `verifyGithubToken(options: { authClient: GitHubOauthClient, Callbacks: Callbacks })`\n\nMiddleware to validate the token returned from GitHub and handle user info.\n\n#### Parameters\n\n| Name       | Type                       | Description                  |\n| ---------- | -------------------------- | ---------------------------- |\n| authClient | GitHubOauthClient          | The initialized OAuth client |\n| Callbacks  | `(ctx) => CallbacksReturn` | Optional lifecycle methods   |\n\n---\n\n### ğŸŒ€ `CallbacksReturn`\n\n| Method                   | Description                                                       |\n| ------------------------ | ----------------------------------------------------------------- |\n| `signIn(user)`           | Called after user is authenticated. Return `true` to allow login. |\n| `jwt(token, user?)`      | Customize JWT token if applicable.                                |\n| `session(session, user)` | Customize the session object before sending to client.            |\n\n---\n\n## ğŸ›¡ Security Tip\n\nAlways validate the `state` returned from GitHub against a CSRF token stored on your server before accepting the response.\n\n---\n"
            },
            {
              "originalPath": "Google Oauth2.md",
              "id": 42,
              "name": "Google Oauth2",
              "type": "file",
              "path": "toolkit/middlewares/google-oauth2",
              "content": "\n## @tezx/google-oauth2\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/google-oauth2.svg)\n\n### **Documentation**\n\n<https://developers.google.com/identity/protocols/oauth2>\n\n### **Configuration**\n\n<https://console.developers.google.com/apis/credentials>\n\nProvides:\n\n* **OAuth2 client initialization**\n* **Auth URL generation**\n* **Token verification middleware**\n* **Full TypeScript support** with JSDoc annotations\n\n---\n\n### ğŸ”§ Installation\n\n```bash\nnpm install @tezx/google-oauth2 @googleapis/oauth2\n```\n\nOr with Yarn:\n\n```bash\nyarn add @tezx/google-oauth2 @googleapis/oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx google-auth -- --template google-oauth2 --y\n```\n\n---\n\n### ğŸš€ Quick Start\n\n```ts\nimport { TezX } from 'tezx';\nimport { GoogleOauthClient, getGoogleOAuthURL, verifyGoogleToken } from '@tezx/google-oauth2';\n\nconst app = new TezX({\n  debugMode: true,\n});\n\n// 1. Initialize OAuth2 client\nconst client = GoogleOauthClient({\n  clientId: process.env.GOOGLE_CLIENT_ID!,\n  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000/auth/callback',\n});\n\n// 2. Route to start Google login\napp.get('/auth/google', getGoogleOAuthURL({\n  authClient: client,\n  scopes: ['openid','email','profile'],\n}), (ctx) => {\n  return ctx.redirect(ctx.state.get('google_oauth_url'));\n});\n\n// 3. Callback route, verify token and establish session\napp.get('/auth/callback', verifyGoogleToken({\n  authClient: client,\n  onError: (err) => {\n    console.error('OAuth Error:', err);\n    // handle error or redirect\n  },\n  onSuccess: (tokens) => {\n    console.log('Tokens:', tokens);\n  },\n  Callbacks: (ctx)=> {\n    return {\n    signIn: async (user) => {\n      // e.g. allow only users from a domain\n      return user.email.endsWith('@yourcompany.com');\n    },\n    jwt: async (token, user) => {\n      // attach roles or custom claims\n      token.role = user.email_verified ? 'member' : 'guest';\n      return token;\n    },\n    session: async (session, user) => {\n      // persist user profile in session\n      session.user = {\n        id: user.sub,\n        email: user.email,\n        name: user.name,\n        picture: user.picture\n      };\n      return session;\n    }\n  }\n  } \n}), async (ctx) => {\n  // Now ctx.session is populated\n  return ctx.json({ success: true });\n});\n\n```\n\n---\n\n## ğŸ“š API Reference\n\n### `GoogleOauthClient(config) â†’ OAuth2Client`\n\nCreate a configured Google OAuth2 client.\n\n```ts\nimport type { OAuth2Client } from 'google-auth-library';\n\ninterface GoogleOauthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n}\n\n/**\n * @param config.clientId     Google OAuth Client ID.\n * @param config.clientSecret Google OAuth Client Secret.\n * @param config.redirectUri  Registered redirect URI.\n * @returns OAuth2Client\n */\nexport function GoogleOauthClient(config: GoogleOauthConfig): OAuth2Client;\n```\n\n---\n\n### `getGoogleOAuthURL(params) â†’ Middleware`\n\nGenerate and store the Google authentication URL in `ctx.state`.\n\n```ts\ninterface OAuthURLParams {\n  authClient: OAuth2Client;\n  scopes?: string[];               // default ['openid','email','profile']\n  loginHint?: string;              // optional, e.g. user email\n  prompt?: string;                 // default 'consent select_account'\n  accessType?: 'online'|'offline'; // default 'offline'\n  includeGrantedScopes?: boolean;  // default true\n}\n\n/**\n * Middleware that adds `state` header, generates auth URL, and redirects.\n * On success: ctx.state.get('google_oauth_url') contains the URL.\n */\nexport function getGoogleOAuthURL(params: OAuthURLParams): Middleware<any>;\n```\n\n---\n\n### `verifyGoogleToken(params) â†’ Middleware`\n\nValidate the OAuth callback, exchange the code, verify ID token, and invoke your callbacks.\n\n```ts\nexport type CallbacksReturn = {\n    /**\n     * Callback function called when a user signs in successfully.\n     * \n     * @param {User} user - The user object containing user details such as email, name, etc.\n     * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the sign-in is allowed. \n     *         If `false`, the sign-in will be rejected; if `true`, the sign-in will proceed.\n     * \n     * @example\n     * const callbacks = {\n     *     signIn: async (user) => {\n     *         // Check if the user is allowed to sign in\n     *         return user.email.endsWith('@example.com');\n     *     }\n     * };\n     */\n    signIn?: (user: User) => Promise<boolean>;\n\n    /**\n     * Callback function for handling JWT (JSON Web Token) creation or modification.\n     * \n     * @param {any} token - The token object that contains the user's authentication information.\n     * @param {User} [user] - The user object, which may be available depending on the context.\n     * @returns {Promise<any>} - A promise that resolves to a possibly modified token or additional data to be included with the token.\n     * \n     * @example\n     * const callbacks = {\n     *     jwt: async (token, user) => {\n     *         // Add custom data to the token, like user role\n     *         token.role = user?.role || 'guest';\n     *         return token;\n     *     }\n     * };\n     */\n    jwt?: (token: any, user?: User) => Promise<any>;\n\n    /**\n     * Callback function for handling user session management.\n     * \n     * @param {any} session - The session object containing session data.\n     * @param {User} user - The user object containing the authenticated user's information.\n     * @returns {Promise<any>} - A promise that resolves to the modified session data or a session object.\n     * \n     * @example\n     * const callbacks = {\n     *     session: async (session, user) => {\n     *         // Modify session object, e.g., store user roles or permissions in the session\n     *         session.userRole = user?.role || 'guest';\n     *         return session;\n     *     }\n     * };\n     */\n    session?: (session: any, user: User) => Promise<any>;\n};\n\nexport type Callbacks = (ctx: Context) => CallbacksReturn;\n\ninterface VerifyParams {\n  authClient: OAuth2Client;\n  onError?: (error: string) => void;\n  onSuccess?: (tokens: any, response: any) => void;\n  Callbacks: Callbacks;\n}\n\n/**\n * Middleware that:\n * 1. Exchanges `code` for tokens  \n * 2. Validates `id_token` audience  \n * 3. Executes `signIn`, `jwt`, `session` callbacks  \n * 4. Calls onSuccess or onError  \n */\nexport function verifyGoogleToken(params: VerifyParams): Middleware<any>;\n```\n\n---\n\n### ğŸ“ `User` & `Credentials` Types\n\n```ts\n/** Google user info returned by tokeninfo endpoint */\nexport type GoogleUser = {\n    iss: string;\n    azp: string;\n    aud: string;\n    sub: string;\n    email: string;\n    email_verified: string;\n    at_hash: string;\n    name: string;\n    picture: string;\n    given_name: string;\n    family_name: string;\n    iat: string;\n    exp: string;\n    alg: string;\n    kid: string;\n    typ: string;\n  // ...other standard claims\n};\n\n/** OAuth2 token set returned by getToken() */\nexport interface Credentials {\n  access_token?: string;\n  refresh_token?: string;\n  expiry_date?: number;\n  id_token?: string;\n  token_type?: string;\n  scope?: string;\n}\n```\n\n---\n\n## ğŸ›¡ Security & Best Practices\n\n* **State parameter**: Mitigate CSRF by using `state`.\n* **Prompt & access\\_type**: Use `offline` + `prompt='consent'` to receive refresh tokens.\n* **Scope minimization**: Request only the scopes you need.\n* **Token handling**: Securely store `refresh_token` if you need longâ€‘lived access.\n\n---\n"
            },
            {
              "originalPath": "Tezx profiler.md",
              "id": 43,
              "name": "Tezx profiler",
              "type": "file",
              "path": "toolkit/middlewares/tezx-profiler",
              "content": "# @tezx/profiler\n\nA lightweight, extensible profiling middleware for the [TezX](https://www.npmjs.com/package/tezx) framework. This module enables detailed tracking of runtime performance metrics, memory usage, CPU statistics, and supports custom plugins and rotating file storage.\n\n---\n\n## ğŸš€ Features\n\n- â±ï¸ Measure route execution time.\n- ğŸ’¾ Monitor memory usage in MB.\n- âš™ï¸ Capture CPU usage in milliseconds.\n- ğŸ“Š System stats endpoint (`/__profiler`) with a clean UI.\n- ğŸ”Œ Plugin hooks (`beforeProfile`, `afterProfile`).\n- ğŸ“ Rotating file storage for logs.\n- âœ… Written in TypeScript with full type safety.\n- ğŸŒ Supports Node.js, Deno, and Bun environments.\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/profiler\n```\n\n---\n\n## ğŸ› ï¸ Usage Example\n\n### Basic Setup\n\n```ts\nimport { TezX } from 'tezx';\nimport { profiler, createRotatingFileStorage } from '@tezx/profiler';\n\nconst app =new TezX();\n\napp.use(\n  profiler({\n    route: '/__profiler',\n    excludePaths: ['/favicon.ico'],\n    metrics: ['time', 'memory', 'cpu'],\n    storage: createRotatingFileStorage('./profiler.log', 1024 * 1024), // Rotate every 1MB\n    plugins: [],\n  })\n);\n\napp.get('/', (ctx) => ctx.json({ message: 'Hello World' }));\n\n```\n\n---\n\n## ğŸŒ Profiler UI\n\nVisit your app at:\n\n```bash\nhttp://localhost:3000/__profiler\n```\n\nYou'll see:\n\n- âœ… Uptime (seconds)\n- âœ… Timestamp\n- âœ… Memory Usage (rss, heapTotal, heapUsed, etc.) in MB\n- âœ… CPU Usage (user/system) in milliseconds\n\n---\n\n## âš™ï¸ Profiler Options\n\n| Option           | Type                                        | Default         | Description                             |\n|------------------|---------------------------------------------|-----------------|-----------------------------------------|\n| `route`          | `string`                                    | `/__profiler`   | Path to view system stats               |\n| `excludePaths`   | `string[]`                                  | `[]`            | Paths to ignore                         |\n| `metrics`        | `(\\\"time\\\" \\| \\\"memory\\\" \\| \\\"cpu\\\")[]`     | `['time', 'memory']` | Metrics to collect                |\n| `storage`        | `StorageAdapter`                            | `undefined`     | Save profile results                   |\n| `plugins`        | `ProfilerPlugin[]`                          | `[]`            | Hook into the profiling lifecycle      |\n\n---\n\n## ğŸ”Œ Plugins Example\n\n```typescript\nconst myPlugin = {\n  beforeProfile: () => console.log('Starting profiling...'),\n  afterProfile: (result) => console.log('Profile completed:', result),\n};\n\napp.use(profiler({ plugins: [myPlugin] }));\n```\n\n---\n\n## ğŸ—ƒï¸ Rotating File Storage Example\n\n```typescript\nconst storage = createRotatingFileStorage('./profiler.log', 1024 * 1024); // 1MB rotation\n\napp.use(profiler({ storage }));\n```\n\n- File automatically rotates when it reaches the configured size.\n- Supports Node.js, Deno, Bun file systems.\n\n---\n\n## ğŸ§‘â€ğŸ’» Example Profile Output\n\n```json\n{\n  \"name\": \"default\",\n  \"duration\": 6.25,\n  \"timestamp\": \"2025-07-06T19:25:47.753Z\",\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"memoryUsage\": {\n    \"rss\": 10485760,\n    \"heapTotal\": 6291456,\n    \"heapUsed\": 4194304,\n    \"external\": 102400,\n    \"arrayBuffers\": 51200\n  },\n  \"cpuUsage\": {\n    \"user\": 1416,\n    \"system\": 312\n  }\n}\n```\n\n---\n\n## âš¡ System Stats Breakdown\n\n### Memory Usage\n\n- `rss`: Resident Set Size (total memory allocated for the process)\n- `heapTotal`: Total size of allocated heap\n- `heapUsed`: Heap actually used\n- `external`: Memory used by C++ objects bound to JS\n- `arrayBuffers`: Memory allocated for ArrayBuffer\n\n### CPU Usage\n\n- `user`: Time spent in user mode (Î¼s)\n- `system`: Time spent in kernel mode (Î¼s)\n\n---\n\n## ğŸ” Environment Support\n\nâœ”ï¸ Node.js\nâœ”ï¸ Deno\nâœ”ï¸ Bun\n\n---\n<!-- \n## ğŸ” Future Enhancements\n\n- ğŸ”„ Redis or database storage adapters\n- ğŸ“ˆ Export metrics in Prometheus format\n- ğŸŒ Remote profiling dashboard -->\n\n---\n\n## ğŸ“œ License\n\nMIT Â© 2025 TezX Team\n"
            }
          ]
        },
        {
          "originalPath": "2. Helpers",
          "name": "Helpers",
          "path": "toolkit/2-helpers",
          "type": "folder",
          "children": [
            {
              "originalPath": "Devtools.md",
              "id": 44,
              "name": "Devtools",
              "type": "file",
              "path": "toolkit/helpers/devtools",
              "content": "\n# ğŸ“Š TezX DevTools\n\n> Developer-friendly diagnostics and inspector panel for TezX-based applications. Plug in to see routes, middlewares, env variables, cookies, and add your own custom debug tabs.\n\n---\n\n## âœ… Installation\n\n```bash\nnpm install @tezx/devtools\n```\n\nEnsure you also have:\n\n```bash\nnpm install tezx\n```\n\n---\n\n## ğŸš€ Quick Usage\n\nIn your TezX app entry (e.g., `server.ts` or `index.ts`):\n\n```ts\nimport { TezX } from \"tezx\";\nimport {nodeAdapter} from \"tezx/node\";\nimport DevTools from \"@tezx/devtools\";\n\nconst app = new TezX();\n\napp.get(\n  \"/devtools\",\n  DevTools(app, {\n    // Optional\n    // disableTabs: ['cookies', 'routes'],\n    // extraTabs: (ctx) => [ ... ]\n  })\n);\n\nnodeAdapter(app).listen(3000);\n```\n\nNow visit:\n**`http://localhost:3000/devtools`**\nto see a real-time diagnostic dashboard.\n\n---\n\n## ğŸ§© Built-in Tabs\n\n| Tab           | Description                                              |\n| ------------- | -------------------------------------------------------- |\n| `routes`      | Lists all loaded routes with method, path, and source    |\n| `middlewares` | Displays registered middleware and which routes use them |\n| `cookies`     | Shows request cookies (parsed from `ctx`)                |\n| `.env`        | Displays environment variables loaded via `.env`         |\n\n---\n\n## âš™ï¸ API: `DevTools(app, options)`\n\n```ts\nDevTools(app: TezX<any>, options?: Options): Callback\n```\n\n### Options\n\n| Option        | Type                                                      | Description             |\n| ------------- | --------------------------------------------------------- | ----------------------- |\n| `extraTabs`   | `(ctx) => TabType \\| Promise<TabType>`                    | Add your own tab panels |\n| `disableTabs` | `Array<'cookies' \\| 'routes' \\| '.env' \\| 'middlewares'>` | Hide built-in tabs      |\n\n---\n\n## ğŸ› ï¸ Add Custom Tabs\n\nYou can inject your own debug panels using the `extraTabs` option.\n\n```ts\nimport DevTools , { dumpMiddlewares } from \"@tezx/devtools\";\n\napp.get(\n  \"/devtools\",\n  DevTools(app, {\n    extraTabs(ctx) {\n      const rows = dumpMiddlewares(app)\n        .map(r => `<tr><td>${r.endpoint}</td><td>${r.pattern}</td><td>${r.appliedMiddlewares}</td></tr>`)\n        .join(\"\");\n      return [\n        {\n          tab: \"middlewares\",\n          label: \"Middleware Table\",\n          doc_title: \"Middleware Overview\",\n          content: `<table>${rows}</table>`\n        }\n      ];\n    }\n  })\n);\n```\n\n---\n\n## ğŸ“š Types\n\n```ts\ntype Tab = \"cookies\" | \"routes\" | \".env\" | \"middlewares\";\n\ntype TabType = {\n  doc_title: string;\n  label: string;\n  tab: Tab | string;\n  content: string; // Rendered HTML content\n}[];\n\ntype Options = {\n  extraTabs?: (ctx: Context) => Promise<TabType> | TabType;\n  disableTabs?: Tab[];\n};\n```\n\n---\n\n## ğŸ“ Directory Example\n\n**Using `tezx/router`**\n\n```bash\nmy-app/\nâ”œâ”€â”€ routes/\nâ”‚   â”œâ”€â”€ _middleware.ts\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ public/\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ tezx.config.mjs             â† setup TezX + DevTools here\nâ”œâ”€â”€ .env\nâ”œâ”€â”€ package.json\nâ””â”€â”€ tsconfig.json\n```\n\n---\n"
            },
            {
              "originalPath": "TezX localfs.md",
              "id": 45,
              "name": "TezX localfs",
              "type": "file",
              "path": "toolkit/helpers/tezx-localfs",
              "content": "# @tezx/localfs\n\n`@tezx/localfs` is a simple, runtime-agnostic local file storage library that works with Node.js, Deno, and Bun.\n\nIt allows you to:\n\n* Save files to the local disk.\n* Automatically detect file types.\n* Auto-create directories.\n* Validate file size & type.\n* Generate public URLs for serving files.\n* List files (with recursive support).\n\n---\n\n## âœ¨ Features\n\n* ğŸ‘ TypeScript ready\n* âœ… Cross-runtime support (Node.js, Deno, Bun)\n* ğŸ“ Auto-create directories when saving files\n* ğŸ” Auto-detect MIME types from file extensions\n* âš™ï¸ Secure file-type filtering based on allowed MIME types\n* ğŸ”— Generate public URLs for serving files\n* ğŸ™ï¸ Public file serving router (TezX Router)\n* ğŸ“‚ List files recursively or non-recursively\n* ğŸ§© Built-in TezX Router for serving static files\n\n---\n\n## ğŸ“¦ Installation\n\n### Node.js / Bun\n\n```bash\nnpm install @tezx/localfs\n# OR\nbun add @tezx/localfs\n```\n\n---\n\n## ğŸ”§ Basic Example (Node.js)\n\n```ts\nimport { LocalFS } from \"@tezx/localfs\";\nimport { readFile } from \"node:fs/promises\";\n\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n\nasync function run() {\n  const buffer = await readFile(\"photo.jpg\");\n\n  const saved = await storage.saveFile(\"photo.jpg\", buffer);\n  console.log(\"File saved:\", saved);\n\n  const files = await storage.listFiles(\"\", true);\n  console.log(\"All files:\", files);\n}\n\nrun();\n```\n\n---\n\n## ğŸ”¹ API Reference\n\n### new LocalFS(options)\n\n| Option               | Type       | Default    | Description                    |\n| -------------------- | ---------- | ---------- | ------------------------------ |\n| basePath             | `string`   | `uploads`  | Folder to save files           |\n| publicUrl            | `string`   | `/uploads` | Public path prefix             |\n| allowPublicAccess    | `boolean`  | `true`     | Enable/disable public serving  |\n| autoRenameOnConflict | `boolean`  | `true`     | Rename files if name conflicts |\n| maxFileSize          | `number`   | `5MB`      | Max upload size in bytes       |\n| allowedTypes         | `string[]` | `image/*`  | Allowed MIME types             |\n\n---\n\n### saveFile(fileName, buffer, mimeType?)\n\nSaves a file to the storage.\n\nReturns:\n\n```json\n{\n  \"savedPath\": \"uploads/photo.jpg\",\n  \"fileName\": \"photo.jpg\",\n  \"publicUrl\": \"/uploads/photo.jpg\"\n}\n```\n\n---\n\n### readFile(fileName)\n\nReads file contents as a `Buffer`.\n\n---\n\n### deleteFile(fileName)\n\nDeletes a file from the disk.\n\n---\n\n### listFiles(folder = '', recursive = false)\n\nLists file names from a folder.\n\nExample output:\n\n```json\n[\n  \"photo.jpg\",\n  \"nested/file.pdf\"\n]\n```\n\n---\n\n### getPublicUrl(fileName)\n\nGenerates the public URL for a file.\n\nExample:\n\n```ts\nstorage.getPublicUrl(\"photo.jpg\");\n// \"/uploads/photo.jpg\"\n```\n\n---\n\n### serveFileResponse()\n\nReturns a TezX Router instance to serve static files from your storage folder.\n\nExample:\n\n```ts\napp.use(storage.serveFileResponse());\n```\n\nThen files are available at:\n\n```bash\n/uploads/photo.jpg\n```\n\n---\n\n## ğŸŒ Example Use with TezX API Router\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files;\n\n  const buffer = Buffer.from(await file.arrayBuffer());\n  const result = await storage.saveFile(file.name, buffer);\n\n  return ctx.json(result);\n});\n\napp.use(storage.serveFileResponse());\n```\n\n---\n\n## ğŸ”¹ Runtime Support\n\n| Runtime | Supported |\n| ------- | --------- |\n| Node.js | âœ…         |\n| Deno    | âœ…         |\n| Bun     | âœ…         |\n\n---\n\n# LocalFS Usage Docs\n\n## ğŸ”¹ Setup\n\n```ts\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n```\n\n## ğŸ“‚ Saving a File\n\n```ts\nconst buffer = await readFile(\"./logo.png\");\nconst saved = await storage.saveFile(\"logo.png\", buffer);\nconsole.log(saved);\n```\n\n---\n\n## ğŸ”¹ Listing Files\n\n```ts\nawait storage.listFiles(); // Non-recursive\nawait storage.listFiles(\"\", true); // Recursive\n```\n\n---\n\n## ğŸ”¹ Deleting Files\n\n```ts\nawait storage.deleteFile(\"logo.png\");\n```\n\n---\n\n## ğŸ”¹ Reading Files\n\n```ts\nconst content = await storage.readFile(\"logo.png\");\n```\n\n---\n\n## ğŸ”¹ Serving Public Files\n\n```ts\napp.use(storage.serveFileResponse());\n\n// Now accessible at: /uploads/logo.png\n```\n\n---\n\n## ğŸ”¹ Error Example\n\n```bash\nError: File type application/x-sh is not allowed\n```\n\n---\n"
            },
            {
              "originalPath": "TezX session.md",
              "id": 46,
              "name": "TezX session",
              "type": "file",
              "path": "toolkit/helpers/tezx-session",
              "content": "# âš¡ @tezx/session\n\n### Simple, Secure & Type-Safe Session Middleware for **TezX**\n\nBuild scalable applications with pluggable session storage, secure cookies, and developer-friendly TypeScript APIs.\n\n---\n\n## âœ¨ Features\n\n* âœ… **Type-Safe** session data (Generics support)\n* ğŸ” Secure, HTTP-only cookie session IDs\n* âš™ï¸ Customizable session storage (Memory, Redis, etc.)\n* ğŸ”„ Simple Middleware: `useSession()`, `createSession()`, `destroySession()`\n* ğŸŒ CORS-friendly: Supports `credentials: 'include'`\n* ğŸ§© Extensible for microservices & SSR apps\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/session\n```\n\nOR\n\n```bash\npnpm add @tezx/session\n```\n\n---\n\n## âš™ï¸ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { SessionManager } from \"@tezx/session\";\n\nconst app = new TezX();\n\nconst sessionManager = new SessionManager({\n  sessionName: \"tezx.sid\",\n  cookie: { maxAge: 1000 * 60 * 30, httpOnly: true, secure: true, sameSite: \"lax\" },\n});\n\n// Load session before routes\napp.use(sessionManager.useSession());\n\n// Login route â†’ create session\napp.post(\"/login\", async (ctx) => {\n  await sessionManager.createSession({ userId: 99, role: \"admin\" }, ctx);\n  return ctx.json({ success: true });\n});\n\n// Protected route â†’ read session\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ session: ctx.session?.data });\n});\n\n// Logout â†’ destroy session\napp.post(\"/logout\", async (ctx) => {\n  await ctx.session?.destroy();\n  return ctx.json({ loggedOut: true });\n});\n```\n\n---\n\n## ğŸ›¡ï¸ API Documentation\n\n### ğŸ”‘ SessionManager\n\n| Method             | Description                                 |\n| ------------------ | ------------------------------------------- |\n| `createSession()`  | Create and save a session                   |\n| `useSession()`     | Middleware: Load session from cookie        |\n| `destroySession()` | Destroy session from store and clear cookie |\n\n---\n\n### ğŸ“„ `createSession(data, ctx)`\n\n* Creates a session.\n* Automatically sets a session cookie in the response.\n* Saves session data to the configured storage.\n\nExample:\n\n```ts\nawait sessionManager.createSession({ userId: 101 }, ctx);\n```\n\n---\n\n### ğŸ”„ `useSession()`\n\nMiddleware for **loading session** on every request:\n\n* Reads session cookie\n* Loads session data from storage\n* Adds `ctx.session` to your context.\n\nExample:\n\n```ts\napp.use(sessionManager.useSession());\n```\n\n---\n\n### âŒ `destroySession()`\n\nDeletes the session from storage and removes the cookie:\n\n```ts\nawait sessionManager.destroySession(sessionId);\n```\n\n---\n\n## ğŸ”§ Configuration Options\n\n```ts\nconst sessionManager = new SessionManager({\n  sessionName: \"my_session\",\n  cookie: {\n    maxAge: 1000 * 60 * 30, // 30 min\n    secure: true,\n    httpOnly: true,\n    sameSite: \"lax\",\n  },\n  storage: new MemoryStore(), // Or your own adapter\n});\n```\n\n| Option          | Type                    | Description                            |\n| --------------- | ----------------------- | -------------------------------------- |\n| sessionName     | `string`                | Name of the cookie key                 |\n| sessionId       | `(ctx) => string`       | Custom session ID generator (optional) |\n| cookie.maxAge   | `number`                | Expiry in ms                           |\n| cookie.secure   | `boolean`               | Only send cookie on HTTPS              |\n| cookie.httpOnly | `boolean`               | Prevent JS access to cookie            |\n| cookie.sameSite | `\"lax\" \\| \"strict\" \\| \"none\"` | SameSite attribute             |\n| storage         | `SessionStorageAdapter` | Custom storage engine                  |\n\n---\n\n## ğŸ§° Example with Redis Storage\n\n```ts\n\nimport type { SessionStorageAdapter, SessionInstance } from \"@tezx/session\";\nimport type { RedisClientType } from \"redis\";\n\nexport class RedisStore implements SessionStorageAdapter {\n  private redisClient: RedisClientType;\n  private prefix: string;\n\n  /**\n   * Create RedisStore adapter.\n   * @param redisClient - Connected Redis client instance.\n   * @param prefix - Optional key prefix for session keys.\n   */\n  constructor(redisClient: RedisClientType, prefix = \"tezx:session:\") {\n    this.redisClient = redisClient;\n    this.prefix = prefix;\n  }\n\n  private getKey(sessionId: string) {\n    return `${this.prefix}${sessionId}`;\n  }\n\n  async get(sessionId: string): Promise<SessionInstance | undefined> {\n    const key = this.getKey(sessionId);\n    const data = await this.redisClient.get(key);\n    if (!data) return undefined;\n\n    try {\n      const parsed = JSON.parse(data);\n      const redisStore = this;\n      return {\n        sessionId: parsed.sessionId,\n        data: parsed.data,\n        async save() {\n          await redisStore.set(this.sessionId, this);\n        },\n        async destroy() {\n          await redisStore.destroy(this.sessionId);\n        },\n      } as SessionInstance;\n    } catch {\n      return undefined;\n    }\n  }\n\n  async set(sessionId: string, data: SessionInstance, maxAge?: number): Promise<void> {\n    const key = this.getKey(sessionId);\n    const value = JSON.stringify({ sessionId, data: data.data });\n    if (maxAge) {\n      // maxAge in ms, Redis EXPIRE in seconds\n      await this.redisClient.set(key, value, {\n        PX: maxAge,\n      });\n    } else {\n      await this.redisClient.set(key, value);\n    }\n  }\n\n  async destroy(sessionId: string): Promise<void> {\n    const key = this.getKey(sessionId);\n    await this.redisClient.del(key);\n  }\n}\n\nconst redisStore = new RedisStore(redisClient);\n\nconst sessionManager = new SessionManager({\n  storage: redisStore,\n  cookie: { maxAge: 1000 * 60 * 60 }, // 1 hour\n});\n```\n\n---\n\n## âš ï¸ CORS & Cookie Notes\n\nFor frontend requests (if CORS enabled):\n\n* Set credentials in the fetch request:\n\n```js\nfetch(\"/profile\", { credentials: \"include\" });\n```\n\n* Server-side: Configure CORS to allow credentials and the origin.\n\n---\n\n## ğŸ”¨ Type Safety\n\n```ts\nconst sessionManager = new SessionManager<{ userId: number, role: string }>();\n\nawait sessionManager.createSession({ userId: 1, role: \"admin\" }, ctx);\n```\n\nNow your `ctx.session.data` will always have `userId` and `role`.\n\n---\n\n## ğŸ”® Advanced Topics\n\n* Redis, MongoDB, File storage adapters\n* Regenerate session IDs on login/logout\n* Auto session expiry + cleanup\n* Session encryption for sensitive data\n* Shared session across subdomains\n\n---\n\n## âœ… License\n\nMIT Â© TezX\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Utilities",
          "name": "Utilities",
          "path": "toolkit/3-utilities",
          "type": "folder",
          "children": [
            {
              "originalPath": "TezX rbac.md",
              "id": 47,
              "name": "TezX rbac",
              "type": "file",
              "path": "toolkit/utilities/tezx-rbac",
              "content": "# ğŸ” @tezx/rbac\n\nA powerful, fully type-safe **Role-Based Access Control (RBAC)** plugin for [TezX](https://www.npmjs.com/package/tezx), designed to help you **control access to routes, APIs, and resources** using simple, template-based permission keys with full IntelliSense support.\n\n---\n\n## ğŸš€ Highlights\n\n- ğŸ¯ Type-safe permission system (`T extends string[]`)\n- ğŸ§  IntelliSense-based permission enforcement\n- ğŸ” Multi-role support (`ctx.user.role` can be `string | string[]`)\n- âš™ï¸ Middleware-driven, plug-and-play\n- âŒ Built-in denial handling + custom `onDeny()` support\n- ğŸ§© Easy integration with auth middlewares (like `authChecker`)\n- ğŸ§ª Battle-tested in production apps\n- ğŸ”‘ Use role IDs(Dynamically generated, flexible)\n- ğŸ” Clean merge of all permissions (No manual logic needed)\n- ğŸ·ï¸ Static roles still supported (Easy for default usage)\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/rbac\n````\n\n---\n\n## ğŸ§  How It Works\n\n```bash\n[Your Middleware]\n    â¬‡ï¸ sets ctx.user.role\n[RBAC Plugin]\n    â¬‡ï¸ loads permission map\n[Route Guard]\n    â¬‡ï¸ checks permission key\n[âœ“ ALLOW] or [âŒ DENY]\n```\n\n---\n\n## âš ï¸ Required: `ctx.user.role`\n\nTo work correctly, you **must set** `ctx.user.role` before using RBAC.\n\nâœ… Example:\n\n```ts\nctx.user = {\n  id: 'user_001',\n  role: 'admin',  // âœ… Required\n  email: 'rakib@example.com'\n};\n```\n\nâœ… If roles can be multiple:\n\n```ts\nctx.user = {\n  role: ['editor', 'viewer']\n};\n```\n\n> ğŸ’¡ Use `authChecker()` middleware to assign `ctx.user` from token/session.\n\n---\n\n## ğŸ§‘â€ğŸ’» Usage Example\n\n```ts\n\nimport RBAC from '@tezx/rbac';\ntype Permissions = ['user:create', 'user:delete', 'order:read', 'property:approve'];\n\nconst rbac = new RBAC<Permissions>();\n\napp.use(authChecker()); // âœ… Assigns ctx.user + ctx.user.role\n\napp.use(rbac.plugin({\n  loadPermissions: async () => ({\n    admin: ['user:create', 'user:delete', 'order:read', 'property:approve'],\n    editor: ['order:read'],\n    guest: []\n  })\n}));\n\napp.get('/admin/users', rbac.authorize('user:create'), async (ctx) => {\n  return ctx.text('You can create users.');\n});\n\n```\n\n---\n\n## ğŸ“Œ RBAC Lifecycle\n\n| Step | Action                                                            |\n| ---- | ----------------------------------------------------------------- |\n| 1ï¸âƒ£  | `ctx.user.role` assigned by auth middleware                       |\n| 2ï¸âƒ£  | `rbac.plugin()` loads Roleâ†’Permission map                         |\n| 3ï¸âƒ£  | `rbac.authorize('permission:key')` checks merged role permissions |\n| 4ï¸âƒ£  | If not allowed â†’ return `403` (with `onDeny` if provided)         |\n\n---\n\n### ğŸ” Replace `role` with Unique Role IDs (Advanced)\n\nRBAC system supports mapping **dynamic role identifiers** (like database IDs or UUIDs) instead of hardcoded role names.\n\nThis is helpful when:\n\n- âœ… Roles are created dynamically from a dashboard or DB\n- âœ… You want to map user roles like `\"role_8FaHq1\"` instead of just `\"admin\"`\n- âœ… Permission sets are assigned to these dynamic IDs\n\n#### ğŸ§ª Example\n\n```ts\nctx.user = {\n  id: 'user_xyz',\n  role: 'role_8FaHq1' // âœ… Your actual role ID from database\n};\n```\n\n```ts\n// Load role-permission map based on DB role IDs\nloadPermissions: async () => ({\n  role_8FaHq1: ['user:create', 'order:read'],\n  role_7NbQt55: ['user:delete']\n})\n```\n\n> âœ… Internally, `RBAC` merges all permissions based on the provided `ctx.user.role`, whether it's `string` or `string[]`.\n\n#### âš ï¸ Important\n\nMake sure the role ID you assign in `ctx.user.role` **exactly matches** the keys in your permission map.\n\n---\n\n### Bonus: Hybrid Role Support\n\nYou can even mix static roles with dynamic IDs if needed:\n\n```ts\nctx.user = {\n  role: ['admin', 'role_7bXy91']\n};\n\nloadPermissions: async () => ({\n  admin: ['dashboard:access'],\n  role_7bXy91: ['product:create']\n});\n```\n\n---\n\n## ğŸ§© Plugin API\n\n### `rbac.plugin(config)`\n\nInitializes the permission map.\n\n**Config options:**\n\n| Field             | Type                         | Required | Description           |\n| ----------------- | ---------------------------- | -------- | --------------------- |\n| `loadPermissions` | `(ctx) => RolePermissionMap` | âœ…        | Role â†’ permission map |\n| `isAuthorized`    | `(roles, permissions, ctx)`  | âŒ        | Custom check hook     |\n| `onDeny`          | `(error, ctx)`               | âŒ        | Custom deny response  |\n\n---\n\n### `rbac.authorize('permission:key')`\n\nMiddleware to protect routes.\n\n```ts\napp.post('/orders', rbac.authorize('order:read'), handler);\n```\n\n---\n\n## ğŸ’¡ IntelliSense with Template Types\n\n```ts\ntype Permissions = ['user:create', 'order:read', 'admin:panel'];\n\nconst rbac = new RBAC<Permissions>();\n```\n\nâœ… Now `rbac.authorize(...)` will auto-suggest only those permission keys.\n\n---\n\n## âŒ Custom Deny Example\n\n```ts\nrbac.plugin({\n  loadPermissions: ...,\n  onDeny: (error, ctx) => {\n    return ctx.json({\n      success: false,\n      reason: error.message,\n      permission: error.permission\n    });\n  }\n});\n```\n\n---\n\n## ğŸ” Real-World Structure\n\n```ts\nconst permissionMap = {\n  admin: ['user:create', 'user:delete'],\n  editor: ['order:read'],\n  viewer: [],\n};\n```\n\nUser may have:\n\n```ts\nctx.user = {\n  id: 'u-001',\n  role: ['editor', 'viewer']\n};\n```\n\nRBAC will combine permissions from both roles.\n\n---\n\n## ğŸ”¥ Debug Tip\n\nTo check permissions being applied at runtime:\n\n```ts\nconsole.log(ctx.user.permissions); // all merged permissions\n```\n\n---\n\n## ğŸ“š Types Summary\n\n```ts\ntype RolePermissionMap<T extends string[]> = Record<string, T[number][]>;\ntype DenyError<T extends string[]> = {\n  error: string;\n  message: string;\n  permission: T[number];\n};\n```\n\n---\n\n## ğŸ“¦ Exported API\n\n```ts\nimport RBAC, { plugin, authorize } from '@tezx/rbac';\n```\n\n---\n\n## ğŸ§ª Test Route Example\n\n```ts\napp.get('/secure', rbac.authorize('admin:panel'), async (ctx) => {\n  ctx.body = { status: 'Access granted.' };\n});\n```\n\n---\n\n## âœ… Best Practices\n\n- ğŸ”„ Always assign `ctx.user.role` in `authChecker`\n- ğŸ§  Define permissions centrally as union literal type\n- ğŸ” Protect all critical routes using `rbac.authorize()`\n- ğŸ§ª Add logging inside `onDeny` for better traceability\n\n---\n"
            },
            {
              "originalPath": "View Engine.md",
              "id": 48,
              "name": "View Engine",
              "type": "file",
              "path": "toolkit/utilities/view-engine",
              "content": "# @tezx/view-engine\n\nA flexible, powerful, and runtime-aware view engine utility for server-side rendering (SSR) with support for **Node.js**, **Bun**, and **Deno**.\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/view-engine.svg)\n\n> ğŸ”§ Supports `ejs`, `pug`, `handlebars`, `nunjucks`, and `mustache` templates out of the box.\n\n---\n\n## âœ¨ Features\n\n- âœ… Supports multiple template engines\n- ğŸ§  Built-in caching for improved performance\n- ğŸª„ Optional file extension overrides\n- ğŸŒ Cross-runtime support: Node.js, Bun, Deno\n- ğŸ“¦ Lightweight and framework-agnostic\n- ğŸ” Ideal for SSR in Tezx or any TS/JS backend\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/view-engine\n# or\nbun add @tezx/view-engine\n````\n\n### **Template**\n\n```bash\nnpm create tezx view-engine -- --template view-engine --y\n```\n\n### **Require**\n\n```bash\n# EJS\nnpm install ejs\n\n# Pug (formerly Jade)\nnpm install pug\n\n# Handlebars\nnpm install handlebars\n\n# Nunjucks (Jinja2-like templating)\nnpm install nunjucks\n\n# Mustache\nnpm install mustache\n\n```\n\n---\n\n## ğŸš€ Usage\n\n```ts\nimport { ViewEngine } from \"@tezx/view-engine\";\n\nconst views = new ViewEngine(\"ejs\", \"./views\");\n\nconst html = await views.render(\"home\", {\n  title: \"Welcome!\",\n  user: { name: \"Rakibul\" },\n});\n\n// In your Tezx handler:\nctx.html(html);\n```\n\n---\n\n## ğŸ”§ Constructor\n\n```ts\nnew ViewEngine(engine: TemplateEngine, viewsPath: string, options?: ViewEngineOptions)\n```\n\n### Parameters\n\n| Name        | Type                   | Description                        |\n| ----------- | ---------------------- | ---------------------------------- |\n| `engine`    | `\"ejs\"`, `\"pug\"`, etc. | Template engine to use             |\n| `viewsPath` | `string`               | Path to the views/templates folder |\n| `options`   | `ViewEngineOptions`    | (Optional) Configuration options   |\n\n---\n\n## âš™ï¸ Options\n\n```ts\ninterface ViewEngineOptions {\n  cache?: boolean; // default: true\n  autoescape?: boolean; // default: true (nunjucks only)\n  extensionOverride?: Partial<Record<TemplateEngine, string>>;\n}\n```\n\n### Example\n\n```ts\nconst views = new ViewEngine(\"ejs\", \"./views\", {\n  cache: true,\n  extensionOverride: {\n    ejs: \".html.ejs\"\n  }\n});\n```\n\n---\n\n## ğŸ“š Supported Engines\n\n| Engine       | Extension   | Notes                       |\n| ------------ | ----------- | --------------------------- |\n| `ejs`        | `.ejs`      | Supports includes/partials  |\n| `pug`        | `.pug`      | Indentation-based templates |\n| `handlebars` | `.hbs`      | Logic-less templates        |\n| `nunjucks`   | `.njk`      | Powerful and Django-like    |\n| `mustache`   | `.mustache` | Minimal and logic-less      |\n\n---\n\n## ğŸ§  Runtime Compatibility\n\n| Runtime | Supported  | Notes                     |\n| ------- | ---------- | ------------------------- |\n| Node.js | âœ…          | Recommended               |\n| Bun     | âœ…          | Fully supported           |\n| Deno     | âœ…          | Fully supported           |\n\n---\n\n## ğŸ“‚ Example View Structure\n\n```bash\nviews/\nâ”œâ”€â”€ home.ejs\nâ”œâ”€â”€ layout.pug\nâ”œâ”€â”€ about.hbs\nâ”œâ”€â”€ user/\nâ”‚   â””â”€â”€ profile.mustache\n```\n\n---\n\n## âœ… Also include in your `docs/` folder\n\nYou can save this as:\n\n```bash\n/docs/view-engine.md\n````\n\nor\n\n```bash\nREADME.md â†’ root of helpers/view-engine/\n```\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "99. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Uploader.md",
          "id": 49,
          "name": "Uploader",
          "type": "file",
          "path": "examples/uploader",
          "content": "\n# ğŸ“¤ File Upload Middleware\n\n## Overview\n\nTezX provides first-class support for file uploads via its `useFormData` utility, allowing you to handle file uploads with minimal setup. This example demonstrates how to accept, read, and save a file using native `fs/promises` and `path`.\n\n## Features\n\n* Parses incoming multipart/form-data requests.\n* Supports extracting and saving uploaded files.\n* Handles errors with clear responses.\n* Compatible with modern runtimes like Bun, Node.js, and Deno.\n\n---\n\n## Example Usage\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\nimport { useFormData } from \"tezx/helper\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await useFormData(ctx);\n  const file = formData?.files as File; // Get uploaded file\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Destination path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save to disk\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n\n---\n\n## ğŸ” Notes\n\n* Make sure the `uploads` directory exists or create it before saving.\n* `formData.files` can also be an array if multiple files are submitted.\n* To support multiple files, iterate over `formData.files`:\n\n```ts\nconst files = formData?.files as File[];\nfor (const file of files) {\n  const buffer = await file.arrayBuffer();\n  await writeFile(join(process.cwd(), \"uploads\", file.name), Buffer.from(buffer));\n}\n```\n\n---\n\n## ğŸ§ª Testing with cURL\n\n```bash\ncurl -F \"file=@/path/to/file.png\" http://localhost:3000/data\n```\n\n---\n"
        },
        {
          "originalPath": "4. Basic Auth Client.md",
          "id": 50,
          "name": "Basic Auth Client",
          "type": "file",
          "path": "examples/basic-auth-client",
          "content": "# ğŸ” Accessing Protected Routes with Basic Authentication\n\nThis guide demonstrates how to access routes secured with HTTP Basic Authentication using various tools and libraries.\n\n---\n\n### **1. Using cURL**\n\n**Option 1: With `-u` flag (recommended)**\n\n```bash\ncurl -u username:password http://localhost:3000/protected\n```\n\n**Option 2: Manually set the `Authorization` header**\n\n```bash\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" http://localhost:3000/protected\n```\n\nâœ… `-u` automatically encodes credentials using Base64.\n\n---\n\n### **2. Using Postman**\n\n1. Open a new request in Postman.\n2. Navigate to the **Authorization** tab.\n3. Choose **Basic Auth** as the type.\n4. Enter your `username` and `password`.\n5. Click **Send**.\n\nPostman automatically encodes and adds the `Authorization` header.\n\n---\n\n### **3. Using JavaScript (Fetch API)**\n\n```js\nconst username = \"admin\";\nconst password = \"password123\";\n\nfetch(\"http://localhost:3000/protected\", {\n  method: \"GET\",\n  headers: {\n    Authorization: `Basic ${btoa(`${username}:${password}`)}`,\n  },\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\nğŸ” `btoa()` encodes the credentials in Base64 format.\n\n---\n\n### **4. Using Axios**\n\n```js\nconst axios = require(\"axios\");\n\naxios\n  .get(\"http://localhost:3000/protected\", {\n    auth: {\n      username: \"admin\",\n      password: \"password123\",\n    },\n  })\n  .then((res) => console.log(res.data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\nğŸ’¡ The `auth` option in Axios handles Base64 encoding internally.\n\n---\n"
        },
        {
          "originalPath": "5. SSE implement.md",
          "id": 51,
          "name": "SSE implement",
          "type": "file",
          "path": "examples/sse-implement",
          "content": "\n# ğŸ“¡ `app.sse(path, handler)`\n\nRegisters a **Server-Sent Events (SSE)** route handler for the given path.\nSSE is a simple and efficient way to send real-time updates from the server to the browser over HTTP using a single, long-lived connection.\n\n---\n\n## âœ… Syntax\n\n```ts\napp.sse(path: string, handler: (ctx: Context) => Promise<Response> | Response)\n```\n\n---\n\n## ğŸ§  Description\n\n* Registers an HTTP `GET` route at the given `path`.\n* Sends **real-time updates** to connected clients via a persistent HTTP connection using the `text/event-stream` MIME type.\n* Automatically handles connection cleanup when the client disconnects.\n\n---\n\n## ğŸ“¥ Parameters\n\n| Name      | Type       | Description                                     |\n| --------- | ---------- | ----------------------------------------------- |\n| `path`    | `string`   | The route path (e.g. `/events`)                 |\n| `handler` | `Function` | An async or sync function that returns a stream |\n\n---\n\n## ğŸ“¤ Returns\n\n* The route is registered to send `ReadableStream` data in SSE-compliant format (`data: ...\\n\\n`).\n* The handler must return a response with appropriate headers.\n\n---\n\n## ğŸ“¦ Headers set (automatically or manually)\n\n```http\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\nYou can override or customize headers inside `ctx.send(stream, { headers })`.\n\n---\n\n## ğŸ“‹ Example\n\n```ts\nfunction encoder(str: string) {\n  return new TextEncoder().encode(str);\n}\n\napp.sse(\"/events\", (ctx) => {\n  const stream = new ReadableStream({\n    start(controller) {\n      // Initial event\n      controller.enqueue(encoder(\"data: Connected\\n\\n\"));\n\n      // Periodic event\n      const interval = setInterval(() => {\n        const message = `data: ${new Date().toISOString()}\\n\\n`;\n        controller.enqueue(encoder(message));\n      }, 2000);\n\n      // Cleanup on client disconnect\n      ctx.rawRequest?.signal?.addEventListener(\"abort\", () => {\n        clearInterval(interval);\n        controller.close()\n      });\n    },\n  });\n\n  return ctx.send(stream, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n  });\n});\n```\n\n---\n\n## ğŸ§ª Test Client (HTML)\n\n```ts\napp.get(\"/\", async (ctx) => {\n  return ctx.html`\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>SSE Demo</title>\n  </head>\n  <body>\n    <h1>Server-Sent Events</h1>\n    <pre id=\"output\"></pre>\n    <script>\n      const output = document.getElementById(\"output\");\n      const eventSource = new EventSource(\"/events\");\n\n      eventSource.onmessage = (event) => {\n        output.textContent += event.data + \"\\\\n\";\n      };\n\n      eventSource.onerror = () => {\n        output.textContent += \"ğŸ”´ Connection lost\\\\n\";\n      };\n    </script>\n  </body>\n</html>\n  `;\n});\n```\n\n---\n\n## ğŸš¨ Notes\n\n* Only supports `GET` method (per SSE spec).\n* Requires `ReadableStream` and `TextEncoder`, which are supported in Node.js 18+, Bun, and modern runtimes.\n* Don't forget to clear intervals/timers on disconnect via `ctx.rawRequest?.signal`.\n\n---\n\n## âœ… Ideal Use Cases\n\n* Live notifications\n* Real-time clock or status updates\n* Live logs / debugging streams\n* Chat message delivery (broadcast style)\n\n---\n\n## ğŸ§© Coming Soon Ideas (optional for docs)\n\n> You can optionally add features like:\n\n* `ctx.pushSSE(data)` helper\n* Broadcasting across multiple connections\n* Named event support (`event: custom\\n`)\n\n---\n\n## ğŸ“˜ Summary\n\n`app.sse()` is the easiest way to build **real-time push updates** over HTTP with zero frontend dependencies.\n\n---\n"
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "benchmarking",
      "name": "Benchmarking",
      "folder": ".",
      "content": "# ğŸš€ Benchmarking Performance: TezX Across Runtimes\n\nTezX is built for speed and efficiency, supporting multiple JavaScript runtimes. This section highlights real-world HTTP server benchmarks comparing TezX performance on **Bun**, **Deno**, and **Node.js** using `wrk`, a popular HTTP benchmarking tool.\n\n---\n\n## âš™ï¸ Test Setup\n\n* **Benchmark Tool:** [wrk](https://github.com/wg/wrk) (v4.1+)\n* **Test Duration:** 10 seconds\n* **Threads:** 12\n* **Concurrent Connections:** 400\n* **Endpoint:** `/` (simple text response)\n* **Ports:** Bun & Deno on `3001`, Node.js on `3000`\n\n---\n\n## ğŸ“Š Benchmark Summary\n\n| Runtime     | Requests/sec     | Avg Latency | Transfer Rate |\n| ----------- | ---------------- | ----------- | ------------- |\n| **Bun**     | **69,367 req/s** | 5.66 ms     | 9.59 MB/s     |\n| **Deno**    | 58,061 req/s     | 6.76 ms     | 9.30 MB/s     |\n| **Node.js** | 13,859 req/s     | 28.63 ms    | 2.17 MB/s     |\n\n---\n\n## ğŸ” Detailed Output\n\n### ğŸŸ¢ Bun\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 5.66 ms | Stdev: 663.46 Âµs | Max: 12.62 ms\nRequests/sec Avg: 5.86k | Max peak: 35.51k\nTotal Requests: 700,594 | Transfer: 96.88 MB\n```\n\n### ğŸŸ¡ Deno\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 6.76 ms | Stdev: 791.19 Âµs | Max: 13.53 ms\nRequests/sec Avg: 4.91k | Max peak: 62.61k\nTotal Requests: 586,419 | Transfer: 93.95 MB\n```\n\n### ğŸ”´ Node.js\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3000\n\nLatency     Avg: 28.63 ms | Stdev: 5.89 ms | Max: 120 ms\nRequests/sec Avg: 1.16k | Max peak: 1.38k\nTotal Requests: 138,852 | Transfer: 21.72 MB\n```\n\n---\n\n## ğŸ’¡ Insights\n\n* **Bun** demonstrates exceptional throughput and low latency, benefiting from its highly optimized JavaScript runtime and native HTTP server.\n* **Deno** performs admirably, striking a balance between speed and robustness with modern runtime features.\n* **Node.js** remains a solid choice but shows higher latency and lower request capacity under heavy concurrency.\n\n---\n\n## ğŸ“ˆ Why Does This Matter?\n\n* **High Throughput:** Enables TezX to handle thousands of requests per second, ideal for real-time apps and APIs.\n* **Low Latency:** Improves user experience by reducing response delays.\n* **Runtime Flexibility:** TezX runs efficiently on multiple platforms â€” choose the runtime that best fits your deployment needs.\n\n---\n\n## ğŸ”— Further Reading\n\n* [Bun Official Website](https://bun.sh)\n* [Deno Official Website](https://deno.land)\n* [Node.js Official Website](https://nodejs.org)\n* [wrk Benchmark Tool](https://github.com/wg/wrk)\n"
    },
    {
      "id": 2,
      "path": "getting-started/create-app",
      "name": "Create app",
      "folder": "Getting Started",
      "content": "# âš¡ Create TezX\n\nEasily scaffold a new [TezX](https://github.com/tezxjs/tezx) project using official starter templates. Whether you're building a backend with WebSocket support or a TypeScript-powered server, `create-tezx` gets you started fast.\n\n---\n\n## ğŸš€ Quick Start\n\nStarter templates are available for common runtimes and package managers. Run one of the following commands:\n\n```bash\n# npm\nnpm create tezx@latest\nnpx create-tezx-app@latest\n# yarn\nyarn create tezx\n\n# pnpm\npnpm create tezx@latest\n\n# bun\nbun create tezx@latest\n\n# deno\ndeno run -A npm:create-tezx@latest\n````\n\nThis will launch an interactive setup. You can also skip prompts using CLI flags.\n\n---\n\n## âš™ï¸ CLI Options\n\nYou can skip interactive prompts by passing options directly via the command line.\n\n### `-t`, `--template <template>`\n\nUse a specific template by name.\n\n```bash\nnpm create tezx@latest my-app -- --template minimal\n```\n\n---\n\n### `-i`, `--install`\n\nAutomatically install dependencies after project setup.\n\n```bash\nnpm create tezx@latest my-app -- --install\n```\n\n---\n\n### `-p`, `--pm <npm|pnpm|bun|yarn>`\n\nChoose a package manager.\n\n```bash\nnpm create tezx@latest my-app -- --pm bun\n```\n\n---\n\n### `--ts`, `-ts`\n\nEnable TypeScript in the scaffolded project.\n\n```bash\nnpm create tezx@latest my-app -- --ts\n```\n\n---\n\n### `--env`, `--runtime`, `-env`, `-runtime`\n\nSet the runtime environment: `node`, `bun`, or `deno`.\n\n```bash\nnpm create tezx@latest my-app -- --runtime bun\n```\n\n---\n\n### `--y`, `--yes`, `-y`, `-yes`\n\nSkip all prompts using sensible defaults.\n\n```bash\nnpm create tezx@latest my-app -- --yes\n```\n\n---\n\n## ğŸ“ Supported Templates\n\n> âœ… More templates coming soon!\n\n| Template        | Description                     | Flag Example               |\n| --------------- | ------------------------------- | -------------------------- |\n| `minimal`       | Minimal TypeScript setup        | `--template minimal`       |\n| `ws`            | WebSocket support (Node or Bun) | `--template ws`            |\n| `google-oauth2` | Google OAuth2 integration       | `--template google-oauth2` |\n| `github-oauth2` | GitHub OAuth2 integration       | `--template github-oauth2` |\n\n---\n\n## ğŸ§ª Example Usage\n\n```bash\nnpm create tezx@latest my-app -- --template ws --ts --runtime node --install\n```\n\n```bash\nbun create tezx@latest auth-app -- --template google-oauth2 --pm bun --yes\n```\n\n---\n\n## ğŸ§‘â€ğŸ’» Author\n\nBuilt by [Rakibul Islam](https://github.com/srakib17)\nand [TezX](https://github.com/tezxjs/tezx) contributors.\n\n---\n"
    },
    {
      "id": 3,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "# âš¡ TezX â€” High-Performance Backend Framework\n\n**TezX** is a modern, ultra-fast, and lightweight JavaScript framework built for **Node.js, Bun, and Deno**. It offers blazing speed, clean APIs, and built-in tools for routing, middleware, and static file handling â€” perfect for scalable backend applications.\n\n---\n\n## âœ¨ Features\n\n* ğŸš€ **High Performance** â€“ Built for speed and concurrency\n* âš™ï¸ **Simple API** â€“ Clean and minimalistic\n* ğŸ›¡ï¸ **Security First** â€“ Follows best practices\n* ğŸ§© **Middleware System** â€“ Modular and powerful\n* ğŸ—‚ï¸ **Static File Serving** â€“ Just plug and go\n* ğŸŒ **Universal Runtime** â€“ Works on **Node**, **Bun**, and **Deno**\n\n---\n\n## ğŸ“¦ Quick Start\n\n### 1. Setup Project\n\n```bash\nmkdir my-tezx-app && cd my-tezx-app\nnpm init -y              # or bun init\nnpm install tezx         # or bun add tezx\n```\n\n### 2. Project Structure\n\n```\n.\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ index.ts      # App entry point\nâ”œâ”€â”€ public/           # Static files\nâ”œâ”€â”€ .env              # Environment variables\nâ””â”€â”€ tsconfig.json     # TypeScript config\n```\n\n### 3. Create `.env`\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key\n```\n\n---\n\n## ğŸ–¥ï¸ Basic Server (Node.js)\n\n```ts\n// src/index.ts\nimport { TezX } from \"tezx\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { logger } from \"tezx/logger\";\nimport { createServer } from \"http\";\n\nconst env = loadEnv();\nconst app = new TezX({ env });\n\napp.use(logger());\napp.get(\"/\", (ctx) => ctx.text(\"Hello TezX!\"));\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(env.PORT || 3000, () => {\n  console.log(`ğŸš€ Running at http://localhost:${env.PORT || 3000}`);\n});\n```\n\n---\n\n## âš™ Runtime-Specific Setup\n\n### â–¶ï¸ Bun\n\n```ts\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: {\n    open(ws) { (ws.data as any)?.open?.(ws); },\n    message(ws, msg) { (ws.data as any)?.message?.(ws, msg); },\n    close(ws, code, reason) { (ws.data as any)?.close?.(ws, { code, reason }); },\n    ping(ws, data) { (ws.data as any)?.ping?.(ws, data); },\n    pong(ws, data) { (ws.data as any)?.pong?.(ws, data); },\n    drain(ws) { (ws.data as any)?.drain?.(ws); },\n  },\n});\n```\n\n### â–¶ï¸ Deno\n\n```ts\nDeno.serve({ port: 3001 }, (req, connInfo) => app.serve(req, connInfo));\n```\n\n---\n\n## ğŸ› ï¸ Dev Scripts\n\n### Node (`package.json`)\n\n```json\n\"scripts\": {\n  \"dev\": \"tsx watch src/index.ts\",\n  \"build\": \"tsc\",\n  \"start\": \"node dist/index.js\"\n}\n```\n\n### Bun\n\n```json\n\"scripts\": {\n  \"dev\": \"bun run --hot src/index.ts\"\n}\n```\n\n### Deno\n\n```json\n\"scripts\": {\n  \"dev\": \"deno run --watch --allow-all src/index.ts\"\n}\n```\n\n---\n\n## ğŸ”§ Common Middleware & Features\n\n### Static Files\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: { \"X-Custom-Header\": \"static\" }\n});\n```\n\n### CORS\n\n```ts\nimport { cors } from \"tezx/cors\";\napp.use(cors({ origin: [\"http://localhost:3000\"], methods: [\"GET\", \"POST\"] }));\n```\n\n### Logger\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## ğŸ“¦ TypeScript Build\n\n```bash\ntsc\n```\n\n### Sample `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n---\n\n## ğŸ› ï¸ Troubleshooting\n\n| Issue                       | Fix                              |\n| --------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'` | Run `npm install` or `bun add`   |\n| `Port already in use`       | Change `PORT` in `.env`          |\n| `TypeScript errors`         | Check `tsconfig.json`            |\n| `.env not loading`          | Verify file location/permissions |\n\n---\n\n## ğŸ§  Tip\n\nWant to create a high-concurrency server with minimal memory footprint? **TezX** + **Bun** is an ideal combo for real-time apps and serverless workloads.\n\n---\n"
    },
    {
      "id": 4,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "# ğŸš€ TezX Configuration Guide\n\nThe `TezX` framework is highly configurable, enabling you to tailor routing, environment variables, middleware, and path handling. This guide details all configuration options available via the `TezX` constructor â€” including how to plug in your own custom router (`routeRegistry`).\n\n---\n\n## ğŸ“Œ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/bun\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  debugMode: true,\n  env,\n  basePath: \"/api\",\n});\n```\n\n---\n\n## ğŸ§  Understanding `TezXConfig`\n\nThe `TezXConfig` type defines the options you can pass to the framework, including routing options inherited from `RouterConfig`:\n\n```ts\nexport type TezXConfig = {\n  debugMode?: boolean;\n  onPathResolve?: (pathname: string) => string;\n  routeRegistry?: RouteRegistry;  // <--- Add your custom router here\n} & RouterConfig;\n\nexport type RouterConfig = {\n  env?: Record<string, string | number>;\n  basePath?: string;\n};\n```\n\n---\n\n## âš™ï¸ Configuration Options\n\n### 1. `debugMode`\n\n* **Type**: `boolean`\n* **Default**: `false`\n* **Description**: Enables verbose logging for development and debugging.\n\n```ts\nconst app = new TezX({ debugMode: true });\n```\n\n---\n\n### 2. `env`\n\n* **Type**: `Record<string, string | number>`\n* **Description**: Supplies environment variables to your app.\n\n```ts\nconst env = { PORT: \"3001\", API_KEY: \"secret\" };\nconst app = new TezX({ env });\nconsole.log(app.config.env.PORT); // \"3001\"\n```\n\n---\n\n### 3. `basePath`\n\n* **Type**: `string`\n* **Description**: Adds a global prefix to all routes (useful for API versioning or grouping).\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\napp.get(\"/users\", (ctx) => ctx.text(\"v1 Users\"));\n// Available at /v1/users\n```\n\n---\n\n### 4. `onPathResolve`\n\n* **Type**: `(pathname: string) => string`\n* **Description**: Custom hook to rewrite or normalize incoming request paths before routing.\n\n```ts\nconst app = new TezX({\n  onPathResolve: (path) => path.toLowerCase().replace(/\\/+$/, \"\"),\n});\n```\n\n---\n\n### 5. `routeRegistry` (Custom Router)\n\n* **Type**: `RouteRegistry`\n* **Description**: Inject your own custom router implementation to fully control route resolution and middleware layering.\n\n---\n\n## ğŸ§© How to Add a Custom `routeRegistry`\n\nYou can supply any router implementing the `RouteRegistry` interface as the `routeRegistry` property in your `TezX` config. This enables complete customization of routing behavior.\n\n### Example: Using a Custom Router with TezX\n\n```ts\nimport { TezX } from \"tezx\";\nimport { PowerfulCustomRouter } from \"./PowerfulCustomRouter\";\n\nconst customRouter = new PowerfulCustomRouter();\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: customRouter,\n});\n```\n\n### How it works\n\n* TezX will call `routeRegistry.search(method, path)` internally to resolve routes.\n* You can register routes and middleware **directly on your custom router** using its API.\n* Middleware registered with method `\"ALL\"` runs before method-specific handlers.\n* Supports all HTTP methods and route param extraction.\n\n---\n\n## ğŸ›  Real-World Example with Sub-Routing and Custom Router\n\n```ts\nimport { TezX } from \"tezx\";\nimport { PowerfulCustomRouter } from \"./PowerfulCustomRouter\";\n\nconst router = new PowerfulCustomRouter();\n\nrouter.addRoute(\"GET\", \"/hello\", [\n  async (ctx) => ctx.text(\"Hello from custom router!\"),\n]);\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: router,\n  basePath: \"/api\",\n});\n\napp.use(\"/api\", async (ctx, next) => {\n  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n\n// Start your server here with Bun, Deno, or Node.js\n\n```\n\n---\n\n## ğŸ“¦ Summary of Configuration Options\n\n| Option          | Type                               | Description                                |\n| --------------- | ---------------------------------- | ------------------------------------------ |\n| `debugMode`     | `boolean`                          | Enables verbose request and error logging  |\n| `env`           | `Record<string, string \\| number>` | Provides environment variables             |\n| `basePath`      | `string`                           | Global prefix added to all routes          |\n| `onPathResolve` | `(pathname: string) => string`     | Hook to rewrite or normalize request paths |\n| `routeRegistry` | `RouteRegistry`                    | Your custom router instance                |\n\n---\n\n## âœ… Best Practices\n\n* Use `basePath` for API versioning or grouping routes.\n* Inject a powerful custom router for fine-grained routing and middleware control.\n* Utilize `onPathResolve` for path normalization or localization needs.\n* Pass your environment variables with `env` for consistent config across environments.\n\n---\n"
    },
    {
      "id": 5,
      "path": "environment/node/configure",
      "name": "Configure",
      "folder": "Environment/node",
      "content": "\n# ğŸ”§ TezX with Node.js â€“ Full Integration Guide (`mountTezXOnNode`)\n\nBuild modern, middleware-driven APIs in Node.js using **TezX**, a lightweight server framework with first-class support for the Fetch API and native HTTP integration.\n\n---\n\n## âœ… Prerequisites\n\n* [Node.js](https://nodejs.org/) v16 or higher\n* TezX installed via `npm`, `yarn`, or `pnpm`\n\n```bash\n# Choose your preferred package manager\nnpm install tezx\n# or\nyarn add tezx\n# or\npnpm add tezx\n```\n\n---\n\n## ğŸ—‚ï¸ Recommended Project Structure\n\n```bash\nproject/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ app.ts          # TezX app instance\nâ”œâ”€â”€ server.ts           # Native Node.js HTTP server\nâ”œâ”€â”€ .env                # Environment config\n```\n\n---\n\n## ğŸš€ Setting Up the Server (`server.ts`)\n\n```ts\nimport { createServer } from \"http\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { app } from \"./src/app\";\n\n// Load environment variables from `.env` into process.env\nloadEnv();\n\n// Create a native HTTP server\nconst server = createServer();\n\n// Mount TezX to handle requests\nmountTezXOnNode(app, server);\n\n// Start listening on the defined port\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(`ğŸš€ TezX is running at http://localhost:${PORT}`);\n});\n```\n\n---\n\n## ğŸ“„ Example `.env`\n\n```env\nPORT=3000\n```\n\n> Loaded via `loadEnv()` and available as `process.env.PORT`\n\n---\n\n## ğŸ§ª Running the Server\n\n```bash\nnode server.ts\n# or with live-reloading (recommended for dev)\nnpx nodemon server.ts\n```\n\n---\n\n## ğŸ§  What Does `mountTezXOnNode` Do?\n\n`mountTezXOnNode(app, server)` enables TezX to work natively with Node.js by:\n\n* ğŸ” **Transforming** Nodeâ€™s `IncomingMessage` into a Fetch-compatible `Request`\n* ğŸ“¤ **Passing** the request to your TezX app via `app.serve()`\n* ğŸ“¥ **Converting** the Fetch `Response` back into a native HTTP response\n* ğŸš° **Supporting** streaming (files, JSON, Server-Sent Events)\n* ğŸ›¡ï¸ **Handling** edge cases like errors and connection aborts cleanly\n\n---\n\n## ğŸ“š Feature Breakdown\n\n| Feature                        | Description                                                          |\n| ------------------------------ | -------------------------------------------------------------------- |\n| `createServer()`               | Standard Node.js HTTP server                                         |\n| `mountTezXOnNode(app, server)` | Binds your TezX app to the server                                    |\n| Request conversion             | `IncomingMessage` â†’ Fetch `Request`                                  |\n| Response conversion            | Fetch `Response` â†’ `ServerResponse` (with stream support)            |\n| Streaming & SSE support        | Handles large or continuous data (e.g., file download, live updates) |\n| Error handling                 | Graceful 500 responses and logging                                   |\n| `.env` support via `loadEnv()` | Automatically loads environment variables                            |\n| Compatibility                  | Works with HTTP/1.x and HTTP/2 servers in Node.js                    |\n\n---\n\n## âœ… Benefits\n\n* ğŸ”§ Native Node.js support without needing adapters\n* âœ¨ Clean Fetch API interface (like Deno or Bun)\n* ğŸ§± Minimal boilerplate, ideal for microservices or APIs\n* ğŸŒŠ Streaming-ready (e.g., `ctx.stream()`, SSE, large files)\n* ğŸ§© Works with existing Node.js tooling (e.g., Nodemon, PM2, ts-node)\n\n---\n\n## ğŸ” Next Steps\n\n* Add routes using `.get()`, `.post()`, `.use()` on your `app` instance\n* Integrate `middleware`, `env`, and `logging` for full control\n* Explore WebSocket support (if using Bun/Deno) or custom WS handlers for Node.js\n\n---\n"
    },
    {
      "id": 6,
      "path": "environment/bun/configure",
      "name": "Configure",
      "folder": "Environment/bun",
      "content": "\n# ğŸ”§ TezX + Bun Integration Guide\n\n## âœ… Prerequisites\n\nBefore you begin, ensure the following tools are installed:\n\n* [Bun](https://bun.sh) â€” A modern all-in-one JavaScript runtime\n* [`tezx`](https://www.npmjs.com/package/tezx) â€” TezX framework for Bun\n\nInstall `tezx` via Bun:\n\n```bash\nbun add tezx\n```\n\n---\n\n## ğŸ“ Project Structure (Example)\n\n```bash\nproject/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ app.ts       # Application logic (TezX app instance)\nâ”œâ”€â”€ server.ts        # Main server entry point\nâ”œâ”€â”€ .env             # Environment variables\n```\n\n---\n\n## ğŸŒ Server Setup (with WebSocket Support)\n\n### `server.ts`\n\n```ts\nimport { loadEnv } from \"tezx/bun\";\nimport { app } from \"./src/app\"; // TezX app instance\n\n// Load environment variables\nloadEnv();\n\nBun.serve({\n  port: 3001,\n  reusePort: true, // Enables clustering support\n  fetch(req, server) {\n    return app.serve(req, server); // TezX handles the request\n  },\n  websocket: {\n    open(ws) {\n      console.log(\"WebSocket connected\");\n      return (ws.data as any)?.open?.(ws);\n    },\n    message(ws, msg) {\n      return (ws.data as any)?.message?.(ws, msg);\n    },\n    close(ws, code, reason) {\n      return (ws.data as any)?.close?.(ws, { code, reason });\n    },\n    ping(ws, data) {\n      return (ws.data as any)?.ping?.(ws, data);\n    },\n    pong(ws, data) {\n      return (ws.data as any)?.pong?.(ws, data);\n    },\n    drain(ws) {\n      return (ws.data as any)?.drain?.(ws);\n    },\n  },\n});\n\nconsole.log(`ğŸš€ Server running at http://localhost:${process.env.PORT}`);\n```\n\n---\n\n## ğŸ“„ `.env` Example\n\n```env\nPORT=3001\n```\n\n---\n\n## ğŸ§ª Running the Server\n\nStart the server using Bun:\n\n```bash\nbun run --watch server.ts\n```\n\nOr simply:\n\n```bash\nbun run server.ts\n```\n\n---\n\n## ğŸ“š Key Concepts\n\n| Feature            | Description                                                                   |\n| ------------------ | ----------------------------------------------------------------------------- |\n| `Bun.serve()`      | Launches the HTTP server (analogous to Node.js' `createServer`)               |\n| `reusePort: true`  | Enables multi-process (cluster) support for improved scalability              |\n| `fetch()` handler  | Main entry point for handling HTTP requests using TezX's `app.serve()`        |\n| `websocket` config | Manages the WebSocket lifecycle events such as `open`, `message`, and `close` |\n| `ws.data` usage    | Custom logic can be attached per WebSocket session through the `data` field   |\n| `loadEnv()`        | Automatically loads environment variables from the `.env` file                |\n\n---\n"
    },
    {
      "id": 7,
      "path": "environment/deno/configure",
      "name": "Configure",
      "folder": "Environment/deno",
      "content": "# ğŸš€ TezX with Deno â€” Developer Guide\n\nBuild modern, high-performance HTTP applications using the TezX framework on Deno.\n\n---\n\n## âœ… Prerequisites\n\n* [Deno](https://deno.land) installed (v1.44+ recommended)\n* Basic knowledge of Denoâ€™s permissions and module system\n* TezX app instance (`app`) created in `src/index.ts`\n\n---\n\n## ğŸ› ï¸ Setup: `server.ts`\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { app } from \"./src/index.ts\";\n\n// Load environment variables from `.env` and `.env.local`\nawait loadEnv();\n\n// Start the HTTP server\nDeno.serve({ port: Number(Deno.env.get(\"PORT\") || 5000) }, (req, connInfo) => {\n  return app.serve(req, connInfo);\n});\n```\n\n---\n\n## ğŸ“ Project Structure\n\n```\nmy-tezx-project/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ index.ts        # Your TezX app instance\nâ”œâ”€â”€ .env                # Environment variables\nâ”œâ”€â”€ server.ts           # Entry point\n```\n\n---\n\n## ğŸ“¦ Environment Variables (`.env`)\n\n```env\nPORT=5000\nAPP_NAME=MyDenoTezXApp\n```\n\nTezX will automatically load:\n\n* `.env`\n* `.env.local` (if exists)\n\nThese are injected into both `Deno.env` and `process.env` (polyfilled where applicable).\n\n---\n\n## ğŸ“Œ Accessing Env Variables\n\n```ts\nconst port = Number(Deno.env.get(\"PORT\") || 5000);\nconst appName = Deno.env.get(\"APP_NAME\");\n```\n\n---\n\n## ğŸ“ Deno Permissions\n\nTo use `.env` and serve HTTP, ensure the following permissions:\n\n```bash\ndeno run --allow-net --allow-env --allow-read server.ts\n```\n\nAlternatively, for full access during development:\n\n```bash\ndeno run --allow-all server.ts\n```\n\n---\n\n## ğŸ” Live Development (with Watch)\n\n```bash\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## ğŸ“¦ Optional: Use with NPM via `npm:` specifier\n\nIf you're integrating with an NPM-style toolchain or writing hybrid code:\n\n```ts\nimport { loadEnv } from \"npm:tezx/deno\";\n```\n\n---\n\n## ğŸ”§ Pro Tip: Create a Run Script\n\nAdd to your `deno.json` for easier use:\n\n```json\n{\n  \"tasks\": {\n    \"dev\": \"deno run --watch --allow-all server.ts\",\n    \"start\": \"deno run --allow-all server.ts\"\n  }\n}\n```\n\nThen run with:\n\n```bash\ndeno task dev\n```\n\n---\n\n## ğŸ“š Additional Docs\n\n* TezX Docs: *coming soon*\n* Deno Docs: [https://deno.land/manual](https://deno.land/manual)\n* Deno Permissions: [https://deno.land/manual@latest/basics/permissions](https://deno.land/manual@latest/basics/permissions)\n\n---\n"
    },
    {
      "id": 8,
      "path": "route-registry/radix-router",
      "name": "Radix Router",
      "folder": "Route Registry",
      "content": "# ğŸ“¦ RadixRouter\n\n`RadixRouter` is a high-performance, memory-efficient HTTP routing system inspired by radix trees. Designed for flexibility and speed, it supports advanced routing patterns and middleware composition, making it ideal for scalable backend frameworks.\n\n---\n\n## ğŸ” Overview\n\n* **Static Routes:** Match exact paths like `/users`\n* **Dynamic Parameters:** Capture URL segments (`/users/:id`)\n* **Optional Parameters:** Support routes like `/users/:id?`\n* **Wildcards:** Handle catch-all paths (`/files/*path`)\n* **Middleware Stacking:** Support for global and route-specific middleware\n* **Router Composition:** Merge routers for modular, maintainable routing\n\n---\n\n## ğŸ“„ Class: `RadixRouter`\n\n### Constructor\n\n```ts\nimport { RadixRouter } from \"tezx/registry\";\n\nconst router = new RadixRouter();\n```\n\nInstantiates a new router with an optimized radix tree for path matching.\n\n---\n\n## âš™ï¸ API Methods\n\n### `addRoute`\n\n```ts\naddRoute(method: HTTPMethod, path: string, handlers: (Callback | Middleware)[]): void;\n```\n\nRegisters a route with the specified HTTP method, path pattern, and middleware/handlers.\n\n* **`method`**: HTTP method (e.g., `\"GET\"`, `\"POST\"`, `\"PUT\"`, `\"DELETE\"`)\n* **`path`**: Route path, supporting dynamic (`:param`), optional (`:param?`), and wildcard (`*`, `*name`) segments\n* **`handlers`**: Array of middleware or handler functions to execute on match\n\n**Example:**\n\n```ts\nrouter.addRoute(\"GET\", \"/users/:id\", [getUserHandler]);\nrouter.addRoute(\"GET\", \"/files/*path\", [serveFileHandler]);\n```\n\n---\n\n### `search`\n\n```ts\nsearch(method: HTTPMethod, path: string): RouteMatchResult;\n```\n\nFinds and returns the route matching the given HTTP method and URL path.\n\n**Returns:**\n\n```ts\n{\n  method: HTTPMethod;\n  middlewares: Middleware[];\n  handlers: (Callback | Middleware)[];\n  params: Record<string, string | null>;\n}\n```\n\n**Example:**\n\n```ts\nconst match = router.search(\"GET\", \"/users/42\");\n/*\n{\n  method: \"GET\",\n  params: { id: \"42\" },\n  handlers: [...],\n  middlewares: [...]\n}\n*/\n```\n\n---\n\n### `mergeRouter`\n\n```ts\nmergeRouter(basePath: string, childRouter: RadixRouter): void;\n```\n\nComposes a child router under a specified base path, enabling modular route organization.\n\n**Use Case:**\n\nCreate feature-specific routers and merge under a common prefix.\n\n**Example:**\n\n```ts\nconst apiRouter = new RadixRouter();\napiRouter.addRoute(\"GET\", \"/users\", [usersHandler]);\n\nrouter.mergeRouter(\"/api\", apiRouter);\n// Now `/api/users` is handled by usersHandler\n```\n\n---\n\n## ğŸ§© Internal: `parsePattern`\n\nTransforms route patterns into segments for efficient radix tree insertion and matching.\n\n```ts\ntype Segment = {\n  type: \"static\" | \"dynamic\" | \"wildcard\";\n  value?: string;\n  paramName?: string;\n  isOptional?: boolean;\n};\n```\n\n---\n\n## âš¡ Matching Priority\n\nRoutes are matched in the following order to ensure deterministic behavior:\n\n1. **Static segments** (`/users`)\n2. **Dynamic segments** (`/users/:id`)\n3. **Optional dynamic segments** (`/users/:id?`)\n4. **Wildcard segments** (`/files/*path`)\n\nBacktracking allows optional segments to gracefully fallback when no match is found.\n\n---\n\n## ğŸ“Š Performance Metrics\n\n`RadixRouter` delivers blazing fast route resolution even with hundreds of routes:\n\n```text\nBenchmark:\n431 routes Ã— 100,000 matches = 43.1 million matches\nCompleted in ~11,983 ms (~278 ns per match)\n```\n\nThis performance makes it suitable for high-traffic, latency-sensitive applications.\n\n---\n\n## ğŸ›  Types\n\n### `RouteMatchResult<T>`\n\n```ts\n{\n  method: HTTPMethod;\n  middlewares: Middleware<T>[];\n  handlers: HandlerType<T>;\n  params: Record<string, string | null | undefined>;\n}\n```\n\n### `RouteRegistry`\n\n```ts\ninterface RouteRegistry {\n  name: string;\n  addRoute<T = any>(method: HTTPMethod, path: string, handler: HandlerType<T>): void;\n  search(method: HTTPMethod, path: string): RouteMatchResult<T>;\n  mergeRouter?(path: string, router: this): void;\n}\n```\n\n---\n\n## ğŸš€ Example Usage\n\n```ts\nconst router = new RadixRouter();\n\nrouter.addRoute(\"GET\", \"/hello\", [\n  (ctx) => ctx.text(\"Hello World\"),\n]);\n\nrouter.addRoute(\"GET\", \"/user/:id?\", [\n  (ctx) => ctx.text(`User ID: ${ctx.params.id ?? \"Guest\"}`),\n]);\n\nconst match = router.search(\"GET\", \"/user/123\");\nawait match.handlers[0](context); // Executes matched handler\n```\n"
    },
    {
      "id": 9,
      "path": "route-registry/custom-router",
      "name": "Custom Router",
      "folder": "Route Registry",
      "content": "# ğŸ“š Custom Routers & Middleware in TezX\n\nTezX offers you **full control** over routing by allowing custom routers implementing the `RouteRegistry` interface. This flexibility lets you define your routing strategy, middleware layering, and parameter parsing â€” all while seamlessly integrating with TezX's request lifecycle.\n\n---\n\n## ğŸš€ Overview\n\n* Implement route registration per HTTP method (GET, POST, etc.)\n* Register global middleware for **all methods** (`\"ALL\"` method)\n* Support dynamic route parameters (e.g., `/user/:id`, `/post/:id?`)\n* Combine middleware and method-specific handlers at runtime\n* Enable modular router composition with `mergeRouter()`\n* Clear TypeScript typings for maintainability and clarity\n* Normalize and match paths robustly with param extraction\n\n---\n\n## ğŸ”§ Powerful Custom Router Implementation\n\n```ts\nimport {\n  HTTPMethod,\n  RouteMatchResult,\n  HandlerType,\n  Middleware,\n  Callback,\n  RouteRegistry,\n} from \"tezx\";\n\ntype Segment = {\n  type: \"static\" | \"param\" | \"paramOptional\" | \"wildcard\";\n  value: string;\n};\n\n/**\n * Parses a URL path into segments with type info:\n * static segments, params, optional params, wildcards.\n */\nfunction parsePath(path: string): Segment[] {\n  return path\n    .split(\"/\")\n    .filter(Boolean)\n    .map((segment) => {\n      if (segment.startsWith(\":\")) {\n        if (segment.endsWith(\"?\")) {\n          return { type: \"paramOptional\", value: segment.slice(1, -1) };\n        }\n        return { type: \"param\", value: segment.slice(1) };\n      }\n      if (segment.startsWith(\"*\")) {\n        return { type: \"wildcard\", value: segment.slice(1) || \"*\" };\n      }\n      return { type: \"static\", value: segment };\n    });\n}\n\n/**\n * Matches a registered routeâ€™s segments against request path segments,\n * returning whether it matches and extracted parameters.\n */\nfunction matchPath(\n  routeSegments: Segment[],\n  requestSegments: string[],\n): { matched: boolean; params: Record<string, string | null> } {\n  const params: Record<string, string | null> = {};\n  let i = 0,\n    j = 0;\n\n  while (i < routeSegments.length && j < requestSegments.length) {\n    const routeSeg = routeSegments[i];\n    const reqSeg = requestSegments[j];\n\n    if (routeSeg.type === \"static\") {\n      if (routeSeg.value !== reqSeg) {\n        return { matched: false, params: {} };\n      }\n      i++;\n      j++;\n    } else if (routeSeg.type === \"param\") {\n      params[routeSeg.value] = reqSeg;\n      i++;\n      j++;\n    } else if (routeSeg.type === \"paramOptional\") {\n      params[routeSeg.value] = reqSeg;\n      i++;\n      j++;\n    } else if (routeSeg.type === \"wildcard\") {\n      params[routeSeg.value] = requestSegments.slice(j).join(\"/\");\n      i++;\n      j = requestSegments.length;\n    }\n  }\n\n  // Allow trailing optional params without matching segments\n  while (i < routeSegments.length) {\n    if (routeSegments[i].type === \"paramOptional\") {\n      params[routeSegments[i].value] = null;\n      i++;\n    } else {\n      break;\n    }\n  }\n\n  // Match only if all route & request segments accounted for\n  return { matched: i === routeSegments.length && j === requestSegments.length, params };\n}\n\nexport class CustomRouter implements RouteRegistry {\n  name = \"CustomRouter\";\n\n  private routes = new Map<\n    HTTPMethod,\n    { path: string; segments: Segment[]; handlers: HandlerType }[]\n  >();\n\n  constructor() {\n    // Initialize all HTTP methods + ALL for middleware\n    [\n      \"ALL\",\n      \"GET\",\n      \"POST\",\n      \"PUT\",\n      \"DELETE\",\n      \"PATCH\",\n      \"OPTIONS\",\n      \"HEAD\",\n    ].forEach((method) => this.routes.set(method as HTTPMethod, []));\n  }\n\n  /**\n   * Register route or middleware stack for a method + path.\n   * Middlewares use method = \"ALL\".\n   */\n  addRoute(method: HTTPMethod, path: string, handlers: HandlerType): void {\n    const normalizedPath = path.startsWith(\"/\") ? path : \"/\" + path;\n    const segments = parsePath(normalizedPath);\n    this.routes.get(method)!.push({ path: normalizedPath, segments, handlers });\n  }\n\n  /**\n   * Find matching middleware + handlers for a given method + path.\n   */\n  search(method: HTTPMethod, path: string): RouteMatchResult {\n    const normalizedPath = path.startsWith(\"/\") ? path : \"/\" + path;\n    const requestSegments = normalizedPath.split(\"/\").filter(Boolean);\n\n    // Collect all middlewares registered under \"ALL\" matching this path\n    const allMiddlewares = this.routes.get(\"ALL\") ?? [];\n    const middlewares: Middleware[] = [];\n    for (const route of allMiddlewares) {\n      if (matchPath(route.segments, requestSegments).matched) {\n        middlewares.push(...route.handlers);\n      }\n    }\n\n    // Find first matching route for this method\n    const methodRoutes = this.routes.get(method) ?? [];\n    let matchedRoute:\n      | { handlers: HandlerType; params: Record<string, string | null> }\n      | null = null;\n\n    for (const route of methodRoutes) {\n      const { matched, params } = matchPath(route.segments, requestSegments);\n      if (matched) {\n        matchedRoute = { handlers: route.handlers, params };\n        break;\n      }\n    }\n\n    if (!matchedRoute) {\n      // Return empty handlers if no match, but include middleware\n      return {\n        method,\n        middlewares,\n        handlers: [],\n        params: {},\n      };\n    }\n\n    return {\n      method,\n      middlewares,\n      handlers: matchedRoute.handlers,\n      params: matchedRoute.params,\n    };\n  }\n\n  /**\n   * Merge another router under a base path prefix.\n   * Useful for modular route composition.\n   */\n  mergeRouter(basePath: string, router: this): void {\n    if (!basePath.startsWith(\"/\")) basePath = \"/\" + basePath;\n    for (const [method, routes] of router.routes.entries()) {\n      for (const route of routes) {\n        // Combine base path and child route path cleanly\n        const combinedPath =\n          basePath === \"/\"\n            ? route.path\n            : basePath.endsWith(\"/\")\n            ? basePath.slice(0, -1) + route.path\n            : basePath + route.path;\n        this.addRoute(method, combinedPath, route.handlers);\n      }\n    }\n  }\n}\n```\n\n---\n\n## ğŸ›  How to Use with TezX â€” Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { CustomRouter } from \"./CustomRouter\";\n\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),\n  debugMode: true,\n});\n\n// Register global middleware on all methods for /api routes\napp.use(\"/api\", async (ctx, next) => {\n  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n\n// Define GET handler with dynamic param\napp.get(\"/api/users/:id\", async (ctx) => {\n  return ctx.json({ userId: ctx.params.id });\n});\n\n// Define POST handler for user creation\napp.post(\"/api/users\", async (ctx) => {\n  const data = await ctx.body.json();\n  return ctx.json({ created: data });\n});\n\n// Modular router example: admin routes\nconst adminRouter = new Router();\nadminRouter.get(\"/dashboard\", [\n  async (ctx) => ctx.text(\"Admin Dashboard\"),\n]);\napp.use(\"/admin\", adminRouter);\n```\n\n---\n\n## ğŸ’¡ Summary of Features\n\n| Feature                        | Description                                                   |\n| ------------------------------ | ------------------------------------------------------------- |\n| **Dynamic Params**             | Support for `:param`, `:param?` (optional), and `*wildcard`   |\n| **Middleware for ALL Methods** | Global middleware runs before method-specific handlers        |\n| **Modular Router Composition** | Combine multiple routers under base paths via `mergeRouter()` |\n| **Path Normalization**         | Ensures consistent matching with leading slashes              |\n| **Efficient Lookup**           | Matches by comparing segmented paths with param extraction    |\n| **Strict Typing**              | Full TypeScript support for safety and clarity                |\n| **Easy to Extend**             | Add validation, param coercion, and logging as needed         |\n\n---\n\n## âš™ï¸ Execution Flow in TezX\n\n1. **Route Registration:** You add routes or middleware via `addRoute()` or `app.use()`.\n2. **Incoming Request:** TezX calls `search(method, path)` on your router.\n3. **Route Matching:** Your router returns middleware + handlers with extracted params.\n4. **Middleware Execution:** Middleware registered on `\"ALL\"` runs first, controlling flow with `await next()`.\n5. **Handler Execution:** Matched route handlers execute after middleware completes.\n6. **Response Generation:** Handlers generate response; middleware can modify `ctx` at any step.\n\n---\n\n## ğŸ§© Middleware and `use()` Method\n\n* Middleware registered with `app.use(path, handler)` internally uses the `\"ALL\"` HTTP method.\n* This means middleware runs for **every HTTP method** on matching paths.\n* Middleware stacks can be layered, reusable, and scoped to sub-paths.\n* Supports async flow control with `next()`.\n\n---\n"
    },
    {
      "id": 10,
      "path": "api/tezx/app",
      "name": "App",
      "folder": "API/TezX",
      "content": "\n# âœ… `TezX` - Application Initialization\n\n`TezX` is a high-performance, middleware-based server and router framework designed for **Deno**, **Bun**, and **Node.js** environments. It offers first-class support for route handling, request lifecycle hooks, and elegant middleware chaining â€” built for speed and flexibility.\n\n---\n\n## ğŸš€ Quick Start: `server.ts`\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { TezX } from \"tezx/core\";\nimport { CustomRouter } from \"./router.ts\"; // your custom route tree\nimport { logger } from \"tezx/logger\";\n\n// Optional: Load environment variables\nawait loadEnv();\n\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),   // ğŸš¦ Route tree definition\n  debugMode: true,                     // ğŸ Enables detailed debugging logs\n  onPathResolve: (path) => path.replace(/\\/+$/, \"\").toLowerCase(), // Optional\n});\n\n// ğŸ”Œ Register global middleware (optional)\napp.use(logger);\n\n// ğŸŒ Start TezX on Deno\nDeno.serve({ port: 5000 }, app.serve);\n```\n\n---\n\n## ğŸ“¦ Folder Structure Example\n\n```bash\nproject/\nâ”œâ”€â”€ middlewares/\nâ”‚   â””â”€â”€ logger.ts\nâ”œâ”€â”€ router.ts\nâ”œâ”€â”€ server.ts\nâ”œâ”€â”€ .env\nâ””â”€â”€ src/\n    â””â”€â”€ handlers/\n        â””â”€â”€ home.ts\n```\n\n---\n\n## âš™ï¸ `TezXConfig` Options\n\n| Option          | Type                       | Description                                                           |\n| --------------- | -------------------------- | --------------------------------------------------------------------- |\n| `routeRegistry` | `Router`                   | Custom route registry implementing `Router` interface                 |\n| `debugMode`     | `boolean`                  | Enable middleware-level debug logging                                 |\n| `onPathResolve` | `(path: string) => string` | Hook to normalize paths (e.g., trim trailing slashes, lowercase URLs) |\n| `basePath`      | `string`                   | Optional base path for all routes (defaults to `/`)                   |\n| `env`           | `Record<string, any>`      | Custom environment object passed into each context                    |\n\n---\n\n## ğŸ›¡ Global Middleware Support\n\n`TezX` allows chaining global middleware using the `.use()` method (inherited from `Router`). Each middleware gets access to the context and `next()` function.\n\n```ts\nimport { Middleware } from \"tezx/types\";\n\nexport const loggerMiddleware: Middleware = async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n};\n```\n\n### Registering Global Middleware\n\n```ts\napp.use(loggerMiddleware);\n```\n\n---\n\n## â• Route-Level Middleware (All Methods)\n\nIf you define a middleware-only route (without `.get()`, `.post()` etc.), `TezX` treats it as an `ALL` method handler â€” perfect for interceptors, guards, or prefix-based matching:\n\n```ts\napp.addRoute({\n  method: \"ALL\", // Intercepts all methods (GET, POST, etc.)\n  path: \"/admin/:section\",\n  handler: adminAuthMiddleware,\n});\n```\n\n---\n\n## âŒ Custom 404 Handler\n\n```ts\napp.notFound((ctx) => ctx.status(404).text(\"ğŸ” Not Found\"));\n```\n\n---\n\n## ğŸ›  Custom Error Handler\n\n```ts\napp.onError((err, ctx) => {\n  console.error(\"Unhandled error:\", err.message);\n  return ctx.status(500).text(\"ğŸ”¥ Internal Server Error\");\n});\n```\n\n---\n\n## ğŸ“¦ Environment Variables (`.env`)\n\n```bash\nPORT=5000\nAPP_NAME=TezXApp\n```\n\n```ts\n// Access anywhere\nconst port = Deno.env.get(\"PORT\");\n```\n\n---\n\n## ğŸ§ª Running the Server\n\n```bash\ndeno run --allow-net --allow-read --allow-env server.ts\n```\n\nor with live reload:\n\n```bash\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## ğŸ§¬ Runtime Compatibility\n\n| Feature    | Deno       | Bun        | Node.js   |\n| ---------- | ---------- | ---------- | --------- |\n| `.serve()` | âœ… Native   | âœ… Native   | âœ… Adapter |\n| Middleware | âœ… Yes      | âœ… Yes      | âœ… Yes     |\n| WebSocket  | âœ… Built-in | âœ… Built-in | â– Custom  |\n\n---\n\n## ğŸ’¡ Summary\n\n| Feature      | Description                                       |\n| ------------ | ------------------------------------------------- |\n| `TezX`       | Main app handler & runtime-agnostic router        |\n| `use()`      | Register global middleware                        |\n| `addRoute()` | Register routes dynamically, including ALL method |\n| `notFound()` | Custom 404 handler                                |\n| `onError()`  | Global error handler                              |\n| `serve()`    | Entry point for Deno/Bun/Node servers             |\n\n---\n"
    },
    {
      "id": 11,
      "path": "api/tezx/serve",
      "name": "Serve",
      "folder": "API/TezX",
      "content": "# ğŸ“¡ `app.serve()` â€” TezX Runtime-Agnostic Request Handler\n\nThe `app.serve()` method is the **core universal handler** for processing HTTP requests in **TezX**. It adapts itself to different JavaScript runtimes by internally delegating requests to the appropriate logic.\n\n---\n\n## ğŸ§  What It Does\n\n* Accepts a native `Request` object (based on the Fetch API).\n* Optionally accepts runtime-specific arguments like `connInfo` (Deno), `req, res, server` (Node.js), or `server` (Bun).\n* Processes the request using your defined middleware and routes.\n* Returns a `Response` object.\n\nThis method allows you to **integrate TezX into any runtime** with **zero extra configuration**.\n\n---\n\n## âš™ï¸ How It Works Internally\n\n```ts\npublic async serve(req: Request, ...args: any[]): Promise<Response>\n```\n\n* `req`: A standard `Request` object.\n* `args`: Optional values like response objects, connections, or server instances.\n\n  * Parses the request.\n  * Creates a context.\n  * Executes middleware chain.\n  * Calls route handlers.\n  * Returns a finalized `Response`.\n\n---\n\n## âœ… Usage Examples\n\n### ğŸ”· Bun\n\n```ts\n// Simple usage\napp.serve(req, server);\n\n// Full Bun server with WebSocket support\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: {\n    open(ws) {\n      return ws.data?.open?.(ws);\n    },\n    message(ws, msg) {\n      return ws.data?.message?.(ws, msg);\n    },\n    close(ws, code, reason) {\n      return ws.data?.close?.(ws, { code, reason });\n    },\n  },\n});\n```\n\n---\n\n### ğŸŸ¨ Deno\n\n```ts\n// Basic serve function\nimport { serve } from \"https://deno.land/std/http/server.ts\";\n\nserve((req, connInfo) => app.serve(req, connInfo));\n\n// Or using modern API\nDeno.serve({ port: 8080 }, app.serve);\n```\n\n---\n\n### ğŸŸ¦ Node.js\n\n```ts\nimport { createServer } from \"http\";\nimport { mountTezXOnNode } from \"tezx/node\";\n\n// Simple server mounting\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n\n// OR: manual conversion if needed\nconst response = await app.serve(toWebRequest(req), req, res, server);\n```\n\n---\n\n## ğŸ”„ When to Use `app.serve()`\n\n| Scenario                       | Use `app.serve()`? |\n| ------------------------------ | ------------------ |\n| Bunâ€™s `Bun.serve`              | âœ… Yes              |\n| Deno's `serve` or `Deno.serve` | âœ… Yes              |\n| Node's `http.createServer`     | âœ… Yes              |\n| Edge runtimes (like Vercel)    | âœ… Yes              |\n| Cloudflare Workers             | âœ… Yes              |\n\n---\n\n## ğŸ“ Example\n\n```ts\nconst res = await app.serve(\n  new Request(\"http://localhost/hello\", { method: \"GET\" })\n);\nconsole.log(await res.text()); // â†’ \"Hello TezX!\" (if route is defined)\n```\n\n---\n\n## ğŸ›  Tip for TypeScript Users\n\nSince `...args: any[]` can vary between environments, you can narrow down types like:\n\n```ts\n// For Deno\napp.serve(req, connInfo as Deno.ServeHandlerInfo);\n\n// For Node\napp.serve(req, res, server);\n```\n\n---\n\n## ğŸ§ª Debugging Middleware Chain\n\nWant to trace how `app.serve()` is executing?\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Incoming request:\", ctx.method, ctx.url);\n  await next();\n});\n```\n\n---\n\n## ğŸ”š Summary\n\n* âœ… Cross-runtime request handler\n* ğŸ“¦ Accepts Fetch API-compatible `Request`\n* ğŸ” Handles middleware, routes, and returns `Response`\n* ğŸ’¡ Plug-and-play with Node, Deno, and Bun\n\n> `app.serve()` is the glue between the **runtime** and your **application logic**.\n"
    },
    {
      "id": 12,
      "path": "api/context/context",
      "name": "Context",
      "folder": "API/Context",
      "content": "\n# ğŸ“˜ TezX `Context` â€” Developer Guide\n\nThe `Context` object in TezX encapsulates the HTTP request and response, providing convenient methods to access request data, manipulate headers, send various types of responses, and manage files â€” all within the lifecycle of a single HTTP transaction.\n\n---\n\n## ğŸ” Request Handling\n\n### `ctx.req` â€” The Wrapped Request Object\n\nProvides high-level access to incoming HTTP request data:\n\n```ts\nctx.req.query;       // Parsed query parameters as an object\nawait ctx.req.json();      // Parse JSON body\nawait ctx.req.formData();  // Parse form data (including multipart/form-data)\nctx.req.header(name);      // Get header by name (case-insensitive)\nctx.req.method;       // HTTP method (GET, POST, etc.)\nctx.req.url;          // Full request URL string\nctx.req.params;       // Route parameters (e.g., from /user/:id)\n```\n\n---\n\n## ğŸ·ï¸ Header Utilities\n\n### Get All Headers\n\n```ts\nconst headers = ctx.header();\nconsole.log(headers);\n// Output: { 'content-type': 'application/json', ... }\n```\n\n### Get Specific Header (Case-Insensitive)\n\n```ts\nconst contentType = ctx.header(\"content-type\");\nconsole.log(contentType); // e.g. 'application/json'\n```\n\n### Set or Append Response Headers\n\n```ts\nctx.setHeader(\"x-powered-by\", \"TezX\");\nctx.setHeader(\"x-custom\", \"value\", { append: true });\n```\n\n* The `append` option appends the header value instead of overwriting.\n\n---\n\n## ğŸ“¡ Response Helpers\n\n### Set HTTP Status Code\n\n```ts\nctx.status(404); // Chainable\n```\n\n### Send Response with Automatic Content-Type Detection\n\n```ts\nctx.send({ message: \"OK\" });        // Sends JSON by default\nctx.send(\"<h1>Hello</h1>\");         // Sends HTML content\nctx.send(\"Plain text response\");    // Sends plain text\n```\n\n### Send JSON Response\n\n```ts\nctx.json({ success: true });\n```\n\n### Send Plain Text Response\n\n```ts\nctx.text(\"Hello World\");\n```\n\n### Send HTML Response\n\n```ts\nctx.html(\"<h1>Welcome</h1>\");\n```\n\nOr using tagged template literal syntax:\n\n```ts\nctx.html`<h1>Hello, ${username}</h1>`;\n```\n\n### Send XML Response\n\n```ts\nctx.xml(`<user><name>John</name></user>`);\n```\n\n### Redirect Client\n\n```ts\nctx.redirect(\"/login\");       // Defaults to HTTP 302 Found\nctx.redirect(\"/admin\", 301);  // Permanent redirect\n```\n\n---\n\n## ğŸ“ File Streaming & Downloads\n\n### Send File (Streaming)\n\n```ts\nawait ctx.sendFile(\"/public/image.png\");\n```\n\nWith additional headers or custom filename:\n\n```ts\nawait ctx.sendFile(\"/docs/manual.pdf\", {\n  filename: \"UserManual.pdf\",\n  headers: { \"X-Sent-By\": \"TezX\" },\n});\n```\n\n### Force File Download with Custom Filename\n\n```ts\nawait ctx.download(\"/files/invoice.pdf\", \"Invoice-2024.pdf\");\n```\n\n---\n\n## ğŸ“¦ Complete Example\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX();\n\napp.get(\"/\", (ctx) => ctx.text(\"Welcome to TezX\"));\n\napp.post(\"/data\", async (ctx) => {\n  const body = await ctx.req.json();\n  return ctx.json({ received: body });\n});\n\napp.get(\"/user/:id\", (ctx) => {\n  const userId = ctx.req.params.id;\n  return ctx.json({ userId });\n});\n\napp.get(\"/download\", async (ctx) => {\n  return await ctx.download(\"./files/sample.pdf\", \"sample.pdf\");\n});\n\napp.get(\"/html\", (ctx) => {\n  return ctx.html`<h1>Hello ${ctx.env.username || \"Guest\"}</h1>`;\n});\n\nexport default app;\n```\n\n---\n\n## ğŸ§ª Handling Form Data (Multipart)\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData.get(\"image\");\n  const username = formData.get(\"username\");\n  return ctx.json({ uploadedBy: username });\n});\n```\n\n**HTML form example for testing:**\n\n```html\n<form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"username\" placeholder=\"Your Name\" />\n  <input type=\"file\" name=\"image\" />\n  <button type=\"submit\">Upload</button>\n</form>\n```\n\n---\n\n## ğŸ§  Pro Tip: Chainable Methods\n\nMost context methods are chainable for concise response building:\n\n```ts\nctx.status(201)\n   .setHeader(\"x-token\", \"abc123\")\n   .json({ message: \"Resource created\" });\n```\n\n---\n\n# Summary\n\n| Feature          | Description                                 | Usage Example                                  |\n| ---------------- | ------------------------------------------- | ---------------------------------------------- |\n| Request Query    | Access parsed query parameters              | `ctx.req.query`                                |\n| Request Body     | Parse JSON or form data                     | `await ctx.req.json()`                         |\n| Headers          | Get/set response headers                    | `ctx.header()`, `ctx.setHeader()`              |\n| Response Types   | Send JSON, text, HTML, XML, redirects       | `ctx.json()`, `ctx.text()`, `ctx.redirect()`   |\n| File Streaming   | Send or download files with custom headers  | `await ctx.sendFile()`, `await ctx.download()` |\n| Middleware Ready | Context flows through middleware with async | `await next()` in handlers                     |\n"
    },
    {
      "id": 13,
      "path": "api/context/context-propagation",
      "name": "Context Propagation",
      "folder": "API/Context",
      "content": "# ğŸ§© **Context Propagation**\n\nContext propagation in **TezX** allows **type-safe**, **request-scoped state sharing** across middleware and route handlers. Built on TypeScript, it enables fine-grained control, promotes modular architecture, and enhances developer productivity through strict typing and tooling support.\n\n---\n\n## ğŸ§  **Conceptual Overview**\n\n* **Type-safe context shape**\n* **Scoped to individual requests**\n* **Mutable across middleware**\n* **Extended through type composition**\n\n---\n\n## 1ï¸âƒ£ **Defining a Typed Context**\n\nCreate a strongly-typed interface to define the structure of your request context.\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required unique identifier per request\n}\n```\n\n---\n\n## 2ï¸âƒ£ **Typed Router Instantiation**\n\nPass the context type to `Router` or `TezX` for strict type enforcement.\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX<CustomContext>();\n```\n\n---\n\n## 3ï¸âƒ£ **Injecting Data via Middleware**\n\nUse middleware to enrich the context during the request lifecycle.\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.user = await authenticate(ctx.req);\n  return next();\n});\n\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n## 4ï¸âƒ£ **Typed Context Access in Handlers**\n\nSafely access your context properties in any handler with full IntelliSense support.\n\n```ts\napp.get(\"/me\", (ctx) => {\n  return ctx.json({\n    requestId: ctx.requestId,\n    email: ctx.user?.email ?? \"Anonymous\",\n  });\n});\n```\n\n---\n\n## ğŸ” **Context Composition**\n\nScale your context by composing smaller types:\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface MetricsContext {\n  logger: Logger;\n  startTime: number;\n}\n\ntype AppContext = AuthContext & MetricsContext;\n\nconst app = new TezX<AppContext>();\n```\n\n---\n\n## ğŸ›¡ï¸ **Validation Middleware**\n\nEnsure the presence of critical fields during runtime:\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Missing request ID\");\n  return next();\n});\n```\n\n---\n\n## âŒ **Type Safety Guards**\n\nTypeScript prevents invalid usage and ensures refactor-safe access:\n\n```ts\n// âŒ Property 'newProp' does not exist\nctx.newProp = \"value\";\n\n// âŒ Type mismatch\nctx.requestId = 123; // should be a string\n```\n\n---\n\n## ğŸ§© **Optional Properties Handling**\n\nUse safe access patterns for optional context data:\n\n```ts\napp.get(\"/dashboard\", (ctx) => {\n  if (!ctx.user) return ctx.status(401).json({ error: \"Unauthorized\" });\n\n  return ctx.json({ email: ctx.user.email });\n});\n```\n\n---\n\n## ğŸ“Œ **Best Practices**\n\n### âœ… **Order Matters**\n\nSet required context early and validate immediately after.\n\n```ts\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Missing ID\");\n  return next();\n});\n```\n\n---\n\n### âœ… **Immutability**\n\nPrefer immutable patterns when modifying nested context objects.\n\n```ts\n// Prefer\nctx.user = { ...ctx.user, email: \"updated@example.com\" };\n```\n\n---\n\n### âœ… **Testing with Mock Context**\n\nTest your logic in isolation with mock context objects.\n\n```ts\nconst mockCtx: CustomContext = {\n  requestId: \"req-test-001\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\nconst response = await handler(mockCtx);\n```\n\n---\n\n## ğŸ”„ **Context Lifecycle Overview**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Incoming Request\n  Server->>Middleware A: Inject requestId\n  Middleware A->>Middleware B: Attach user\n  Middleware B->>Handler: Execute route\n  Handler->>Server: Prepare response\n  Server->>Client: Send response\n```\n\n---\n\n## ğŸ¯ **Why Context Propagation?**\n\n| Benefit            | Description                                                            |\n| ------------------ | ---------------------------------------------------------------------- |\n| ğŸ” Type Safety     | Compile-time validation prevents access errors and invalid mutations   |\n| ğŸ§© Modularity      | Enables context slicing and extension across layers                    |\n| âš™ï¸ Maintainability | Clear structure for evolving app concerns like auth, logging, sessions |\n| ğŸš€ Scalability     | Composable and predictable patterns for large applications             |\n\n---\n\n## ğŸ§µ Extendability Tips\n\n* Extend context per domain: `AuthContext`, `TraceContext`, `FeatureFlagContext`, etc.\n* Use utility types for safer extensions: `Partial<>`, `Pick<>`, etc.\n* Compose middlewares using domain isolation and shared contracts.\n\n---\n"
    },
    {
      "id": 14,
      "path": "api/middleware/merging-middlewares",
      "name": "Merging Middlewares",
      "folder": "API/Middleware",
      "content": "# âœ… Middleware Merging Strategy\n\nThis outlines how two router trees with nested middlewares are **intelligently merged** to preserve execution order and structure.\n\n---\n\n## ğŸ”¹ **Before Merging**\n\n### ğŸ§­ **Root Router Tree (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\nâ””â”€â”€ \"/test\"                             # path\n    â”œâ”€â”€ middlewares: [m1]              # existing middleware\n    â””â”€â”€ children:\n        â””â”€â”€ \"/test/1\"\n            â”œâ”€â”€ middlewares: [m2]\n```\n\n* `/test`: Contains middleware `[m1]`.\n* `/test/1`: A subroute with its own middleware `[m2]`.\n\n---\n\n## ğŸ”¹ **New Router Tree to Merge (`RouterMiddlewares`)**\n\n### ğŸŒ± **Incoming Subrouter**\n\n```plaintext\nRouterMiddlewares\nâ””â”€â”€ \"/test\"\n    â”œâ”€â”€ middlewares: [m3]              # additional middleware to merge\n    â””â”€â”€ children:\n        â””â”€â”€ \"/test/2\"\n            â”œâ”€â”€ middlewares: [m4]\n```\n\n* `/test`: New middleware `[m3]` for same path.\n* `/test/2`: New child route under `/test`.\n\n---\n\n## ğŸ” **After Merging (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\nâ””â”€â”€ \"/test\"\n    â”œâ”€â”€ middlewares: [m1, m3]          # merged middlewares\n    â””â”€â”€ children:\n        â”œâ”€â”€ \"/test/1\"\n        â”‚   â”œâ”€â”€ middlewares: [m2]\n        â””â”€â”€ \"/test/2\"\n            â”œâ”€â”€ middlewares: [m4]      # newly added\n```\n\n* Middleware arrays are **merged**: `[m1] + [m3] â†’ [m1, m3]`.\n* All existing children remain untouched (`/test/1`).\n* New children are **appended** (`/test/2`).\n\n---\n\n## ğŸ§  **Implementation Behavior**\n\n### ğŸ”§ `addRoute` API\n\n```ts\n/**\n * Registers a route or middleware stack for a specific HTTP method.\n *\n * @param method - HTTP method (e.g., \"GET\", \"POST\", \"ALL\" for middleware).\n * @param path - Path to match (e.g., \"/api\", \"/test\").\n * @param handlers - Array of middleware or route handler functions.\n */\naddRoute(method: HttpMethod | \"ALL\", path: string, handlers: Handler[]): void;\n```\n\n* `method = \"ALL\"` implies middleware, applied to all requests for that path.\n* Used internally when adding reusable or nested routers.\n\n---\n\n## ğŸ§± **Automatic Middleware Registration Logic**\n\nWhen merging routes via a registry:\n\n```ts\nif (middlewares?.length) {\n  this.#addRoute(\"ALL\", path, middlewares);\n}\n```\n\n* Ensures **all middleware layers** from incoming routers are preserved.\n* Middleware at the same path is concatenated, not replaced.\n\n---\n"
    },
    {
      "id": 15,
      "path": "api/middleware/middleware",
      "name": "Middleware",
      "folder": "API/Middleware",
      "content": "# ğŸ§© `use()` â€“ Register Middlewares or Routers\n\nThe `use()` method in `TezX.Router` is a powerful, flexible API for registering middlewares and sub-routers â€” either globally or scoped to a specific path.\n\n---\n\n## ğŸ“š **Function Signature**\n\n```ts\nuse(...args: any[]): this;\n```\n\nInternally supports overloads like:\n\n```ts\n// Global middleware\nuse(middleware);\nuse([middleware1, middleware2]);\n\n// Scoped middleware\nuse(\"/path\", middleware);\nuse(\"/path\", [middleware1, middleware2]);\n\n// Middleware + handler or router\nuse(\"/path\", middleware, callback);\nuse(\"/path\", [middleware1], subRouter);\nuse(middleware, callback);\nuse([middleware], subRouter);\n```\n\n---\n\n## ğŸ“¦ **Middleware Type**\n\n```ts\ntype Middleware<T = {}, Path extends string = any> = (\n  ctx: Ctx<T, Path>,\n  next: () => Promise<void>\n) => Response | Promise<Response | void>;\n```\n\n* Receives a request context (`ctx`) and a `next()` callback.\n* Can **modify `ctx`**, **short-circuit**, or **continue** the chain with `await next()`.\n\n---\n\n## ğŸ§ª **Usage Examples**\n\n### 1. **Global Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Request started\");\n  await next();\n  console.log(\"Request ended\");\n});\n```\n\n### 2. **Multiple Global Middlewares**\n\n```ts\napp.use([\n  loggerMiddleware,\n  requestIDMiddleware,\n  timingMiddleware\n]);\n```\n\n---\n\n### 3. **Scoped Middleware by Path**\n\n```ts\napp.use(\"/admin\", async (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    return ctx.status(403).text(\"Forbidden\");\n  }\n  return next();\n});\n```\n\n> Middleware will only run for requests under `/admin`.\n\n---\n\n### 4. **Scoped Middleware with Sub-Router**\n\n```ts\nconst authRouter = new Router();\n\nauthRouter.get(\"/login\", (ctx) => ctx.text(\"Login page\"));\n\napp.use(\"/auth\", authMiddleware, authRouter);\n```\n\n> Middleware runs before any subroutes inside `/auth`.\n\n---\n\n## ğŸ§  **How It Works Internally**\n\nThe `use()` function:\n\n* Normalizes arguments into `path`, `middlewares`, and optional `router`.\n* Registers middlewares using:\n\n```ts\nthis.#addRoute(\"ALL\", path, middlewares);\n```\n\n* If a `Router` is passed, itâ€™s mounted using:\n\n```ts\nthis.addRouter(path, router);\n```\n\n---\n\n## ğŸ” **Middleware Chaining**\n\nAll middleware functions follow a **chainable model** via `next()`:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.startTime = Date.now();\n  await next();\n  const ms = Date.now() - ctx.startTime;\n  console.log(`${ctx.method} ${ctx.path} - ${ms}ms`);\n});\n```\n\n* Each middleware may perform actions **before or after** the next one.\n* If `next()` is not called, the chain stops.\n\n---\n\n## ğŸ§± **Router Composition**\n\nMultiple routers can be composed with isolated or shared middleware:\n\n```ts\nconst v1 = new Router();\nv1.use(\"/users\", authMiddleware, userRouter);\n\nconst v2 = new Router();\nv2.use(\"/products\", productRouter);\n\napp.use(\"/api\", [loggerMiddleware], v1);\napp.use(\"/api\", v2);\n```\n\n---\n\n## ğŸ›¡ï¸ **Best Practices**\n\n| Tip                           | Description                                        |\n| ----------------------------- | -------------------------------------------------- |\n| âœ… Use scoped middleware       | For route-specific logic like authentication       |\n| âœ… Keep global middleware pure | Logging, CORS, rate limiting, etc.                 |\n| âœ… Chain with `next()`         | Enables layered composition                        |\n| âœ… Compose routers             | Modularize APIs or feature groups                  |\n| âœ… Handle errors               | Wrap logic in try/catch or global error middleware |\n\n---\n"
    },
    {
      "id": 16,
      "path": "api/router/router",
      "name": "Router",
      "folder": "API/Router",
      "content": "\n# ğŸš€ TezX Router â€” Complete Developer Guide\n\n`Router` is the heart of the **tezx** web framework, providing a modern, flexible, and high-performance way to handle HTTP routing, middleware, static assets, sub-routing, and even Server-Sent Events (SSE).\n\n---\n\n## Import & Initialization\n\n```ts\nimport { Router } from \"tezx\";\n\n// Create a new Router instance\nconst app = new Router({\n  basePath: \"/\",           // Base path for all routes (default: \"/\")\n  env: { NODE_ENV: \"prod\" } // Optional environment variables accessible in middleware\n});\n```\n\n---\n\n## Core Concepts\n\n* **Route registration:** Define endpoints with HTTP methods (`GET`, `POST`, etc.).\n* **Middleware support:** Chain multiple middlewares per route.\n* **Route grouping:** Organize routes under common prefixes.\n* **Sub-routers:** Modularize your API by mounting routers under paths.\n* **Static files:** Serve assets like images, CSS, JS seamlessly.\n* **SSE (Server-Sent Events):** Real-time server push via HTTP.\n\n---\n\n## 1. Defining Routes\n\n### Basic Route Handler\n\n```ts\napp.get(\"/hello\", (ctx) => {\n  ctx.body = \"Hello from TezX!\";\n});\n```\n\n* `ctx` is the request context, including request info, response methods, params, and more.\n* Set response by assigning to `ctx.body`.\n\n### Route with Middleware\n\n```ts\nconst auth = async (ctx, next) => {\n  if (!ctx.user) {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  await next(); // Proceed to next middleware or handler\n};\n\napp.get(\"/profile\", auth, (ctx) => {\n return ctx.json({ user: ctx.user });\n});\n```\n\n* Middleware intercepts the request and can halt or continue the chain.\n* Middleware functions accept `(ctx, next)` and must call `await next()` to continue.\n\n### Multiple Middlewares\n\n```ts\nconst log = (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  return next();\n};\n\nconst adminOnly = (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    ctx.setStatus = 403;\n    return ctx.text(\"Forbidden\");\n  }\n  return next();\n};\n\napp.get(\"/admin/dashboard\", [auth, log, adminOnly], (ctx) => {\n  return {\n    body: \"Admin Dashboard\"\n  }\n});\n```\n\n---\n\n## 2. HTTP Methods Supported\n\nUse methods matching HTTP verbs:\n\n* `.get(path, ...middleware, handler)`\n* `.post(path, ...middleware, handler)`\n* `.put(path, ...middleware, handler)`\n* `.patch(path, ...middleware, handler)`\n* `.delete(path, ...middleware, handler)`\n* `.options(path, ...middleware, handler)`\n* `.all(path, ...middleware, handler)` â€” match all HTTP methods\n\nExample:\n\n```ts\napp.post(\"/submit\", (ctx) => {\n  const data = ctx.request.body;\n  return ctx.json({ received: data });\n});\n```\n\n---\n\n## 3. Static File Serving\n\nServe files from a local folder under a route:\n\n```ts\napp.static(\"/assets\", \"./public/assets\");\n```\n\n* Supports directory-based static serving.\n* Use for images, CSS, JS, or any public assets.\n* You can also serve at root:\n\n```ts\napp.static(\"./public\");\n```\n\n---\n\n## 4. Grouping Routes for Cleaner Code\n\nGroup related routes under a common prefix:\n\n```ts\napp.group(\"/api/v1\", (router) => {\n  router.get(\"/users\", (ctx) => { /*...*/ });\n  router.post(\"/users\", (ctx) => { /*...*/ });\n});\n```\n\n* `group` creates a new sub-router scoped to the prefix.\n* Improves modularity and readability.\n\n---\n\n## 5. Mounting Sub-Routers\n\nBuild modular routers and mount them at a path:\n\n```ts\nconst adminRouter = new Router();\n\nadminRouter.use(auth); // Apply auth middleware to all admin routes\n\nadminRouter.get(\"/dashboard\", (ctx) => {\n  return ctx.text(\"Welcome, admin!\")\n});\n\napp.addRouter(\"/admin\", adminRouter);\n```\n\n* `addRouter` mounts another router at the specified base path.\n* Sub-routers can have their own middleware, routes, and groups.\n\n---\n\n## 6. Middleware Usage & Notes\n\n* Middleware signature: `async (ctx, next) => { ... }`\n* Call `await next()` to pass control.\n* Can short-circuit by not calling `next()`.\n* Can attach data to `ctx` (e.g., `ctx.user = ...`).\n* Supports arrays of middlewares for routes or groups.\n\n---\n\n## 8. Example: Full Mini App\n\n```ts\nimport { Router } from \"tezx\";\n\nconst app = new Router();\n\nconst logger = async (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  await next();\n};\n\nconst auth = async (ctx, next) => {\n  const token = ctx.headers[\"authorization\"];\n  if (token !== \"secret-token\") {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  ctx.user = { name: \"Alice\" };\n  await next();\n};\n\napp.use(logger);\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Welcome to TezX Router!\");\n});\n\napp.group(\"/api\", (api) => {\n  api.get(\"/public\", (ctx) => {\n    return ctx.text(\"Public API data\");\n  });\n\n  api.get(\"/private\", auth, (ctx) => {\n    return ctx.text(`Hello ${ctx.user.name}, this is private data.`);\n  });\n});\n\napp.static(\"/static\", \"./public\");\n\nexport default app;\n```\n\n---\n\n## 9. Tips for Success\n\n* Use `.group()` and `.addRouter()` to keep routes modular and maintainable.\n* Always validate input in middleware before reaching handlers.\n* Use static serving for your frontend assets or uploads.\n* Compose middlewares to reuse authentication, logging, or error handling.\n* Use `.all()` to apply middleware or handlers for all HTTP methods on a path.\n\n---\n"
    },
    {
      "id": 17,
      "path": "api/router/router-merging",
      "name": "Router Merging",
      "folder": "API/Router",
      "content": "\n# ğŸ”€ **Router Merging â€” TezX**\n\n## ğŸ“˜ Overview\n\n**Router merging** enables seamless integration of multiple routers into a parent application, preserving route hierarchy and avoiding accidental collisions by design.\n\n---\n\n## ğŸ§­ Terminology\n\n| Term              | Meaning                                                     |\n| ----------------- | ----------------------------------------------------------- |\n| **Parent Router** | Your primary app instance (`TezX` or `Router`)              |\n| **Sub-Router**    | A child router with its own routes and middleware           |\n| **Merged Router** | The resulting router structure after `.use()` or `.merge()` |\n\n---\n\n## ğŸ“‚ Pre-Merge Example\n\n```bash\nParent Router:\nâ”œâ”€â”€ /test\nâ”‚   â”œâ”€â”€ GET â†’ handler1\nâ”‚   â””â”€â”€ /1\nâ”‚       â”œâ”€â”€ GET â†’ handler2\n```\n\n---\n\n## â• Adding a Sub-Router\n\n```bash\nSub-Router:\nâ”œâ”€â”€ /products\nâ”‚   â””â”€â”€ /2\nâ”‚       â”œâ”€â”€ GET â†’ handler3\n```\n\n---\n\n## âœ… After Merge\n\n```bash\nMerged Router:\nâ”œâ”€â”€ /test\nâ”‚   â”œâ”€â”€ GET â†’ handler1\nâ”‚   â””â”€â”€ /1\nâ”‚       â”œâ”€â”€ GET â†’ handler2\nâ”œâ”€â”€ /products\nâ”‚   â””â”€â”€ /2\nâ”‚       â”œâ”€â”€ GET â†’ handler3\n```\n\n> âœ… All routes remain intact and merge **non-destructively**.\n\n---\n\n## ğŸ§ª Code Example\n\n```ts\nimport { TezX, Router } from \"tezx\";\n\n// Parent router\nconst app = new TezX();\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// Sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge the routers\napp.use(\"/\", productRouter);\n```\n\n---\n\n## ğŸ§‘â€ğŸ’» Best Practices\n\n### 1. **Use Unique Prefixes**\n\nAvoid route conflicts by assigning distinct prefixes:\n\n```ts\nconst authRouter = new Router();\nauthRouter.get(\"/login\", ...);\napp.use(\"/auth\", authRouter); // Routes like /auth/login\n```\n\n---\n\n### 2. **Middleware Hygiene**\n\nEach sub-router can register its own middleware chain:\n\n```ts\nconst api = new Router();\n\napi.use((ctx, next) => {\n  ctx.setHeader(\"x-api\", \"v1\");\n  return next();\n});\n\napi.get(\"/status\", (ctx) => ctx.json({ ok: true }));\n\napp.use(\"/api\", api);\n```\n\n---\n\n### 3. **Inspect Route Tree**\n\nUse dev logs to inspect routes:\n\n```ts\nconsole.log(app.routes); // Tree-style structure if exposed\n```\n\n---\n\n### 4. **Safe Re-Merge Patterns**\n\nAvoid defining the same path in multiple routers unless intended.\n\n```ts\n// Avoid this\nrouter1.get(\"/ping\", ...);\nrouter2.get(\"/ping\", ...);\n\n// Instead, use a prefix\napp.use(\"/api\", router1);\napp.use(\"/public\", router2);\n```\n\n---\n\n## ğŸ” Debug Tip\n\n```ts\napp.get(\"/example\", (ctx) => {\n  console.log(\"Routing to /example\");\n  return ctx.text(\"Logged\");\n});\n```\n"
    },
    {
      "id": 18,
      "path": "api/request/request",
      "name": "Request",
      "folder": "API/Request",
      "content": "# ğŸ“¦ TezXRequest â€” Request Wrapper\n\n`TezXRequest` wraps the native `Request` and provides convenient access to:\n\n* Query parameters\n* Route parameters\n* Headers\n* Body parsing (JSON, FormData, file uploads)\n* Remote address info (via middleware)\n\n---\n\n## ğŸ”¹ Properties\n\n### `url: string`\n\nFull request URL.\n\n```ts\nctx.req.url; // e.g. \"https://example.com/api/user?id=5\"\n```\n\n---\n\n### `method: HTTPMethod`\n\nHTTP method (GET, POST, etc).\n\n```ts\nctx.req.method; // e.g. \"POST\"\n```\n\n---\n\n### `pathname: string`\n\nURL path without query string.\n\n```ts\nctx.req.pathname; // e.g. \"/api/user\"\n```\n\n---\n\n### `params: Record<string, string>`\n\nRoute parameters extracted dynamically.\n\n```ts\n// For route `/user/:id`\nctx.req.params.id; // e.g. \"123\"\n```\n\n---\n\n### `query: Record<string, string>`\n\nParsed query string parameters.\n\n```ts\n// URL: /search?q=js&page=2\nctx.req.query.q;    // \"js\"\nctx.req.query.page; // \"2\"\n```\n\n---\n\n## ğŸ”¸ Methods\n\n### `header(): Record<string, string>`\n\nGet all request headers.\n\n```ts\nconst headers = ctx.req.header();\nconsole.log(headers[\"content-type\"]); // \"application/json\"\n```\n\n---\n\n### `header(name: string): string | undefined`\n\nGet a specific header (case-insensitive).\n\n```ts\nconst contentType = ctx.req.header(\"content-type\");\nconsole.log(contentType); // \"application/json\"\n```\n\n---\n\n### `text(): Promise<string>`\n\nRead raw request body as text.\n\n```ts\nconst body = await ctx.req.text();\nconsole.log(body); // raw string body\n```\n\n---\n\n### `json<T = any>(): Promise<T>`\n\nParse request body as JSON.\n\nReturns `{}` if content-type isnâ€™t JSON or parse fails.\n\n```ts\nconst data = await ctx.req.json();\nconsole.log(data.username); // \"john\"\n```\n\n---\n\n### `formData(): Promise<FormData>`\n\nParse request body as FormData (supports `application/x-www-form-urlencoded` and `multipart/form-data`).\n\n```ts\nconst form = await ctx.req.formData();\nconsole.log(form.get(\"name\"));    // \"John\"\nconsole.log(form.getAll(\"skills\")); // [\"js\", \"ts\"]\n```\n\n---\n\n### âœ… `useFormData<T extends Record<string, string | File | (string | File)[]>>(ctx: Context, options?:FormDataOptions): Promise<T>`\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nimport { useFormData } from \"tezx/helper\";\nconst data = await useFormData<{ name: string; file: File }>(ctx);\ndata.name; // \"Rakib\"\ndata.file; // File object\n```\n\n---\n"
    },
    {
      "id": 19,
      "path": "api/response/response",
      "name": "Response",
      "folder": "API/Response",
      "content": "# ğŸ” **Response Handling in TezX**\n\nThe TezX framework provides a rich and extensible response system through the `ctx` object. This system supports typed utilities for sending structured responses, including JSON, HTML, plain text, file downloads, redirects, and more.\n\n---\n\n## ğŸ§© **Core Type Definitions**\n\n```ts\n/**\n * Callback to continue the middleware chain.\n */\nexport type NextCallback = () => Promise<void>;\n\n/**\n * A valid return type from any route handler or middleware.\n */\nexport type HttpBaseResponse = Response | Promise<Response>;\n\n/**\n * Context object passed to routes/middleware.\n * @template T - Extended application state.\n * @template Path - Typed path string.\n */\nexport type Ctx<T extends Record<string, any> = {}, Path extends string = any> =\n  Context<T, Path> & T & Record<string, any>;\n\n/**\n * Route callback signature.\n */\nexport type Callback<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>) => HttpBaseResponse;\n\n/**\n * TezX middleware function signature.\n */\nexport type Middleware<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>, next: NextCallback) =>\n    HttpBaseResponse | Promise<HttpBaseResponse | void> | NextCallback;\n\n/**\n * Error-handling callback.\n */\nexport type ErrorHandler<T = {}> =\n  (err: Error, ctx: Ctx<T>) => HttpBaseResponse;\n```\n\n---\n\n## âœ… **Custom Response (Native Response Object)**\n\nFor full control, return a native `Response` directly:\n\n```ts\napp.get(\"/data\", (ctx) => {\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: { \"Content-Type\": \"text/plain\" },\n  });\n});\n```\n\n---\n\n## ğŸš€ **Response Utilities on `ctx`**\n\n### `ctx.json(body, status?, headers?)`\n\nSends a JSON response.\n\n```ts\napp.get(\"/json\", (ctx) => {\n  return ctx.json({ success: true }, 200);\n});\n```\n\n* **Content-Type**: `application/json`\n* **Returns**: `Response`\n\n---\n\n### `ctx.html(html, status?, headers?)`\n\nReturns an HTML response.\n\n```ts\napp.get(\"/html\", (ctx) => {\n  return ctx.html(\"<h1>Welcome</h1>\");\n});\n```\n\n* **Content-Type**: `text/html`\n\n---\n\n### `ctx.text(text, status?, headers?)`\n\nReturns plain text.\n\n```ts\napp.get(\"/plain\", (ctx) => {\n  return ctx.text(\"Just a plain message.\");\n});\n```\n\n* **Content-Type**: `text/plain`\n\n---\n\n### `ctx.xml(xml, status?, headers?)`\n\nSends XML content.\n\n```ts\napp.get(\"/xml\", (ctx) => {\n  return ctx.xml(\"<note><msg>Hi</msg></note>\");\n});\n```\n\n* **Content-Type**: `application/xml`\n\n---\n\n### `ctx.send(body, status?, headers?)`\n\nSmart responder. Infers content type:\n\n```ts\napp.get(\"/send\", (ctx) => {\n  return ctx.send({ user: \"admin\" });\n});\n```\n\n* **Content-Type** inferred from `body` type:\n\n  * `object` â†’ `application/json`\n  * `string` â†’ `text/plain`\n  * `Buffer`/`Uint8Array` â†’ `application/octet-stream`\n\n---\n\n### `ctx.redirect(url, status?, headers?)`\n\nRedirects to a target URL.\n\n```ts\napp.get(\"/go\", (ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n```\n\n* **Default Status**: `302`\n* **Header**: `Location`\n\n---\n\n### `ctx.download(filePath, fileName)`\n\nTriggers a file download with a custom file name.\n\n```ts\napp.get(\"/download\", (ctx) => {\n  return ctx.download(\"/files/report.pdf\", \"Monthly-Report.pdf\");\n});\n```\n\n* **Header**: `Content-Disposition: attachment`\n\n---\n\n### `ctx.sendFile(filePath, fileName?)`\n\nServes a static file directly.\n\n```ts\napp.get(\"/image\", (ctx) => {\n  return ctx.sendFile(\"/assets/banner.jpg\");\n});\n```\n\n* Automatically sets `Content-Type` and streams file.\n* Optional custom file name.\n\n---\n\n## ğŸ› ï¸ Best Practices\n\n| Use Case                | Recommended Method |\n| ----------------------- | ------------------ |\n| JSON API response       | `ctx.json()`       |\n| HTML rendering          | `ctx.html()`       |\n| Serving static assets   | `ctx.sendFile()`   |\n| Secure file download    | `ctx.download()`   |\n| External redirects      | `ctx.redirect()`   |\n| Manual response control | Native `Response`  |\n\n---\n"
    },
    {
      "id": 20,
      "path": "middleware/-logger",
      "name": "Logger",
      "folder": "Middleware",
      "content": "# ğŸ“˜ Logger Middleware â€” `@tezx/logger`\n\n## ğŸ§© Overview\n\nThe `logger` middleware provides structured, real-time logging of HTTP requests and responses for applications built with the TezX framework. It captures request lifecycle data, including method, path, status code, and response time, and prints them in a color-coded format to enhance debugging and monitoring.\n\n---\n\n## âœ… Key Features\n\n* ğŸ“¥ Logs every incoming HTTP request with method and path.\n* â± Measures and logs the execution time for each request.\n* ğŸ¯ Displays status codes and response completion details.\n* âš ï¸ Gracefully handles and logs runtime errors in middleware or handlers.\n* ğŸ¨ Color-coded output for enhanced readability (method, status, errors).\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nbun add tezx\n```\n\n*Or if already using `tezx`, it's built-in.*\n\n---\n\n## ğŸš€ Usage\n\n### 1. Import the Middleware\n\n```ts\nimport { logger } from \"tezx/logger\";\n```\n\n### 2. Apply to Your App\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/logger\";\n\nconst app = new TezX();\napp.use(logger());\n```\n\nOr inside a `createApp` bootstrap function:\n\n```ts\nexport function createApp() {\n  const app = new TezX();\n  app.use(logger());\n  return app;\n}\n```\n\n---\n\n## âš™ï¸ Middleware Behavior\n\n### Lifecycle\n\n1. Logs: `--> METHOD PATH` when a request starts.\n2. Tracks start time with `performance.now()`.\n3. Waits for `await next()` to execute downstream logic.\n4. After response: calculates duration and logs:\n\n   ```\n   <-- METHOD PATH STATUS_CODE TIMEms\n   ```\n\n5. On error: logs the error stack in red and rethrows it.\n\n---\n\n## ğŸ§ª Example Output\n\n```bash\n--> GET /api/list\n<-- GET /api/list 200 22.63ms\n\n--> POST /auth/login\n<-- POST /auth/login 401 13.71ms\n\n--> GET /unknown\n<-- GET /unknown 404 5.02ms\n\n[x] Error: Invalid JSON\n```\n\n---\n\n## ğŸ§± Middleware Return Signature\n\n```ts\nfunction logger(): Middleware;\n```\n\nReturns a `Middleware` function compatible with `.use()` or `addRoute()`.\n\n---\n\n## ğŸ“¦ Integration Example with Full TezX Setup\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/logger\";\nimport { CustomRouter } from \"./router\";\n\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),\n  debugMode: true,\n});\n\napp.use(logger());\n```\n\nYou can also attach it to all methods using `addRoute`:\n\n```ts\napp.addRoute({\n  method: \"ALL\",\n  path: \"*\",\n  handler: logger(),\n});\n```\n\n---\n\n## ğŸ›¡ Error Handling\n\nIf any unhandled exception is thrown inside a middleware or route handler, `logger()`:\n\n* Logs the stack trace in red (highlighted).\n* Preserves stack for higher-level error middleware.\n* Does not interfere with downstream error catchers.\n\n---\n\n## ğŸ“„ Related\n\n* `@tezx/core` â€” core HTTP server utilities.\n* `@tezx/router` â€” custom route registry support.\n* `@tezx/middleware` â€” more built-in middleware (e.g., CORS, compression, JSON parser).\n\n---\n"
    },
    {
      "id": 21,
      "path": "middleware/basic-auth",
      "name": "Basic Auth",
      "folder": "Middleware",
      "content": "\n# `basicAuth` Middleware\n\n## Overview\n\n`basicAuth` is a flexible authentication middleware supporting multiple methods:\n\n* **Basic Authentication**\n* **Bearer Token**\n* **API Key**\n\nIt also supports:\n\n* Rate limiting (optional)\n* Role-Based Access Control (RBAC) checks (optional)\n* Custom unauthorized handlers\n* Dynamic realm name generation\n\n---\n\n## Usage\n\n### Basic Setup\n\n```ts\nimport {basicAuth} from \"tezx/basic-auth\";\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      // Implement your validation logic per method and credentials here\n      // Return true if valid, false otherwise\n    },\n  })\n);\n```\n\n### Optional Configurations\n\n```ts\nbasicAuth({\n  validateCredentials,\n  \n  // Customize the HTTP Basic auth realm shown on prompt (default: \"Restricted Area\")\n  getRealm: (ctx) => \"My Protected API\",\n\n  // Customize response for unauthorized access\n  onUnauthorized: (ctx, error) => {\n    ctx.setStatus = 401;\n    ctx.setHeader(\"WWW-Authenticate\", `Basic realm=\"${getRealm(ctx)}\"`);\n    ctx.body = { error: error?.message || \"Unauthorized\" };\n  },\n\n  // Rate limiting configuration (optional)\n  rateLimit: {\n    maxRequests: 100,\n    windowMs: 60000,\n    // Optional: Provide custom storage; default storage created if omitted\n    // storage: customStorage,\n  },\n\n  // Supported methods to accept (default: all three)\n  supportedMethods: [\"basic\", \"api-key\", \"bearer-token\"],\n\n  // Optional RBAC check for access control\n  checkAccess: async (ctx, credentials) => {\n    // Return true if user is authorized, false otherwise\n  },\n});\n```\n\n---\n\n## Important Notes\n\n### 1. Node.js Buffer Requirement\n\n* For Node.js, the middleware uses:\n\n  ```ts\n  import { Buffer } from \"node:buffer\";\n  ```\n\n* This is necessary to decode Base64 Basic Auth credentials.\n\n### 2. Rate Limiting Requires `getConnInfo`\n\n* To enable rate limiting, you **must** add the `getConnInfo` middleware **before** `basicAuth`.\n\n* This middleware populates `ctx.req.remoteAddress` which `basicAuth` uses to track IPs for rate limiting.\n\nExample:\n\n```ts\nimport { getConnInfo } from \"tezx/bun\";\n// or\nimport { getConnInfo } from \"tezx/deno\";\n// or\nimport { getConnInfo } from \"tezx/node\";\n\napp.use(getConnInfo());\napp.use(\n  basicAuth({\n    rateLimit: {\n      maxRequests: 50,\n      windowMs: 60000,\n    },\n    validateCredentials,\n  }),\n);\n```\n\n---\n\n## TypeScript Types\n\n```ts\nexport type AuthMethod = \"basic\" | \"api-key\" | \"bearer-token\";\n\nexport type AuthCredential = {\n  username?: any;\n  password?: any;\n  token?: any;\n  apiKey?: any;\n};\n\nexport type DynamicBasicAuthOptions = {\n  validateCredentials: (\n    method: AuthMethod,\n    credentials: AuthCredential,\n    ctx: Context,\n  ) => boolean | Promise<boolean>;\n\n  getRealm?: (ctx: Context) => string;\n\n  onUnauthorized?: (ctx: Context, error?: Error) => HttpBaseResponse;\n\n  rateLimit?: {\n    storage?: {\n      get: (key: string) => { count: number; resetTime: number } | undefined;\n      set: (key: string, value: { count: number; resetTime: number }) => void;\n      clearExpired: () => void;\n    };\n    maxRequests: number;\n    windowMs: number;\n  };\n\n  supportedMethods?: AuthMethod[];\n\n  checkAccess?: (\n    ctx: Context,\n    credentials: AuthCredential,\n  ) => boolean | Promise<boolean>;\n};\n```\n\n---\n\n## Summary\n\n| Feature                     | Notes                                                   |\n| --------------------------- | ------------------------------------------------------- |\n| Basic Auth                  | Decodes Base64 credentials using `Buffer`               |\n| Bearer Token & API Key      | Reads from `Authorization` header or `x-api-key` header |\n| Rate Limiting               | Requires `injectRemoteAddress` middleware               |\n| Custom Unauthorized Handler | Use `onUnauthorized` option                             |\n| RBAC                        | Use `checkAccess` option for access control             |\n"
    },
    {
      "id": 22,
      "path": "middleware/cors",
      "name": "CORS",
      "folder": "Middleware",
      "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```ts\nimport { cors } from \"tezx/cors\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```ts\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```ts\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```ts\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```bash\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```bash\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```ts\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```ts\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```ts\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```ts\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```ts\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n```ts\n// âŒ Avoid in production\ncors({ origin: \"*\" });\n// âœ… Secure setup\ncors({ origin: process.env.ALLOWED_ORIGINS });\n```\n\n2. **Limit Exposed Headers**\n\n```ts\ncors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n```\n\n3. **Use Credentials Judiciously**\n\n```ts\ncors({ credentials: true }); // Enable only when required\n```\n\n4. **Pair with Rate Limiting**\n\n```ts\napp.use(rateLimiter());\napp.use(cors());\n```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```ts\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```ts\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```bash\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```ts\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```ts\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```ts\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```ts\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```ts\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n```ts\n   // âŒ Vulnerable\n   /example\\.com/\n   // âœ… Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n```\n\n2. **Escape Characters**\n\n```ts\nconst domain = \"special.domain.com\";\nconst escaped = domain.replace(/\\./g, \"\\\\.\");\nnew RegExp(`^https://${escaped}$`);\n```\n\n3. **Use Allow Lists**\n\n```ts\nconst allowed = loadFromDB();\ncors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```ts\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.req.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
    },
    {
      "id": 23,
      "path": "middleware/cache-control",
      "name": "Cache Control",
      "folder": "Middleware",
      "content": "# ğŸ§Š `cacheControl` Middleware\n\n## ğŸ“˜ Overview\n\nThe `cacheControl` middleware manages HTTP caching headers intelligently, improving performance and reducing unnecessary server load. It supports fine-grained control over client and intermediary caching behavior.\n\n---\n\n## âœ¨ Key Features\n\n* ğŸ”§ Dynamic `Cache-Control` headers (`max-age`, `public`/`private`)\n* ğŸ“… Sets accurate `Expires` headers\n* â™»ï¸ Supports the `Vary` header for smart client-side caching\n* ğŸ” Generates ETags (strong or weak) and handles `If-None-Match`\n* ğŸ“‰ Automatically returns `304 Not Modified` if ETag matches\n* ğŸ§  Rule-based configuration per request path/context\n* ğŸ“¢ Customizable event logging for cache hits/misses/errors\n\n---\n\n## ğŸ“¦ Installation\n\n```ts\nimport { cacheControl } from \"tezx/cache-control\";\n```\n\n> âš ï¸ Requires **Node.js**, as it uses `node:crypto` for hashing.\n\n---\n\n## âš™ï¸ Configuration\n\n### Middleware Initialization\n\n```ts\napp.use(cacheControl({\n  defaultSettings: {\n    maxAge: 120,\n    scope: \"public\",\n    enableETag: true,\n    vary: [\"Accept-Encoding\"]\n  },\n  useWeakETag: true,\n  rules: [...],\n  logEvent: (event, ctx, error) => {\n    if (event === \"error\") {\n      console.error(`[CACHE ERROR] ${error?.message}`);\n    } else {\n      console.log(`[CACHE ${event.toUpperCase()}] ${ctx.method} ${ctx.pathname}`);\n    }\n  },\n}));\n```\n\n---\n\n## ğŸ”§ Options\n\n| Option            | Type                                      | Description                                                            |\n| ----------------- | ----------------------------------------- | ---------------------------------------------------------------------- |\n| `defaultSettings` | `CacheSettings` (required)                | Fallback cache behavior if no rule matches.                            |\n| `rules`           | `CacheRule[]` (optional)                  | Conditional caching rules per request.                                 |\n| `useWeakETag`     | `boolean` (optional)                      | Generate weak ETags (`W/`) instead of strong ones.                     |\n| `logEvent`        | `(event, ctx, error?) => void` (optional) | Logs events: `\"cached\"`, `\"no-cache\"`, or `\"error\"` during processing. |\n\n---\n\n## ğŸ“˜ `CacheRule` Type\n\n```ts\ntype CacheRule = {\n  condition: (ctx: Context) => boolean;\n  maxAge: number;\n  scope: \"public\" | \"private\";\n  enableETag: boolean;\n  vary?: string[];\n};\n```\n\n> First matching rule is applied.\n\n---\n\n## ğŸ§ª Usage Examples\n\n### Basic Setup with Default Caching\n\n```ts\ncacheControl({\n  defaultSettings: {\n    maxAge: 60, // 1 minute\n    scope: \"public\",\n    enableETag: true,\n  }\n});\n```\n\n### Advanced with Rules\n\n```ts\ncacheControl({\n  defaultSettings: {\n    maxAge: 120,\n    scope: \"public\",\n    enableETag: true,\n    vary: [\"Accept-Encoding\"]\n  },\n  rules: [\n    {\n      condition: ctx => ctx.pathname.startsWith(\"/api/private\"),\n      maxAge: 0,\n      scope: \"private\",\n      enableETag: false\n    },\n    {\n      condition: ctx => ctx.pathname.startsWith(\"/static\"),\n      maxAge: 86400,\n      scope: \"public\",\n      enableETag: true,\n      vary: [\"Accept-Encoding\"]\n    }\n  ]\n});\n```\n\n---\n\n## âš™ï¸ How It Works\n\n1. **Request Type Check**\n\n   * Only processes `GET` and `HEAD` methods.\n   * Others bypass cache logic.\n\n2. **Rule Evaluation**\n\n   * Scans `rules` and applies the first match.\n   * If none, uses `defaultSettings`.\n\n3. **Header Generation**\n\n   * `Cache-Control`: Based on `maxAge` and `scope`.\n   * `Expires`: Based on current time + `maxAge`.\n   * `Vary`: If provided.\n\n4. **ETag Handling**\n\n   * Generates hash of the response body.\n   * Compares against `If-None-Match`.\n   * Returns `304 Not Modified` if matched.\n\n5. **Logging**\n\n   * Calls `logEvent` if provided.\n\n---\n\n## âš ï¸ Limitations & Notes\n\n* **Node.js only**: Uses `crypto` for hashing.\n* **GET/HEAD only**: Avoids side effects on other methods.\n* **Performance tip**: Avoid ETag on large dynamic responses to reduce hash load.\n* **ETag is generated post-body**: Middleware must run after body is set.\n\n---\n\n## ğŸš¨ Error Handling\n\nIf an error occurs (e.g., during hashing):\n\n* Logs using `logEvent` with type `\"error\"`.\n* Responds with `500 Internal Server Error` and JSON:\n\n```json\n{ \"error\": \"Failed to set cache headers.\" }\n```\n\n---\n\n## ğŸ“‹ Summary Table\n\n| Feature             | Support                        |\n| ------------------- | ------------------------------ |\n| Cache-Control       | âœ… Dynamic max-age + scope      |\n| Expires             | âœ… Set with `Date.now + maxAge` |\n| ETag                | âœ… Strong & weak supported      |\n| Conditional Request | âœ… Returns 304 when matched     |\n| Vary Header         | âœ… Optional per rule            |\n| Rules Support       | âœ… Context-aware strategy       |\n| Logging             | âœ… Via `logEvent()`             |\n| Platform            | â— Node.js required             |\n\n---\n"
    },
    {
      "id": 24,
      "path": "middleware/detect-locale",
      "name": "Detect Locale",
      "folder": "Middleware",
      "content": "\n# `detectLocale` Middleware\n\n## Overview\n\nThe `detectLocale` middleware detects and sets a userâ€™s preferred locale in web applications. It supports detection via query parameters, cookies, `Accept-Language` headers, and custom logic. The detected locale is attached to the request context, enabling localized responses downstream.\n\nBuilt with TypeScript, it works seamlessly across Node.js, Bun, and Deno runtimes.\n\n---\n\n## Configuration Options\n\n| Option                 | Type                                    | Description                                                       | Default    | Required |\n| ---------------------- | --------------------------------------- | ----------------------------------------------------------------- | ---------- | -------- |\n| `supportedLocales`     | `string[]`                              | Allowed locale codes (e.g., `[\"en\", \"fr\", \"bn\"]`).                | â€”          | Yes      |\n| `defaultLocale`        | `string`                                | Fallback locale if detection fails.                               | `\"en\"`     | No       |\n| `queryKeyLocale`       | `string`                                | Query parameter key for locale (e.g., `lang` in `/?lang=fr`).     | `\"lang\"`   | No       |\n| `cookieKeyLocale`      | `string`                                | Cookie name storing locale preference.                            | `\"locale\"` | No       |\n| `localeContextKey`     | `string`                                | Context key where detected locale is stored (e.g., `ctx.locale`). | `\"locale\"` | No       |\n| `customLocaleDetector` | `(ctx: Context) => string \\| undefined` | Custom function for programmatic locale detection.                | â€”          | No       |\n\n---\n\n## Middleware Detection Workflow\n\n1. **Query Parameter:** Checks for locale in the query string and validates against `supportedLocales`.\n2. **Cookie:** Looks for locale cookie, validating the value.\n3. **Accept-Language Header:** Parses and selects the first matching locale from the header.\n4. **Custom Detector:** If provided, invokes the custom function for locale detection.\n5. **Fallback:** Defaults to `defaultLocale` if no valid locale is found.\n\nFinally, the detected locale is assigned to `ctx[localeContextKey]`, and the middleware proceeds by calling `next()`.\n\n---\n\n## Usage Examples\n\n### 1. Query Parameter Detection\n\n```ts\nimport { detectLocale } from \"tezx/detect-locale\";\n\napp.get(\n  \"/welcome\",\n  detectLocale({ supportedLocales: [\"en\", \"fr\", \"bn\"], queryKeyLocale: \"lang\" }),\n  (ctx) => {\n    return ctx.json({\n      message: {\n        en: \"Welcome!\",\n        fr: \"Bienvenue !\",\n        bn: \"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!\",\n      }[ctx.locale],\n    });\n  }\n);\n```\n\n---\n\n### 2. Cookie-Based Detection\n\n```ts\napp.get(\n  \"/welcome\",\n  detectLocale({ supportedLocales: [\"en\", \"fr\", \"bn\"], cookieKeyLocale: \"locale\" }),\n  (ctx) => {\n    return ctx.json({ message: { en: \"Welcome!\", fr: \"Bienvenue !\", bn: \"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!\" }[ctx.locale] });\n  }\n);\n```\n\n---\n\n### 3. Accept-Language Header Detection\n\n```ts\napp.get(\n  \"/welcome\",\n  detectLocale({ supportedLocales: [\"en\", \"fr\", \"bn\"] }),\n  (ctx) => {\n    return ctx.json({ message: { en: \"Welcome!\", fr: \"Bienvenue !\", bn: \"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!\" }[ctx.locale] });\n  }\n);\n```\n\n---\n\n### 4. Custom Locale Detector\n\n```ts\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  customLocaleDetector: (ctx) => {\n    const userId = ctx.req.headers.get(\"x-user-id\");\n    const userLocales = { user123: \"bn\" };\n    return userLocales[userId] || undefined;\n  },\n});\n```\n\n---\n\n### 5. Default Locale Fallback\n\n```ts\ndetectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"fr\",\n});\n```\n\n---\n\n### 6. Custom Context Key and Combining All\n\n```ts\ndetectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"en\",\n  queryKeyLocale: \"language\",\n  cookieKeyLocale: \"user_locale\",\n  localeContextKey: \"userLocale\",\n  customLocaleDetector: (ctx) => {\n    // Your logic here\n  },\n});\n```\n\n---\n\n## Best Practices\n\n* Ensure `supportedLocales` covers all locales your app supports.\n* Use consistent and clear names for keys (`queryKeyLocale`, `cookieKeyLocale`, `localeContextKey`).\n* Implement `customLocaleDetector` for complex scenarios like DB lookups or geolocation.\n* Enable logging/debugging during development to troubleshoot detection.\n* Secure cookies storing locale preferences (HTTP-only, Secure flags).\n* Handle malformed or complex `Accept-Language` headers gracefully.\n\n---\n\n## Error Handling and Robustness\n\n* Unsupported or invalid query param and cookie values are ignored.\n* Malformed `Accept-Language` headers are safely filtered.\n* Invalid results from custom detectors fall back to `defaultLocale`.\n* Always guarantees a valid locale is set in context.\n\n---\n\n## Type Definitions\n\n```ts\ntype DetectLocaleOptions = {\n  supportedLocales: string[];\n  defaultLocale?: string;\n  queryKeyLocale?: string;\n  cookieKeyLocale?: string;\n  localeContextKey?: string;\n  customLocaleDetector?: (ctx: Context) => string | undefined;\n};\n\ndeclare function detectLocale(options: DetectLocaleOptions): Middleware;\n```\n\n---\n"
    },
    {
      "id": 25,
      "path": "middleware/detect-bot",
      "name": "Detect bot",
      "folder": "Middleware",
      "content": "# DetectBot Middleware\n\n`detectBot` is a powerful and extensible middleware designed to detect and handle bot traffic in your web applications. It combines multiple detection techniques like User-Agent analysis, IP blacklisting, query parameter flags, rate limiting, and custom logic to identify bots effectively.\n\n---\n\n## âš ï¸ Important Prerequisite: Use `getConnInfo()` Middleware First\n\nTo enable accurate IP detection (used for IP blacklisting and rate limiting), you **must** register the `getConnInfo()` middleware **before** `detectBot()`:\n\n```ts\nimport { getConnInfo } from \"tezx/node\"; // or \"tezx/bun\", \"tezx/deno\" depending on runtime\nimport { detectBot } from \"tezx/detect-bot\";\n\napp.use(getConnInfo()); // <-- Injects IP info into ctx.req.remoteAddress\napp.use(detectBot());\n```\n\nFailing to do so will cause IP-based detections to malfunction.\n\n---\n\n## Installation\n\n```bash\nnpm install tezx\n```\n\n---\n\n## Import\n\n```ts\nimport { detectBot } from \"tezx/detect-bot\";\nimport { getConnInfo } from \"tezx/node\"; // or bun / deno\n```\n\n---\n\n## Configuration Options\n\n| Option                  | Type                                                                          | Default Value                         | Description                                                            |\n| ----------------------- | ----------------------------------------------------------------------------- | ------------------------------------- | ---------------------------------------------------------------------- |\n| `botUserAgents`         | `string[]`                                                                    | `[\"bot\", \"spider\", \"crawl\", \"slurp\"]` | User-Agent substrings to detect bots                                   |\n| `maxRequests`           | `number`                                                                      | `30`                                  | Max requests allowed within the rate-limit window                      |\n| `windowMs`              | `number`                                                                      | `60000` (1 minute)                    | Rate limit window duration in milliseconds                             |\n| `isBlacklisted`         | `(ctx: Context, ip: string) => boolean \\| Promise<boolean>`                   | `() => false`                         | Async check to determine if an IP is blacklisted                       |\n| `queryKeyBot`           | `string`                                                                      | `\"bot\"`                               | Query parameter key to flag bot traffic (e.g., `?bot=true`)            |\n| `onBotDetected`         | `\"block\" \\| ((ctx: Context, result: BotDetectionResult) => HttpBaseResponse)` | `\"block\"`                             | Action on bot detection: `\"block\"` or custom callback                  |\n| `enableRateLimiting`    | `boolean`                                                                     | `false`                               | Enable rate limiting-based bot detection                               |\n| `customBotDetector`     | `(ctx: Context) => boolean \\| Promise<boolean>`                               | `() => false`                         | Custom asynchronous function to detect bots                            |\n| `customBlockedResponse` | `(ctx: Context, result: BotDetectionResult) => HttpBaseResponse`              | Default 403 JSON error                | Custom response returned when bot is blocked                           |\n| `storage`               | Custom storage with `get/set/clearExpired` for rate limiting state            | In-memory Map                         | Custom storage implementation, e.g., Redis, for rate limit persistence |\n| `confidenceThreshold`   | `number` (0-1)                                                                | `0.5`                                 | Confidence threshold to mark as bot when multiple indicators are found |\n\n---\n\n## How It Works\n\n1. **User-Agent Check**\n   Scans the User-Agent header against common bot substrings.\n\n2. **IP Blacklist Check**\n   Checks if the client IP is blacklisted (customizable).\n\n3. **Query Parameter**\n   Detects bot traffic flagged by query params like `?bot=true`.\n\n4. **Rate Limiting**\n   Optionally tracks and limits requests per IP over a time window.\n\n5. **Custom Detection Logic**\n   Supports user-defined async functions for bespoke bot detection.\n\n6. **Confidence Score**\n   Combines multiple indicators to calculate a confidence score for nuanced detection.\n\n7. **Response Handling**\n   Blocks detected bots or triggers custom response handlers.\n\n---\n\n## Usage Examples\n\n### Basic Usage (Block bots by User-Agent)\n\n```ts\nimport { getConnInfo } from \"tezx/node\";\nimport { detectBot } from \"tezx/detect-bot\";\n\napp.use(getConnInfo());\napp.use(detectBot());\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, human!\");\n});\n```\n\n---\n\n### Advanced Usage with IP Blacklist and Rate Limiting\n\n```ts\napp.use(getConnInfo());\n\napp.use(\n  detectBot({\n    botUserAgents: [\"bot\", \"crawler\", \"spider\"],\n    maxRequests: 15,\n    windowMs: 60000,\n    enableRateLimiting: true,\n    isBlacklisted: async (ctx, ip) => {\n      const blacklist = [\"10.0.0.1\", \"192.168.0.5\"];\n      return blacklist.includes(ip);\n    },\n    customBotDetector: async (ctx) => !ctx.headers.get(\"referer\"),\n    onBotDetected: (ctx, { reason, indicators }) => {\n      ctx.setStatus = 403;\n      return ctx.json({ error: \"Bot blocked\", reason, indicators });\n    },\n  }),\n);\n```\n\n---\n\n### Using Redis for Distributed Rate Limiting\n\n```ts\nimport Redis from \"ioredis\";\n\nconst redis = new Redis();\n\nconst redisStorage = {\n  get: async (key) => {\n    const val = await redis.get(key);\n    return val ? JSON.parse(val) : undefined;\n  },\n  set: async (key, value) => {\n    await redis.set(key, JSON.stringify(value), \"PX\", value.resetTime - Date.now());\n  },\n  clearExpired: () => {}, // Redis handles expiration automatically\n};\n\napp.use(getConnInfo());\n\napp.use(\n  detectBot({\n    enableRateLimiting: true,\n    storage: redisStorage,\n    maxRequests: 50,\n    windowMs: 60000,\n  }),\n);\n```\n\n---\n\n## Best Practices\n\n* Always register `getConnInfo()` **before** `detectBot`.\n* Tune `maxRequests` and `windowMs` based on your app traffic patterns.\n* Use `customBotDetector` for domain-specific bot patterns.\n* Enable `GlobalConfig.debugging` to track bot detections during development.\n* For production or multiple server instances, use a distributed store (Redis, etc.) for rate limiting.\n\n---\n\n## Sample Bot Detection Response\n\n```json\n{\n  \"error\": \"Bot blocked\",\n  \"reason\": \"Multiple Indicators\",\n  \"indicators\": [\"User-Agent\", \"Blacklisted IP\", \"Query Parameter\"]\n}\n```\n\n---\n"
    },
    {
      "id": 26,
      "path": "middleware/lazy-loader",
      "name": "Lazy Loader",
      "folder": "Middleware",
      "content": "# `lazyLoader` Middleware\n\nThe `lazyLoader` middleware enables dynamic, lazy loading of modules in a `tezx` application based on route or query parameters. It supports caching, lifecycle hooks, and module validation to optimize performance and ensure reliability.\n\n## Overview\n\nThe `lazyLoader` middleware enables dynamic, lazy loading of modules in a `tezx/lazy-loader` application based on runtime parameters (e.g., query, route, or custom logic). It supports caching, lifecycle hooks, module validation, and an optional `init` function for module-specific initialization. The `init` function is a critical feature, allowing modules to perform asynchronous setup, validate prerequisites, or short-circuit the request lifecycle. This document provides a unified explanation of the `init` functionâ€™s work procedure, its integration with the middleware, and a consolidated example that incorporates the diverse use cases from four demos.\n\n### Key Features\n\n- **Dynamic Module Loading**: Load modules on-demand via configurable loaders.\n- **Caching**: Cache modules with customizable TTL and storage (e.g., `Map`, Redis).\n- **Lifecycle Hooks**: Execute custom logic at stages like load, cache hit, or error.\n- **Module Validation**: Ensure modules meet structural or behavioral criteria.\n- **Initialization via `init`**: Perform asynchronous setup or early responses per module.\n- **Flexible Module Identification**: Support query parameters, route parameters, or custom logic.\n\nImport the middleware and related types:\n\n```typescript\nimport { lazyLoader } from \"tezx/lazy-loader\";\n```\n\n### Type Definitions\n\n```typescript\nexport type LazyModuleLoader<T> = () => Promise<T>;\nexport interface CacheItem<T = any> {\n  module: T;\n  expiresAt: number;\n}\ninterface LazyLoadOptions<T> {\n  moduleKey?: (ctx: Context) => string;\n  getModuleLoader: (\n    ctx: Context,\n  ) => Promise<LazyModuleLoader<T> | null> | null | LazyModuleLoader<T>;\n  queryKeyModule?: string;\n  moduleContextKey?: string;\n  enableCache?: boolean;\n  cacheStorage?: {\n    get: (key: string) => CacheItem<T> | undefined;\n    set: (key: string, value: CacheItem<T>) => void;\n    delete: (key: string) => void;\n  };\n  cacheTTL?: number;\n  lifecycleHooks?: {\n    onLoad?: (moduleName: string, ctx: Context) => void;\n    onError?: (moduleName: string, error: Error, ctx: Context) => void;\n    onComplete?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheHit?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheSet?: (moduleName: string, module: T, ctx: Context) => void;\n  };\n  validateModule?: (module: T) => boolean;\n}\n```\n\n### Middleware Signature\n\n```typescript\nexport const lazyLoader = <T = any>(options: LazyLoadOptions<T>): Middleware;\n```\n\n---\n\n## Work Procedure of the `init` Function\n\n### Purpose\n\nThe `init` function is an optional, asynchronous method exported by a module to:\n\n- Perform setup tasks (e.g., initializing resources, fetching configurations).\n- Validate request-specific prerequisites (e.g., API keys, tokens).\n- Modify the `Context` object for downstream use.\n- Return early responses to short-circuit the middleware chain (e.g., errors, redirects).\n\n### Code Context\n\nThe `init` function is invoked in the middleware as follows:\n\n```typescript\nif (module.init && typeof module.init === \"function\") {\n  const initResult = await module.init(ctx);\n  if (initResult) {\n    return initResult;\n  }\n}\n```\n\n### Operational Workflow\n\nThe `init` function is processed within the middleware pipeline as follows:\n\n1. **Module Identification**:\n\n   - The middleware determines the module name using `moduleKey`, `queryKeyModule`, or route parameters.\n   - Example: `ctx.req.query.module` (Demo 1, 3), `ctx.req.params.module` (Demo 2), or `ctx.req.body.moduleName` (Demo 4).\n\n2. **Module Loading**:\n\n   - The `getModuleLoader` function returns a `LazyModuleLoader`, which dynamically imports the module.\n   - The loaded module is validated using `validateModule` (if provided).\n\n3. **init Function Detection**:\n\n   - The middleware checks if the module exports an `init` function (`module.init && typeof module.init === \"function\"`).\n   - If absent, the middleware skips to caching or context attachment.\n\n4. **init Invocation**:\n\n   - The `init` function is called with the `Context` object (`ctx`):\n\n     ```typescript\n     const initResult = await module.init(ctx);\n     ```\n\n   - The `Context` provides access to `req`, `res`, and custom properties, enabling request-specific logic.\n   - Asynchronous operations (e.g., database queries, API calls) are awaited.\n\n5. **Result Processing**:\n\n   - **Truthy Result**: If `initResult` is non-falsy (e.g., `{ error: \"Unauthorized\" }`), the middleware returns it, halting further processing (e.g., no caching, no `next`).\n   - **Falsy Result**: If `initResult` is `null`, `undefined`, or absent, the middleware continues.\n   - The `Context` may be modified (e.g., `ctx.config = {...}`) for use by the module or downstream middleware.\n\n6. **Post-Initialization**:\n\n   - The module is cached (if `enableCache` is true) with the specified `cacheTTL`.\n   - The module is attached to the context (`ctx[moduleContextKey] = module`).\n   - The `onComplete` lifecycle hook is triggered.\n   - The middleware proceeds to `await next()`.\n\n7. **Error Handling**:\n   - Errors thrown by `init` are caught in the middlewareâ€™s `try-catch` block.\n   - The `onError` hook is invoked, and the response status is set to 500 (`ctx.setStatus = 500`).\n   - The error is re-thrown for upstream handling.\n\n### Integration Points\n\n- **Before `init`**: Module loading and validation ensure the module is valid.\n- **During `init`**: The function performs setup, validation, or early responses.\n- **After `init`**: Caching, context attachment, and lifecycle hooks complete the cycle.\n- **Short-Circuiting**: A truthy `initResult` bypasses caching, context attachment, and `next`.\n\n---\n\n#### `LazyLoadOptions<T>`\n\nConfiguration options for the `lazyLoader` middleware.\n\n| Property           | Description                                               | Default                                                                      |\n| ------------------ | --------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| `moduleKey`        | Function to extract the module name from the context.     | `(ctx) => ctx.req.params[queryKeyModule] \\|\\| ctx.req.query[queryKeyModule]` |\n| `getModuleLoader`  | Function to retrieve the module loader.                   | Required                                                                     |\n| `queryKeyModule`   | Query parameter name to select the module.                | `\"module\"`                                                                   |\n| `moduleContextKey` | Key to attach the loaded module to the context.           | `\"module\"`                                                                   |\n| `enableCache`      | Enable caching of loaded modules.                         | `true`                                                                       |\n| `cacheStorage`     | Custom cache storage implementation.                      | `Map<string, CacheItem<T>>`                                                  |\n| `cacheTTL`         | Cache Time-To-Live (TTL) in milliseconds.                 | `3600000` (1 hour)                                                           |\n| `lifecycleHooks`   | Lifecycle hooks for custom actions during module loading. | `{}`                                                                         |\n| `validateModule`   | Function to validate the loaded module.                   | `undefined`                                                                  |\n\n---\n\n## Consolidated Example: Unified Production-Ready Application\n\nThis example combines features from all four demos:\n\n- **Query-based loading** (Demo 1).\n- **Route-based loading** (Demo 2).\n- **Async `init` function** (Demo 3).\n- **Custom module key with validation** (Demo 4).\n\nIt demonstrates a production-ready setup with robust error handling, caching, lifecycle hooks, and a complex `init` function.\n\n### File Structure\n\n```bash\nproject/\nâ”œâ”€â”€ modules/\nâ”‚   â”œâ”€â”€ dashboard.js\nâ”‚   â”œâ”€â”€ orders.js\nâ”‚   â”œâ”€â”€ auth.js\nâ”‚   â”œâ”€â”€ report.js\nâ””â”€â”€ server.js\n```\n\n### Code\n\n**`server.js`**:\n\n```typescript\nimport { Context } from \"tezx\";\nimport { lazyLoader, CacheItem } from \"tezx/lazy-loader\";\n\n// Custom cache storage\nconst customCache = new Map<string, CacheItem>();\nconst cacheStorage = {\n  get: (key: string) => customCache.get(key),\n  set: (key: string, value: CacheItem) => customCache.set(key, value),\n  delete: (key: string) => customCache.delete(key),\n};\n\n// Module loader map\nconst moduleLoaders: Record<string, () => Promise<any>> = {\n  dashboard: () => import(\"./modules/dashboard.js\"),\n  orders: () => import(\"./modules/orders.js\"),\n  auth: () => import(\"./modules/auth.js\"),\n  report: () => import(\"./modules/report.js\"),\n};\n\n// Middleware configuration\nconst lazyLoadMiddleware = lazyLoader({\n  moduleKey: (ctx: Context) => {\n    // Prioritize body, then query, then params\n    return (\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module\n    );\n  },\n  getModuleLoader: async (ctx: Context) => {\n    const moduleName =\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module;\n    return moduleLoaders[moduleName] || null;\n  },\n  queryKeyModule: \"module\",\n  moduleContextKey: \"loadedModule\",\n  enableCache: true,\n  cacheTTL: 120000, // 2 minutes\n  cacheStorage,\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) =>\n      console.log(\n        `Loading ${moduleName} for request ID: ${ctx.req.id || \"unknown\"}`,\n      ),\n    onCacheHit: (moduleName, module, ctx) =>\n      console.log(`Cache hit for ${moduleName}`),\n    onCacheSet: (moduleName, module, ctx) =>\n      console.log(`Cached ${moduleName}`),\n    onComplete: (moduleName, module, ctx) =>\n      console.log(`Completed loading ${moduleName}`),\n    onError: (moduleName, error, ctx) =>\n      console.error(`Error in ${moduleName}: ${error.message}`),\n  },\n  validateModule: (module) => {\n    // Require handler function and version property\n    return (\n      typeof module.handler === \"function\" && typeof module.version === \"string\"\n    );\n  },\n});\n\n// Create Tezx app\napp.use(lazyLoadMiddleware);\n\n// Routes\napp.get(\"/api/query\", async (ctx: Context) => {\n  // Query-based (Demo 1, 3)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.get(\"/api/route/:module\", async (ctx: Context) => {\n  // Route-based (Demo 2)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.post(\"/api/body\", async (ctx: Context) => {\n  // Body-based (Demo 4)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 400;\n  return { error: \"Invalid or missing module\" };\n});\n```\n\n**`modules/dashboard.js`** (Demo 1-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Dashboard module\",\n  data: { widgets: [\"chart\", \"table\"] },\n});\n```\n\n**`modules/orders.js`** (Demo 2-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Orders module\",\n  data: { orderId: ctx.req.query.orderId || 123 },\n});\n```\n\n**`modules/auth.js`** (Demo 3-inspired, with complex `init`):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  const apiKey = ctx.req.headers[\"x-api-key\"];\n  if (!apiKey) {\n    return {\n      status: 401,\n      error: \"API key required\",\n    };\n  }\n  try {\n    // Simulate async config fetch\n    const config = await fetchConfig(apiKey);\n    ctx.authConfig = config; // Attach to context\n    return null;\n  } catch (error) {\n    return {\n      status: 500,\n      error: `Auth initialization failed: ${error.message}`,\n    };\n  }\n};\nexport const handler = (ctx) => ({\n  message: \"Auth module\",\n  data: { token: \"abc123\", config: ctx.authConfig },\n});\n\n// Simulated async function\nasync function fetchConfig(apiKey) {\n  return { apiKey, settings: { scope: \"user\" } };\n}\n```\n\n**`modules/report.js`** (Demo 4-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  return null;\n};\nexport const handler = (ctx) => ({\n  message: \"Report module\",\n  data: { type: ctx.req.body?.reportType || \"sales\" },\n});\n```\n\n### Example Features\n\n- **Unified Module Identification**: Supports query (`/api/query?module=...`), route (`/api/route/:module`), and body (`POST /api/body`) inputs.\n- **Robust `init` Function**: The `auth` module demonstrates a complex `init` with API key validation, async configuration fetch, and context modification.\n- **Custom Cache Storage**: Uses a `Map`-based cache with a 2-minute TTL.\n- **Strict Validation**: Ensures modules have a `handler` function and `version` property.\n- **Comprehensive Lifecycle Hooks**: Logs all stages (load, cache hit, cache set, complete, error).\n- **Error Handling**: Gracefully handles missing modules, validation failures, and `init` errors.\n\n---\n"
    },
    {
      "id": 27,
      "path": "middleware/pagination",
      "name": "Pagination",
      "folder": "Middleware",
      "content": "\n# ğŸ“„ PaginationHandler Middleware\n\nThe `paginationHandler` middleware simplifies adding pagination support to your web app. It parses query params, fetches paginated data dynamically, and enriches responses with useful metadata.\n\n---\n\n## Key Features\n\n* âœ… Parses and sanitizes pagination query parameters (`page` & `limit`).\n* âœ… Supports dynamic data fetching via customizable data source function.\n* âœ… Attaches detailed pagination metadata (`totalPages`, `hasNextPage`, etc.).\n* âœ… Configurable defaults, limits, and response keys.\n* âœ… Graceful error handling and input validation.\n\n---\n\n## Installation\n\n```ts\nimport { paginationHandler } from \"tezx/pagination\";\n```\n\n---\n\n## Configuration Options\n\n| Option          | Type                                                                                                             | Default     | Description                                                   |\n| --------------- | ---------------------------------------------------------------------------------------------------------------- | ----------- | ------------------------------------------------------------- |\n| `defaultPage`   | `number`                                                                                                         | `1`         | Default page number if none provided.                         |\n| `defaultLimit`  | `number`                                                                                                         | `10`        | Default items per page if none provided.                      |\n| `maxLimit`      | `number`                                                                                                         | `100`       | Maximum allowed items per page.                               |\n| `queryKeyPage`  | `string`                                                                                                         | `\"page\"`    | Query param name for page number.                             |\n| `queryKeyLimit` | `string`                                                                                                         | `\"limit\"`   | Query param name for items per page.                          |\n| `countKey`      | `string`                                                                                                         | `\"total\"`   | Key in response containing total item count.                  |\n| `dataKey`       | `string`                                                                                                         | `\"data\"`    | Key in response containing the data array.                    |\n| `getDataSource` | `(ctx: Context, pagination: { page: number; limit: number; offset: number }) => Promise<{ [key: string]: any }>` | `undefined` | Function to fetch paginated data and total count dynamically. |\n\n---\n\n## Usage Examples\n\n### Basic Usage: Parsing Pagination Params Only\n\n```ts\napp.use(paginationHandler());\n\napp.get(\"/users\", (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  return ctx.json({ message: `Page ${page}, Limit ${limit}, Offset ${offset}` });\n});\n```\n\n*Request*: `GET /users?page=2&limit=20`\n\n*Response*:\n\n```json\n{\n  \"message\": \"Page 2, Limit 20, Offset 20\"\n}\n```\n\n---\n\n### Advanced Usage: With Dynamic Data Source\n\n```ts\nasync function fetchProducts(ctx, { page, limit, offset }) {\n  const products = await Product.findAll({ offset, limit });\n  const total = await Product.count();\n  return { items: products, totalCount: total };\n}\n\napp.get(\n  \"/products\",\n  paginationHandler({\n    defaultPage: 1,\n    defaultLimit: 5,\n    maxLimit: 50,\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n    countKey: \"totalCount\",\n    dataKey: \"items\",\n    getDataSource: fetchProducts,\n  }),\n  (ctx) => ctx.json(ctx.body),\n);\n```\n\n*Request*: `GET /products?p=2&size=10`\n\n*Response*:\n\n```json\n{\n  \"items\": [ /* 10 products */ ],\n  \"totalCount\": 25,\n  \"pagination\": {\n    \"page\": 2,\n    \"limit\": 10,\n    \"totalItems\": 25,\n    \"totalPages\": 3,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": true,\n    \"nextPage\": 3,\n    \"prevPage\": 1\n  }\n}\n```\n\n---\n\n### Custom Response Keys\n\n```ts\nasync function fetchUsers(ctx, { page, limit, offset }) {\n  const users = await User.findAll({ offset, limit });\n  const total = await User.count();\n  return { records: users, count: total };\n}\n\napp.get(\n  \"/users\",\n  paginationHandler({\n    countKey: \"count\",\n    dataKey: \"records\",\n    getDataSource: fetchUsers,\n  }),\n);\n```\n\n---\n\n## How It Works\n\n1. Reads `page` and `limit` from query parameters (customizable keys).\n2. Sanitizes values: enforces minimum `page = 1`, and `limit <= maxLimit`.\n3. Calculates offset = `(page - 1) * limit`.\n4. Calls `getDataSource` (if provided) with pagination info.\n5. Attaches paginated data and metadata to `ctx.body`.\n\n---\n\n## Pagination Metadata Included\n\n* `page` â€” current page number\n* `limit` â€” items per page\n* `totalItems` â€” total number of items available\n* `totalPages` â€” total pages calculated\n* `hasNextPage` â€” boolean, if next page exists\n* `hasPrevPage` â€” boolean, if previous page exists\n* `nextPage` â€” next page number or `null`\n* `prevPage` â€” previous page number or `null`\n\n---\n\n## Error Handling\n\n* Invalid or missing `page`/`limit` query params default to configured defaults.\n* Limits are clamped to `maxLimit`.\n* Missing `getDataSource` means only pagination info is attached; data fetching is manual.\n\n---\n\n## Best Practices\n\n* Set sensible `maxLimit` to prevent excessive data loads.\n* Use database-level pagination (`OFFSET`/`LIMIT`) in `getDataSource` for performance.\n* Customize response keys to integrate with existing APIs.\n* Test edge cases such as empty datasets or out-of-range pages.\n\n---\n\n## Sample Output (Page 3 of 5 items per page, total 13 items)\n\n```json\n{\n  \"items\": [ /* last 3 items */ ],\n  \"totalCount\": 13,\n  \"pagination\": {\n    \"page\": 3,\n    \"limit\": 5,\n    \"totalItems\": 13,\n    \"totalPages\": 3,\n    \"hasNextPage\": false,\n    \"hasPrevPage\": true,\n    \"nextPage\": null,\n    \"prevPage\": 2\n  }\n}\n```\n\n---\n"
    },
    {
      "id": 28,
      "path": "middleware/powered-by",
      "name": "Powered By",
      "folder": "Middleware",
      "content": "# ğŸš€ PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware adds an `X-Powered-By` HTTP header to every response, indicating your server or framework name. Itâ€™s lightweight and allows optional customization of the header value.\n\n---\n\n## Features\n\n* Adds `X-Powered-By` header to all responses.\n* Optional custom server name (defaults to `\"TezX\"`).\n* Simple and efficient middleware for Express-like environments.\n\n---\n\n## Installation\n\nMake sure your app supports middleware (e.g., Express, Koa, TezX).\n\n---\n\n## Usage\n\n### Import\n\n```ts\nimport { poweredBy } from \"tezx/powered-by\";\n```\n\n### Apply Middleware\n\n```ts\napp.use(poweredBy());           // Sets header to \"TezX\"\napp.use(poweredBy(\"MyServer\")); // Sets header to \"MyServer\"\n```\n\n---\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string) => Middleware;\n```\n\n* **`serverName`** *(optional)* â€” Custom string for `X-Powered-By` header. Default: `\"TezX\"`\n\n---\n\n## How it works\n\n1. Middleware sets `X-Powered-By` header on the response.\n2. Uses provided `serverName` or `\"TezX\"` by default.\n3. Calls `next()` to continue request handling.\n\n---\n\n## Example Response Header\n\n```http\nX-Powered-By: MyServer\n```\n\n---\n\n## Notes\n\n* Add this middleware early in your stack to ensure the header is included.\n* Changing the header value can help with branding or obscure server details for security.\n\n---\n"
    },
    {
      "id": 29,
      "path": "middleware/rate-limiter",
      "name": "Rate Limiter",
      "folder": "Middleware",
      "content": "# Rate Limiting Middleware (`rateLimiter`)\n\nA robust, configurable middleware to throttle client requests and prevent abuse by limiting the number of requests per time window. Uses a sliding window strategy with in-memory storage by default (Redis support planned).\n\n---\n\n## âš ï¸ Important: Use `getConnInfo()` First\n\nTo detect client IPs correctly (`ctx.req.remoteAddress`), **always register `getConnInfo()` before `rateLimiter`**:\n\n```ts\nimport { getConnInfo } from \"tezx/node\"; // or \"tezx/bun\" / \"tezx/deno\"\nimport { rateLimiter } from \"tezx/middleware\";\n\napp.use(getConnInfo()); // REQUIRED for IP detection\napp.use(rateLimiter({ maxRequests: 100, windowMs: 60_000 }));\n```\n\n---\n\n## Installation\n\n```bash\nnpm install tezx\n```\n\nImport:\n\n```ts\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n---\n\n## Middleware Options (`RateLimiterOptions`)\n\n| Option         | Type                                           | Default              | Description                                                                    |\n| -------------- | ---------------------------------------------- | -------------------- | ------------------------------------------------------------------------------ |\n| `maxRequests`  | `number`                                       | **Required**         | Max requests allowed per client in the time window                             |\n| `windowMs`     | `number`                                       | **Required**         | Time window duration in milliseconds                                           |\n| `keyGenerator` | `(ctx: Context) => string`                     | Client IP and port   | Function to uniquely identify clients (e.g., user ID or IP)                    |\n| `storage`      | `{ get, set, clearExpired }`                   | In-memory Map        | Storage backend for tracking request counts (Redis support via custom storage) |\n| `onError`      | `(ctx, retryAfter, error) => HttpBaseResponse` | Sends 429 by default | Custom handler called when rate limit is exceeded                              |\n\n---\n\n## Usage Examples\n\n### Basic: Limit 100 requests per minute per IP\n\n```ts\nimport { getConnInfo } from \"tezx/node\";\nimport { rateLimiter } from \"tezx/middleware\";\n\napp.use(getConnInfo());\napp.use(rateLimiter({\n  maxRequests: 100,\n  windowMs: 60_000,\n}));\n```\n\n---\n\n### Custom client identification (e.g., user ID)\n\n```ts\napp.use(rateLimiter({\n  maxRequests: 10,\n  windowMs: 10_000,\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({\n      error: \"Too Many Requests\",\n      retryAfter: `${retryAfter} seconds`,\n    });\n  },\n}));\n```\n\n---\n\n### Using Redis for distributed rate limiting\n\n```ts\nimport Redis from \"ioredis\";\n\nconst redis = new Redis();\n\nconst redisStorage = {\n  get: async (key) => {\n    const val = await redis.get(key);\n    return val ? JSON.parse(val) : undefined;\n  },\n  set: async (key, value) => {\n    await redis.set(key, JSON.stringify(value), \"PX\", value.resetTime - Date.now());\n  },\n  clearExpired: () => {\n    // Redis auto-expires keys; no cleanup needed here\n  },\n};\n\napp.use(getConnInfo());\n\napp.use(rateLimiter({\n  maxRequests: 50,\n  windowMs: 60_000,\n  storage: redisStorage,\n}));\n```\n\n---\n\n## How It Works\n\n* Uses a **sliding window** algorithm counting requests per client key within `windowMs`.\n* Default client key is `ip:port` but customizable via `keyGenerator`.\n* Stores counts and reset times in a cache (default `Map` or custom storage).\n* On exceeding limits, responds with HTTP 429 and `Retry-After` header.\n* Adds these headers to every response:\n\n  * `X-RateLimit-Limit` â€” Max allowed requests\n  * `X-RateLimit-Remaining` â€” Remaining requests in current window\n  * `X-RateLimit-Reset` â€” Timestamp when window resets\n  * `Retry-After` â€” Seconds to wait before next allowed request (on 429)\n\n---\n\n## Best Practices\n\n* Always use `getConnInfo()` **before** `rateLimiter`.\n* Customize `keyGenerator` for authenticated users to rate limit by user ID.\n* Use a distributed storage backend (like Redis) for multi-instance deployments.\n* Adjust `maxRequests` and `windowMs` to fit your app's traffic and security needs.\n* Use stricter limits on sensitive endpoints (e.g., login).\n* Monitor and log rate limiting events to tune thresholds.\n\n---\n\n## Troubleshooting\n\n| Problem                   | Cause                                 | Solution                                  |\n| ------------------------- | ------------------------------------- | ----------------------------------------- |\n| Too many 429 responses    | Low `maxRequests` or short `windowMs` | Increase limits or widen window duration  |\n| Rate limiting not working | Missing `getConnInfo()` middleware    | Add `getConnInfo()` before `rateLimiter`  |\n| Growing memory usage      | Many unique keys in in-memory storage | Use Redis or periodically cleanup storage |\n| Unstable client keys      | Unstable/custom `keyGenerator` output | Ensure `keyGenerator` returns stable IDs  |\n\n---\n\n## Advanced: Different Limits by Route\n\n```ts\nconst apiLimiter = rateLimiter({ maxRequests: 100, windowMs: 15 * 60_000 });\nconst loginLimiter = rateLimiter({ maxRequests: 5, windowMs: 60_000 });\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/login\", loginLimiter);\n```\n\n---\n\n## Custom Error Handler Example\n\n```ts\napp.use(rateLimiter({\n  maxRequests: 100,\n  windowMs: 60_000,\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({\n      code: \"RATE_LIMITED\",\n      message: `Please wait ${retryAfter} seconds before retrying.`,\n      retryAfter,\n    });\n  },\n}));\n```\n\n---\n"
    },
    {
      "id": 30,
      "path": "middleware/request-id",
      "name": "Request ID",
      "folder": "Middleware",
      "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/request-id\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Adds the request ID to the response headers.\n4. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
    },
    {
      "id": 31,
      "path": "middleware/request-timeout",
      "name": "Request Timeout",
      "folder": "Middleware",
      "content": "# ğŸ•’ `requestTimeout` Middleware\n\nEnforce dynamic, per-request timeouts in your middleware stackâ€”complete with custom error handling, logging, and cleanup logic.\n\n---\n\n## ğŸ“Œ Overview\n\nThe `requestTimeout` middleware is designed for frameworks using a `Context`-based architecture (like `tezx`). It:\n\n* Dynamically sets timeouts per request.\n* Gracefully handles timeout errors.\n* Logs and cleans up after timeouts.\n* Works seamlessly with other middleware.\n\n---\n\n## ğŸ”§ API\n\n### `requestTimeout(options: TimeoutOptions): Middleware`\n\n#### `TimeoutOptions`\n\n| Option            | Type                                             | Required | Description                                                                      |\n| ----------------- | ------------------------------------------------ | -------- | -------------------------------------------------------------------------------- |\n| `getTimeout`      | `(ctx: Context) => number`                       | âœ…        | Returns timeout (in ms) based on the request context.                            |\n| `onTimeout`       | `(ctx: Context, error: Error) => CallbackReturn` | âŒ        | Called when request times out. Default: 504 + `{ error: \"Request timed out.\" }`. |\n| `logTimeoutEvent` | `(ctx: Context, error: Error) => void`           | âŒ        | Called when timeout happens. Default: logs warning via `debugging.warn`.         |\n| `cleanup`         | `(ctx: Context) => void`                         | âŒ        | Cleanup hook after timeout (DB, streams, etc). Default: no-op.                   |\n\n---\n\n## âœ¨ Features\n\n* â± Dynamic timeouts based on route, headers, or user state\n* ğŸ§  Custom handlers for timeout error response\n* ğŸ“œ Event logging for timeout diagnostics\n* ğŸ§¹ Reliable resource cleanup\n* ğŸ§© Easy integration with existing middleware\n\n---\n\n## ğŸš€ Usage Examples\n\n### âœ… Basic Timeout\n\n```ts\nimport { requestTimeout } from \"tezx/request-timeout\";\n\napp.use(requestTimeout({\n  getTimeout: () => 5000, // 5 seconds\n}));\n```\n\n> All requests timeout after 5 seconds.\n\n---\n\n### ğŸ“‚ Per-Path Timeout\n\n```ts\napp.use(requestTimeout({\n  getTimeout: (ctx) =>\n    ctx.path.startsWith(\"/api/slow\") ? 10000 : 3000,\n  onTimeout: (ctx, error) => {\n    ctx.setStatus = 504;\n    ctx.body = {\n      error: `Request to ${ctx.path} timed out.`,\n    };\n  },\n}));\n```\n\n> Custom response for slow API paths.\n\n---\n\n### ğŸ§¾ With Logging & Cleanup\n\n```ts\napp.use(requestTimeout({\n  getTimeout: () => 5000,\n  logTimeoutEvent: (ctx, err) => {\n    console.warn(`â± Timeout: ${ctx.method} ${ctx.path}`);\n  },\n  cleanup: (ctx) => {\n    releaseDB(ctx.state.connection);\n  },\n}));\n```\n\n> Logs timeouts and ensures database connections are released.\n\n---\n\n### ğŸ›¡ï¸ Auth-Aware Timeout\n\n```ts\napp.use(authenticate); // Sets ctx.user\n\napp.use(requestTimeout({\n  getTimeout: (ctx) => ctx.user ? 10000 : 3000,\n}));\n```\n\n> Authenticated users get more generous timeouts.\n\n---\n\n## ğŸ“¦ Behavior Summary\n\n| Behavior          | Description                                        |\n| ----------------- | -------------------------------------------------- |\n| `getTimeout`      | Called first to get the timeout duration           |\n| `onTimeout`       | Called only if timeout occurs                      |\n| `logTimeoutEvent` | Invoked on timeout for diagnostics                 |\n| `cleanup`         | Always runs in `finally`, even on error or timeout |\n\n---\n\n## â— Error Handling\n\n* Timeout âœ `onTimeout` called, response handled, middleware chain stops.\n* Normal error âœ Propagated normally.\n* `cleanup` always runsâ€”guaranteed by `finally`.\n\n---\n\n## ğŸ§  Best Practices\n\n* Use short timeouts on user-facing endpoints.\n* Customize `onTimeout` with helpful errors.\n* Always log and release resources in `cleanup`.\n* Test slow endpoints to verify timeout + cleanup.\n\n---\n\n## ğŸš« Limitations\n\n* Timer precision limited by JavaScript event loop.\n* Assumes `ctx.method`, `ctx.path`, `ctx.setStatus`, and `ctx.body` exist.\n* Doesn't automatically cancel long-running internal operations (e.g., DB queries).\n\n---\n\n## ğŸ“ Types Export\n\n```ts\nimport type {\n  TimeoutOptions,\n  requestTimeout,\n} from \"tezx/request-timeout\";\n```\n\n---\n"
    },
    {
      "id": 32,
      "path": "middleware/sanitize-headers",
      "name": "Sanitize Headers",
      "folder": "Middleware",
      "content": "# ğŸ§¼ `sanitizeHeaders` Middleware\n\nEnhance HTTP request header hygiene by normalizing, filtering, and sanitizing headers â€” designed for modern web security and compliance.\n\n---\n\n## ğŸ“Œ Overview\n\nThe `sanitizeHeaders` middleware provides a powerful mechanism to:\n\n* Enforce **header name and value sanitation**\n* Strip disallowed headers via **whitelist or blacklist**\n* Normalize header names for consistency\n* Defend against **header injection** attacks (e.g. CRLF)\n\n---\n\n## ğŸ“¦ Installation\n\n```ts\nimport { sanitizeHeaders } from \"tezx/sanitize-headers\";\n```\n\n---\n\n## ğŸš€ Basic Usage\n\n```ts\napp.use(sanitizeHeaders());\n```\n\n> All incoming request headers will be normalized and sanitized using default safe policies.\n\n---\n\n## âš™ï¸ Advanced Configuration\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n---\n\n## ğŸ”§ Configuration Options\n\n### `whitelist: string[]`\n\n* **Default:** `[]` (allows all headers)\n* Case-insensitive list of allowed header names.\n* When non-empty, **only these headers are preserved**.\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"];\n```\n\n---\n\n### `blacklist: string[]`\n\n* **Default:** `[]` (blocks none)\n* Case-insensitive list of header names to **explicitly remove**.\n\n```ts\nblacklist: [\"x-powered-by\", \"server\"];\n```\n\n---\n\n### `allowUnsafeCharacters: boolean`\n\n* **Default:** `false`\n* When `false`, removes **control characters (e.g., CR/LF)** from header values to mitigate injection attacks.\n\n```ts\nallowUnsafeCharacters: true; // Less secure\n```\n\n---\n\n## ğŸ›  Internal Processing Flow\n\n1. **Iterate headers** â†’ one-by-one\n2. **Normalize header names** (if enabled)\n3. **Apply whitelist / blacklist**\n4. **Validate header name format**: must match `/^[a-zA-Z0-9\\-_]+$/`\n5. **Sanitize values**:\n\n   * Trims whitespace\n   * Removes dangerous characters (unless allowed)\n6. **Rebuild headers**\n7. **Overwrite original request headers**\n\n---\n\n## ğŸ› Debug Logging\n\nWhen enabled, the global debugging utility reports:\n\n* ğŸš« Removed headers due to policy\n* âš ï¸ Invalid header names\n* âš ï¸ Suspicious or empty values\n\n---\n\n## ğŸ§  Best Practices\n\n### 1. Secure Defaults\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n  }),\n);\n```\n\n### 2. Hide Server Internals\n\n```ts\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n  }),\n);\n```\n\n### 3. Compatibility Assurance\n\n* Test against your client apps before enforcing strict whitelists.\n* Monitor which headers are stripped unexpectedly.\n\n### 4. Layered Security\n\n* Use in conjunction with:\n\n  * CORS middleware\n  * Content Security Policy (CSP)\n  * XSS/CSRF protection middleware\n\n---\n\n## âš¡ Performance Notes\n\n* Fast execution: single-pass header processing\n* Case-insensitive lookups are optimized\n* Tip: Normalize whitelist values for faster lookup:\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n```\n\n---\n\n## ğŸ” Security Highlights\n\n| Threat                  | Protection                                                            |\n| ----------------------- | --------------------------------------------------------------------- |\n| Header Injection (CRLF) | Stripped by default                                                   |\n| Technology exposure     | Use `blacklist` to hide `\"x-powered-by\"`, `\"server\"` headers          |\n| Unsafe values           | Control characters removed (unless `allowUnsafeCharacters` is `true`) |\n\n---\n\n## âœ… Client Compatibility\n\n* Compatible with all modern browsers and clients.\n* Changes affect server-side only.\n* Useful for:\n\n  * APIs serving untrusted clients\n  * Systems requiring strict request validation\n  * Compliance-heavy environments (e.g. PCI, HIPAA)\n\n---\n"
    },
    {
      "id": 33,
      "path": "middleware/secure-headers",
      "name": "Secure Headers",
      "folder": "Middleware",
      "content": "# ğŸ›¡ï¸ `secureHeaders` Middleware\n\nSecure your HTTP responses with modern, configurable security headers. Ideal for protecting web applications against common browser-based vulnerabilities.\n\n---\n\n## ğŸ“Œ Overview\n\nThe `secureHeaders` middleware dynamically sets HTTP security headers, applying best practices by default while allowing custom configurations per route or request.\n\n---\n\n## âœ¨ Features\n\n* âœ… Applies essential HTTP security headers\n* âš™ï¸ Fully customizable per header\n* ğŸ§  Supports dynamic values via functions (per request)\n* ğŸ§ª Environment-aware defaults (e.g. HSTS in production only)\n\n---\n\n## ğŸ“¦ Installation\n\n```ts\nimport { secureHeaders } from \"tezx/secure-headers\";\n```\n\n---\n\n## ğŸš€ Usage\n\n### Minimal Setup (Defaults Applied)\n\n```ts\napp.use(secureHeaders());\n```\n\n### With Custom Header Configuration\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n---\n\n## ğŸ”§ Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n* `options` *(optional)*: `SecurityHeaderOptions` â€“ object defining custom header values (strings, booleans, or functions).\n\n### Returns\n\nA middleware function that injects the configured security headers into HTTP responses.\n\n---\n\n## ğŸ§± Supported Security Headers\n\n| Header                      | Default Value                                                                              | Purpose                                 |\n| --------------------------- | ------------------------------------------------------------------------------------------ | --------------------------------------- |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` | Prevents resource injection (XSS, etc.) |\n| `X-Frame-Options`           | `DENY`                                                                                     | Blocks clickjacking                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains` *(only in production)*                               | Enforces HTTPS                          |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            | Enables legacy XSS protection           |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  | Prevents MIME-sniffing                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              | Controls what `Referer` is sent         |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 | Restricts browser APIs                  |\n\n---\n\n## ğŸ§  Dynamic Header Configuration\n\nEach option supports either:\n\n* A **static string or boolean** (enabled/disabled)\n* A **function**: `(ctx: Ctx) => string | undefined`\n\n### Example: Route-specific CSP\n\n```ts\nsecureHeaders({\n  contentSecurityPolicy: (ctx) =>\n    ctx.url.startsWith(\"/admin\")\n      ? \"default-src 'self'; script-src 'self';\"\n      : undefined, // fallback to default\n});\n```\n\n---\n\n## ğŸŒ Example\n\n```ts\nimport { secureHeaders } from \"tezx/secure-headers\";\n\napp.use(\n  secureHeaders({\n    hsts: false, // Disable HSTS\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.startsWith(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined,\n    referrerPolicy: \"strict-origin-when-cross-origin\",\n  }),\n);\n\napp.get(\"/\", (ctx) => ctx.send(\"Hello, World!\"));\napp.get(\"/admin\", (ctx) => ctx.send(\"Admin Dashboard\"));\n```\n\n---\n\n## ğŸ§ª Testing & Verification\n\n### 1. Default Route\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected:\n\n```\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n---\n\n### 2. Admin Route with Custom CSP\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected:\n\n```\nContent-Security-Policy: default-src 'self'; script-src 'self';\n```\n\n---\n\n### 3. HSTS Disabled\n\nNo `Strict-Transport-Security` header is present.\n\n---\n\n## âœ… Best Practices\n\n* âœ… Place early in middleware chain to ensure headers are applied globally.\n* âœ… Use dynamic rules for admin or sensitive routes.\n* âœ… Keep `unsafe-inline` to a minimum in CSP.\n* âœ… Use `hsts: true` only in production (enabled by default in prod).\n\n---\n\n## ğŸ” Security Summary\n\n| Threat                 | Defense Mechanism                  |\n| ---------------------- | ---------------------------------- |\n| XSS (script injection) | `Content-Security-Policy`, `X-XSS` |\n| Clickjacking           | `X-Frame-Options`                  |\n| Protocol downgrade     | `Strict-Transport-Security`        |\n| MIME sniffing          | `X-Content-Type-Options`           |\n| Over-sharing referrers | `Referrer-Policy`                  |\n| Feature abuse          | `Permissions-Policy`               |\n\n---\n"
    },
    {
      "id": 34,
      "path": "middleware/xss-protection",
      "name": "XSS protection",
      "folder": "Middleware",
      "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```ts\nimport { xssProtection } from \"tezx/xss-protection\";\n```\n\n## Basic Usage\n\n```ts\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n* **Default:** `true`\n* Enables or disables the XSS protection.\n* Can be a static boolean or a function that evaluates dynamically based on request context.\n\n#### Examples\n\n```ts\nenabled: true; // Always enabled\nenabled: (ctx) => !ctx.url.startsWith(\"/admin\"); // Disabled for admin\n```\n\n---\n\n### `mode: \"block\" | \"filter\"`\n\n* **Default:** `\"block\"`\n* Defines the behavior when XSS is detected:\n\n  * `\"block\"`: Prevents page from rendering.\n  * `\"filter\"`: Tries to sanitize and allow rendering.\n\n#### Examples\n\n```ts\nmode: \"block\";  // More secure, stricter\nmode: \"filter\"; // More tolerant, user-friendly\n```\n\n---\n\n### `fallbackCSP: string`\n\n* **Default:** `\"default-src 'self'; script-src 'self';\"`\n* Fallback CSP applied only when no `Content-Security-Policy` header is already set.\n* Helps secure older browsers or edge cases.\n\n#### Example\n\n```ts\nfallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n```\n\n---\n\n## Technical Implementation Details\n\n### Headers Set\n\n| Header                    | Example Value          | Purpose                            |\n| ------------------------- | ---------------------- | ---------------------------------- |\n| `X-XSS-Protection`        | `1; mode=block` or `1` | Enables browser XSS filters        |\n| `Content-Security-Policy` | As configured          | Fallback policy for older browsers |\n\n### Flow\n\n1. Check if protection is enabled.\n2. Determine `X-XSS-Protection` mode based on config.\n3. Set fallback CSP if no existing CSP header exists.\n4. Proceed to the next middleware.\n\n---\n\n## Debug Logging\n\n* ğŸŸ  Skipped protection due to `enabled = false`\n* ğŸŸ¢ Set `X-XSS-Protection` header\n* ğŸŸ£ Applied fallback `Content-Security-Policy`\n\n---\n\n## Best Practices\n\n* âœ… Use `\"block\"` mode in production unless filtering is required.\n* âœ… Only disable protection for trusted internal/admin routes.\n* âœ… Complement this middleware with:\n\n  * Input sanitization\n  * Output escaping\n  * Proper CSP setup\n\n---\n\n## Browser Compatibility\n\n| Browser       | `X-XSS-Protection` Support | CSP Support  |\n| ------------- | -------------------------- | ------------ |\n| Chrome (â‰¤78)  | âœ…                          | âœ…            |\n| Edge (Legacy) | âœ…                          | âœ…            |\n| Firefox       | âŒ (ignores this header)    | âœ… (CSP only) |\n| Safari        | âœ…                          | âœ…            |\n\n* **Tip:** Rely on CSP as a long-term strategy â€” `X-XSS-Protection` is deprecated in some browsers.\n\n---\n\n## Security Considerations\n\n* \"Block\" mode is safest, but test for layout/content impact.\n* \"Filter\" mode offers more flexibility for legacy or complex UIs.\n* Always pair with CSP, validation, and escaping mechanisms.\n\n---\n\n## Example: Per-Route XSS Mode\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => ctx.url.startsWith(\"/public\"),\n    mode: \"filter\",\n  }),\n);\n```\n"
    },
    {
      "id": 35,
      "path": "middleware/i18n",
      "name": "i18n",
      "folder": "Middleware",
      "content": "# ğŸŒ `i18n` Middleware for TezX\n\nAdvanced internationalization middleware supporting dynamic translation loading, fallback language chains, caching, and customizable message formatting.\n\n---\n\n## ğŸ“„ Basic Usage\n\n```ts\nimport { i18n } from \"tezx/i18n\";\n\napp.use(\n  i18n({\n    loadTranslations: (lang) => import(`./locales/${lang}.json`),\n    defaultLanguage: \"en\",\n  }),\n);\n```\n\n---\n\n## ğŸ”§ API: `i18n(options: I18nOptions): Middleware`\n\n### Configuration Options\n\n| Option                   | Type                                                                          | Default                           | Description                                          |\n| ------------------------ | ----------------------------------------------------------------------------- | --------------------------------- | ---------------------------------------------------- |\n| `loadTranslations`       | `(language: string) => Promise<{ translations: object, expiresAt?: number }>` | **Required**                      | Dynamically loads translations for a given language  |\n| `defaultCacheDuration`   | `number`                                                                      | `3600000` (1 hour)                | Cache expiration time in milliseconds                |\n| `isCacheValid`           | `(cached: object, language: string) => boolean`                               | `cached.expiresAt > Date.now()`   | Custom cache validation logic                        |\n| `detectLanguage`         | `(ctx: Context) => string`                                                    | Query > Cookie > Header > default | Custom language detection logic                      |\n| `defaultLanguage`        | `string`                                                                      | `'en'`                            | Fallback language if detection fails                 |\n| `fallbackChain`          | `string[]`                                                                    | `[]`                              | Array of fallback languages in priority order        |\n| `translationFunctionKey` | `string`                                                                      | `'t'`                             | Key on `ctx` where the translation function is added |\n| `formatMessage`          | `(msg: string, vars?: Record<string, any>) => string`                         | Basic `{{var}}` interpolation     | Custom message formatting/interpolation function     |\n| `cacheTranslations`      | `boolean`                                                                     | `true`                            | Enable or disable caching of translations            |\n\n---\n\n## ğŸ’¬ Translation Format\n\nTranslations can be structured as nested JSON objects:\n\n```json\n{\n  \"home\": {\n    \"title\": \"Welcome, {{name}}!\",\n    \"subtitle\": \"Your dashboard\"\n  },\n  \"common\": {\n    \"logout\": \"Log out\"\n  }\n}\n```\n\n---\n\n## ğŸ§  Features\n\n### 1. Language Detection\n\nDefault order: Query param (`?lang=fr`) â†’ Cookie (`lang=fr`) â†’ `Accept-Language` header â†’ `defaultLanguage`\n\nOverride with:\n\n```ts\ndetectLanguage: (ctx) => ctx.cookies.get(\"user_lang\") || \"en\";\n```\n\n### 2. Fallback Chain\n\nSupports fallback languages, e.g.:\n\n```ts\nfallbackChain: [\"fr-CA\", \"fr\", \"en\"];\n```\n\n### 3. Cache with Expiry\n\nTranslations can be cached with expiration either from `expiresAt` returned by loader or default duration.\n\n### 4. Message Interpolation\n\nSupports variable interpolation inside messages:\n\n```ts\nctx.t(\"home.title\", { name: \"Alice\" }); // â†’ \"Welcome, Alice!\"\n```\n\nCustom formatter example:\n\n```ts\nformatMessage: (msg, vars) => msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? \"\");\n```\n\n### 5. Nested Key Support\n\nSupports nested keys using dot notation:\n\n```ts\nctx.t('user.profile.greeting', { name: 'John' });\n```\n\n---\n\n## ğŸ§ª Advanced Example\n\n```ts\napp.use(\n  i18n({\n    loadTranslations: async (lang) => {\n      const res = await fetch(`https://api.example.com/lang/${lang}`);\n      const json = await res.json();\n      return { translations: json.data, expiresAt: json.expiresAt };\n    },\n    defaultLanguage: \"en\",\n    fallbackChain: [\"en-GB\", \"en\"],\n    detectLanguage: (ctx) => ctx.req.headers.get(\"x-custom-lang\") || \"en\",\n    translationFunctionKey: \"translate\",\n    formatMessage: (msg, vars) =>\n      msg.replace(/\\{\\{(.*?)\\}\\}/g, (_, key) => vars?.[key.trim()] ?? \"\"),\n    cacheTranslations: true,\n    isCacheValid: (cached) => cached.expiresAt > Date.now(),\n  }),\n);\n```\n\n---\n\n## ğŸ“Œ What `ctx` Provides After Middleware\n\n| Property            | Type                                      | Description                     |\n| ------------------- | ----------------------------------------- | ------------------------------- |\n| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function            |\n| `ctx.language`      | `string`                                  | Detected language               |\n| `ctx.languageChain` | `string[]`                                | Ordered fallback language chain |\n\n---\n\n## â— Error Handling\n\nIf translations are missing for all languages in the chain, the middleware throws an error and sets:\n\n```ts\nctx.setStatus = 500;\n```\n\n---\n\n## ğŸ“¤ Exported Types\n\nYou can import and use these types for strong typing:\n\n```ts\nimport type {\n  I18nOptions,\n  loadTranslations,\n  TranslationMap,\n} from \"tezx/i18n\";\n```\n\n---\n"
    },
    {
      "id": 36,
      "path": "helpers/cookie",
      "name": "Cookie",
      "folder": "Helpers",
      "content": "\n# ğŸª Cookie Utilities â€“ TezX Helper\n\nA utility module for managing HTTP cookies within TezX applications. This includes reading, setting, parsing, and deleting cookies in a type-safe and consistent manner.\n\n---\n\n## ğŸ“¦ Import\n\n```ts\nimport {\n  getCookie,\n  allCookies,\n  setCookie,\n  deleteCookie,\n  serializeOptions,\n} from \"tezx/helper\";\n```\n\n---\n\n## ğŸ§° API Reference\n\n### ğŸ” `getCookie(ctx: Context, name: string): string | undefined`\n\nRetrieve the value of a specific cookie from the incoming HTTP request.\n\n#### **Parameters for `getCookie`**\n\n* `ctx`: The request context.\n* `name`: The name of the cookie.\n\n#### **Returns**\n\n* The decoded cookie value if found, otherwise `undefined`.\n\n#### **Example**\n\n```ts\nconst session = getCookie(ctx, \"session_id\")\nif (session) {\n  console.log(\"Active session:\", session);\n}\n```\n\n---\n\n### ğŸ“‹ `allCookies(ctx: Context): Record<string, string>`\n\nParse all cookies from the request and return them as an object.\n\n#### **Parameters**\n\n* `ctx`: The request context.\n\n#### **Returns**\n\n* A key-value map of all cookies.\n\n#### **Example**\n\n```ts\nconst cookies = allCookies(ctx);\nconsole.log(\"Cookies:\", cookies);\n```\n\n---\n\n### â• `setCookie(ctx: Context, name: string, value: string, options?: CookieOptions): void`\n\nSet a cookie on the response using optional attributes.\n\n#### **Parameters for `setCookie`**\n\n* `ctx`: The response context.\n* `name`: The name of the cookie.\n* `value`: The value to store.\n* `options` *(optional)*: Configuration like expiration, security flags, etc.\n\n#### **Example**\n\n```ts\nsetCookie(ctx, \"session_id\", \"abc123\", {\n  httpOnly: true,\n  secure: true,\n  maxAge: 3600,\n  path: \"/\",\n});\n```\n\n---\n\n### âŒ `deleteCookie(ctx: Context, name: string, options?: CookieOptions): void`\n\nDelete a cookie by expiring it immediately.\n\n#### **Parameters for `deleteCookie`**\n\n* `ctx`: The response context.\n* `name`: The cookie to remove.\n* `options` *(optional)*: Must match original cookie attributes (e.g., `path`, `domain`) to ensure deletion.\n\n#### **Example**\n\n```ts\ndeleteCookie(ctx, \"session_id\", { path: \"/\" });\n```\n\n---\n\n### ğŸ› ï¸ `serializeOptions(options: CookieOptions): string`\n\nSerialize a cookie options object into a valid `Set-Cookie` string fragment.\n\n> Used internally, but available for custom header construction if needed.\n\n#### **Parameters for `serializeOptions`**\n\n* `options`: An object describing cookie settings.\n\n#### **Returns**\n\n* A string representation suitable for HTTP headers.\n\n#### **Example**\n\n```ts\nconst header = serializeOptions({ maxAge: 3600, httpOnly: true });\n// Output: \"Max-Age=3600; HttpOnly\"\n```\n\n---\n\n## ğŸ“‘ `CookieOptions` Interface\n\nUse this interface to configure cookie behavior:\n\n| Property   | Type                              | Description                                              |\n| ---------- | --------------------------------- | -------------------------------------------------------- |\n| `maxAge`   | `number`                          | Lifetime of the cookie (in seconds).                     |\n| `expires`  | `Date`                            | Absolute expiry timestamp.                               |\n| `path`     | `string`                          | Path scope of the cookie.                                |\n| `domain`   | `string`                          | Domain scope of the cookie.                              |\n| `secure`   | `boolean`                         | Send only over HTTPS.                                    |\n| `httpOnly` | `boolean`                         | Restrict access from JavaScript.                         |\n| `sameSite` | `'Strict'` \\| `'Lax'` \\| `'None'` | Restrict cross-site cookie behavior for CSRF protection. |\n\n---\n\n## âœ… Best Practices\n\n* Always use `httpOnly` and `secure` for sensitive cookies.\n* Use `path` and `domain` to avoid scope conflicts.\n* Set `sameSite: 'Strict'` or `'Lax'` for CSRF mitigation.\n* Call `deleteCookie()` with matching `path` and `domain` for successful removal.\n\n---\n"
    },
    {
      "id": 37,
      "path": "helpers/useformdata",
      "name": "useFormData",
      "folder": "Helpers",
      "content": "\n# ğŸš€ `useFormData` â€” Multipart Form & File Upload Handler\n\n`useFormData` is a powerful helper designed for efficient parsing, validation, and management of **multipart/form-data** HTTP requests in TezX applications. It simplifies handling complex file uploads combined with form fields while enforcing strict limits to protect your server from overload and security risks.\n\n---\n\n## ğŸ”§ Function Signature\n\n```ts\nimport { Context,FormDataOptions } from \"tezx\";\n\nexport async function useFormData(\n  ctx: Context,\n  options?: FormDataOptions\n): Promise<Record<string, string | File | (string | File)[]>>;\n```\n\n---\n\n## ğŸ”¥ Core Features\n\n* **Full multipart/form-data parsing** for text fields and file uploads\n* **Automatic merging** of repeated fields into arrays\n* **File validation:**\n\n  * MIME type whitelist\n  * Max file size per file\n  * Max number of files per field\n  * Max total upload size (combined all files)\n* **Text field validation:**\n\n  * Max size per text field (bytes/characters)\n  * Optional sanitization (trimming, escaping)\n* **Streaming-aware file processing** for large uploads (configurable)\n* Detailed **error handling** with descriptive messages\n* Easily **extensible** to add custom file processors or virus scanners\n\n---\n\n## ğŸ”¹ Parameters\n\n| Name      | Type              | Description                                                         |\n| --------- | ----------------- | ------------------------------------------------------------------- |\n| `ctx`     | `Context`         | TezX request context with the incoming multipart HTTP request       |\n| `options` | `FormDataOptions` | Optional configuration object to control validations and processing |\n\n---\n\n## ğŸ”¸ Returns\n\nPromise resolving to an object mapping field names to:\n\n* **string** â€” for text form fields\n* **File** â€” for single uploaded files\n* **Array\\<string | File>** â€” for repeated fields (multiple values/files)\n\n---\n\n## âš™ï¸ FormDataOptions Interface\n\n| Property       | Type       | Description                                                                     |\n| -------------- | ---------- | ------------------------------------------------------------------------------- |\n| `sanitized`    | `boolean`  | Enables sanitization of text inputs (trimming, escaping, etc.)                  |\n| `allowedTypes` | `string[]` | MIME types allowed for file uploads (e.g., `[\"image/jpeg\", \"application/pdf\"]`) |\n| `maxSize`      | `number`   | Maximum size (in bytes) allowed per individual file                             |\n| `maxFiles`     | `number`   | Maximum number of files accepted per single field                               |\n| `maxTotalSize` | `number`   | Maximum combined size (in bytes) allowed for all files in the request           |\n| `maxFieldSize` | `number`   | Maximum allowed length (characters or bytes) for text fields                    |\n\n---\n\n## ğŸ” Detailed Behavior\n\n### 1. **Multipart Form Parsing**\n\nThe function calls `ctx.req.formData()` internally to parse the multipart form. It then iterates over all fields and files, applying the configured validations.\n\n### 2. **File Handling**\n\n* **File Size:** Each file is checked against the `maxSize` option. Files exceeding this size are rejected immediately.\n* **File Count:** Enforces a strict maximum number of files per field via `maxFiles`.\n* **MIME Type Validation:** If `allowedTypes` is specified, files not matching allowed MIME types are rejected.\n* **Total Upload Size:** Keeps a running total of all uploaded file bytes and throws if the `maxTotalSize` is exceeded.\n* **Extensible Processing:** Internally calls a customizable `processFile` function for potential streaming, virus scanning, or on-the-fly compression.\n\n### 3. **Text Field Handling**\n\n* Checks each string field against `maxFieldSize` for length.\n* Optionally sanitizes text fields when `sanitized` is enabled (trimming whitespace, escaping dangerous chars).\n\n### 4. **Duplicate Field Names**\n\nFields with the same name are grouped into arrays, supporting inputs like:\n\n```html\n<input type=\"file\" name=\"photos\" multiple>\n<input type=\"text\" name=\"tags\">\n<input type=\"text\" name=\"tags\">\n```\n\n---\n\n## ğŸ›¡ï¸ Error Handling & Security\n\n* Throws clear, actionable errors on exceeding any configured limits (size, count, type).\n* Prevents large unexpected uploads from exhausting memory or disk space.\n* Supports input sanitization to prevent injection or XSS attacks from text fields.\n* Encourages defining strict `allowedTypes` and `maxSize` to avoid malicious uploads.\n\n---\n\n## âš¡ Example Usage (Robust File Upload)\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nasync function uploadHandler(ctx: Context) {\n  try {\n    const form = await useFormData(ctx, {\n      allowedTypes: [\"image/jpeg\", \"image/png\", \"application/pdf\"],\n      maxSize: 10 * 1024 * 1024,       // 10MB max per file\n      maxFiles: 5,                     // Max 5 files per field\n      maxTotalSize: 50 * 1024 * 1024, // 50MB combined limit\n      maxFieldSize: 2000,              // Max 2000 chars for text fields\n      sanitized: true,                 // Trim & sanitize text inputs\n    });\n\n    // Access text fields and files\n    const username = form[\"username\"];\n    const profilePics = form[\"photos\"]; // Array of File objects\n\n    // Process or store files\n    for (const file of Array.isArray(profilePics) ? profilePics : [profilePics]) {\n      // e.g. save to disk, cloud storage, virus scan, etc.\n      console.log(`Uploading file: ${file.name} (${file.size} bytes)`);\n    }\n\n    return ctx.text(\"Upload successful!\");\n  } catch (err) {\n    // Handle validation errors\n    return ctx.status(400).text(err.message);\n  }\n}\n```\n\n---\n"
    },
    {
      "id": 38,
      "path": "helpers/load-environment",
      "name": "Load Environment",
      "folder": "Helpers",
      "content": "# `loadEnv(basePath?: string)`\n\n## Purpose\n\nLoads `.env` files into `process.env` (Node/Bun) or `Deno.env` and returns a typed object with environment variables for easy and type-safe access.\n\n---\n\n## Supported `.env` Files (Priority Order)\n\n```bash\n.env â†’ .env.local â†’ .env.[mode] â†’ .env.[mode].local\n```\n\n---\n\n## Return Type\n\n```ts\ntype EnvVariables = {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n};\n```\n\n---\n\n## Usage Example\n\n```ts\nimport { loadEnv } from \"tezx/node\"; // or \"tezx/bun\", \"tezx/deno\"\n\nconst env = loadEnv(\"./config\");\nconst port = env.PORT || process.env.PORT || \"3000\";\n```\n\n---\n\n# Custom Context in TezX\n\n## Purpose\n\nExtend TezXâ€™s base `Context` interface with your own typed properties to share data such as authenticated user info or request-specific metadata across middleware and routes.\n\n---\n\n## Example: Adding User and Request ID\n\n```ts\ninterface CustomContext {\n  user?: { id: string; roles: string[] };\n  requestId: string;\n}\n\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return next();\n});\n```\n\n---\n\n## Accessing Custom Context in Routes\n\n```ts\napp.get(\"/me\", (ctx) => ctx.json(ctx.user));\n```\n\n---\n\n# Server Initialization with Custom Context and Env\n\n```ts\nconst env = loadEnv();\n\nconst app = new TezX<CustomContext>({ env });\n\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n---\n\n# Configuration Options for `TezX`\n\n| Option | Type           | Description                    |\n| ------ | -------------- | ------------------------------ |\n| `env`  | `EnvVariables` | Injected environment variables |\n\nUse `ctx.env` in middleware/routes to access these variables safely.\n\n---\n\n# Best Practices\n\n* **.env Files Per Mode**\n\n```bash\n.env.development\n.env.production\n.env.production.local\n```\n\n* **Git Ignore**\n\n```bash\n.env.local\n.env.*.local\n```\n\n* **Feature Flags**\n\n```ts\nif (env.FEATURE_X === \"enabled\") {\n  enableExperimentalFeature();\n}\n```\n\n---\n\n## Advanced Context Usage\n\n```ts\ninterface AppContext {\n  user?: User;\n  analytics: Tracker;\n}\n\napp.use((ctx, next) => {\n  ctx.analytics = new Tracker(ctx.env.TRACKING_ID);\n  return next();\n});\n```\n\n---\n\nğŸ’¡ Combine `loadEnv()`, **custom typed contexts**, and `ctx.env` for a secure, clean, and scalable server foundation in TezX.\n"
    },
    {
      "id": 39,
      "path": "websocket",
      "name": "WebSocket",
      "folder": ".",
      "content": "# ğŸ”Œ `upgradeWebSocket` Middleware\n\nTezX provides **first-class WebSocket support** via the `upgradeWebSocket` middleware, enabling seamless integration across **Node.js**, **Deno**, and **Bun** with runtime-specific optimizations.\n\n---\n\n## âœ… Prerequisites\n\n| Requirement          | Node.js          | Deno       | Bun        |\n| -------------------- | ---------------- | ---------- | ---------- |\n| Runtime Support      | âœ… Yes            | âœ… Native   | âœ… Native   |\n| WebSocket Dependency | âš ï¸ Requires `ws` | âœ… No       | âœ… No       |\n| TezX App             | âœ… Required       | âœ… Required | âœ… Required |\n\n```bash\n# For Node.js only\nnpm install ws\n```\n\n---\n\n## ğŸ“ Runtime-Specific Import\n\nImport the middleware from your target runtime package:\n\n```ts\n// Node.js\nimport { upgradeWebSocket } from \"tezx/node\";\n\n// Deno\nimport { upgradeWebSocket } from \"tezx/deno\";\n\n// Bun\nimport { upgradeWebSocket } from \"tezx/bun\";\n```\n\n---\n\n## ğŸ§© Type Definitions\n\n### `WebSocketEvent`\n\n```ts\ntype WebSocketEvent = {\n  open?: (ws: WebSocket, ctx?: Context) => void;\n  message?: (ws: WebSocket, data: string | Buffer | ArrayBuffer) => void;\n  close?: (ws: WebSocket, info: { code: number; reason: string }) => void;\n  error?: (ws: WebSocket, err: Error | any) => void;\n  ping?: (ws: WebSocket, data: Buffer) => void;\n  pong?: (ws: WebSocket, data: Buffer) => void;\n  drain?: (ws: WebSocket) => void;\n};\n```\n\n### `WebSocketCallback`\n\n```ts\ntype WebSocketCallback = (ctx: Context) => WebSocketEvent;\n```\n\n### `WebSocketOptions`\n\n```ts\ntype WebSocketOptions = {\n  onUpgradeError?: (err: Error, ctx: Context) => HttpBaseResponse;\n};\n```\n\n---\n\n## ğŸš€ Basic Usage\n\n```ts\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) {\n      console.log(\"WebSocket connected\");\n    },\n    message(ws, data) {\n      ws.send(`Echo: ${data}`);\n    },\n    close(ws, { code, reason }) {\n      console.log(\"Closed with\", code, reason);\n    },\n    error(ws, err) {\n      console.error(\"Error:\", err);\n    },\n  }))\n);\n```\n\n---\n\n## âš™ï¸ Runtime Setup\n\n### ğŸ§­ **Node.js + `ws`**\n\n```ts\nimport { createServer } from \"http\";\nimport { upgradeWebSocket, mountTezXOnNode } from \"tezx/node\";\n\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open: (ws) => console.log(\"Client connected\"),\n    message: (ws, msg) => ws.send(\"From Node: \" + msg),\n  }))\n);\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n```\n\n---\n\n### ğŸ¦• **Deno**\n\n```ts\nimport { upgradeWebSocket } from \"tezx/deno\";\n\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) {\n      console.log(\"WebSocket ready (Deno)\");\n    },\n    message(ws, msg) {\n      ws.send(\"From Deno: \" + msg);\n    },\n  }))\n);\n\nDeno.serve({ port: 3000 }, app.serve);\n```\n\n---\n\n### âš¡ **Bun**\n\n```ts\nimport { upgradeWebSocket } from \"tezx/bun\";\n\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) {\n      console.log(\"Client connected\");\n    },\n    message(ws, msg) {\n      ws.send(\"From Bun: \" + msg);\n    },\n  }))\n);\n\n// Required Bun.serve() handler for WebSocket routing\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  reusePort: true,\n  websocket: {\n    open(ws) {\n      return (ws.data as any)?.open?.(ws);\n    },\n    message(ws, msg) {\n      return (ws.data as any)?.message?.(ws, msg);\n    },\n    close(ws, code, reason) {\n      return (ws.data as any)?.close?.(ws, { code, reason });\n    },\n    ping(ws, data) {\n      return (ws.data as any)?.ping?.(ws, data);\n    },\n    pong(ws, data) {\n      return (ws.data as any)?.pong?.(ws, data);\n    },\n    drain(ws) {\n      return (ws.data as any)?.drain?.(ws);\n    },\n  },\n});\n```\n\n---\n\n## â— Upgrade Error Handling\n\nUse `onUpgradeError` to customize behavior when a connection fails:\n\n```ts\nupgradeWebSocket(callback, {\n  onUpgradeError: (err, ctx) => {\n    return ctx.text(\"Upgrade failed: \" + err.message, 400);\n  },\n});\n```\n\n---\n\n## ğŸ§ª Advanced Events\n\nYou can listen to lower-level events like `ping`, `pong`, or `drain` (Bun-only):\n\n```ts\nmessage(ws, data) {\n  ws.send(\"Hello\");\n},\nping(ws, buffer) {\n  console.log(\"Ping received:\", buffer);\n},\ndrain(ws) {\n  console.log(\"Backpressure relieved\");\n}\n```\n\n---\n\n## âœ… Runtime Compatibility Matrix\n\n| Feature                | Node.js (`ws`)  | Deno  | Bun        |\n| ---------------------- | --------------- | ----- | ---------- |\n| Native Upgrade         | âŒ Requires `ws` | âœ… Yes | âœ… Yes      |\n| `ctx.args[2]` Support  | âœ… Yes           | âŒ No  | âŒ No       |\n| `.data` Usage          | âŒ N/A           | âŒ N/A | âœ… Required |\n| `ping` / `pong` Events | âœ… Yes           | âŒ No  | âœ… Yes      |\n| `drain` Event          | âŒ No            | âŒ No  | âœ… Yes      |\n| Compression            | âœ… Via `ws`      | âŒ No  | âŒ No       |\n\n---\n\n## ğŸ›¡ Best Practices\n\n* Use `ping` and `pong` for health checks in Bun/Node.\n* In Bun, always return event handlers via `.data` to enable runtime delegation.\n* In Node, attach your server manually using `createServer()` and `mountTezXOnNode`.\n\n---\n"
    },
    {
      "id": 40,
      "path": "static-file",
      "name": "Static File",
      "folder": ".",
      "content": "# Static File Serving (`app.static()`)\n\n## Overview\n\nThe `static()` method enables efficient serving of static files (HTML, CSS, JS, images, videos, fonts) from a specified directory. You can serve files from the root (`/`) or a custom route, with full control over caching and response headers.\n\n---\n\n## Basic Usage\n\n### 1. Serve from Root\n\n```ts\napp.static(\"./public\");\n```\n\nğŸ“‚ `public/style.css` â†’ ğŸŒ `/style.css`\n\n---\n\n### 2. Serve from Custom Route\n\n```ts\napp.static(\"/static\", \"./assets\");\n```\n\nğŸ“‚ `assets/logo.png` â†’ ğŸŒ `/static/logo.png`\n\n---\n\n### 3. Serve with Options\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\nğŸ§  Files are cached for 1 hour.\n\n---\n\n## Method Signature\n\n```ts\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## Parameters\n\n| Name      | Type                             | Description                                     |\n| --------- | -------------------------------- | ----------------------------------------------- |\n| `route`   | `string` *(optional)*            | Base URL (e.g., `/static`). Defaults to `/`     |\n| `folder`  | `string`                         | Directory with static assets (e.g., `./public`) |\n| `options` | `StaticServeOption` *(optional)* | Configuration for caching, headers, etc.        |\n\n---\n\n## StaticServeOption\n\n| Option         | Type             | Default      | Description                         |\n| -------------- | ---------------- | ------------ | ----------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Sets `Cache-Control` header         |\n| `header`       | `HeaderResponse` | `undefined`  | Adds custom headers to the response |\n\n---\n\n## Examples\n\n### âœ… Long-Term Caching\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\", // 1 year\n});\n```\n\n---\n\n### ğŸ” Method Chaining\n\n```ts\napp.static(\"./public\").use(logger());\n```\n\n---\n\n### ğŸ”§ Override a Static File\n\n```ts\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/logo.png\", (ctx) => ctx.text(\"Overridden logo\"));\n```\n\n---\n\n## Features\n\n* âœ… **Automatic MIME types**\n* ğŸ” **Prevents directory traversal**\n* ğŸŒ **Works with Node.js, Bun, Deno**\n* ğŸ” **Supports method chaining**\n\n---\n\n## Best Practices\n\n* Use long-term `cacheControl` for versioned assets.\n* Prefix with `/static` to prevent route collisions.\n* Avoid serving sensitive or dynamic files.\n\n---\n\n## Learn More\n\n* [MDN â€“ Cache-Control Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)\n"
    },
    {
      "id": 41,
      "path": "toolkit/middlewares/github-oauth2",
      "name": "Github Oauth2",
      "folder": "Toolkit/Middlewares",
      "content": "\n# ğŸ“¦ `@tezx/github-oauth2`\n\nGitHub OAuth2.0 middleware for the [TezX](https://github.com/tezxjs/TezX) web framework. Securely authenticate users via GitHub, and define custom sign-in, session, and token handling logic.\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/github-oauth2.svg)\n\n---\n\n## âœ… Setup GitHub OAuth App\n\nGo to: [https://github.com/settings/developers](https://github.com/settings/developers)\n\n1. Click **\"New OAuth App\"**\n2. Name: `My GitHub Login App`\n3. Homepage URL: `http://localhost:3000`\n4. Authorization callback URL: `http://localhost:3000/auth/github/callback`\n5. Save and copy `Client ID` and `Client Secret`\n\n## ğŸ“¥ Installation\n\n```bash\nnpm install @tezx/github-oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx github-auth -- --template github-oauth2 --y\n```\n\n---\n\n## ğŸ“„ Example Usage\n\n```ts\nimport { TezX } from 'tezx';\nimport {\n  GitHubOauthClient,\n  getGithubOAuthURL,\n  verifyGithubToken\n} from '@tezx/github-oauth2';\n\nconst app = new TezX({\n  debugMode: true\n});\n\n// Initialize OAuth client\nconst client = GitHubOauthClient({\n  clientId: process.env.GITHUB_CLIENT_ID!,\n  clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000'\n});\n\n// Step 1: Redirect user to GitHub login\napp.get('github', getGithubOAuthURL({\n  authClient: client,\n}), (ctx) => {\n  return ctx.redirect(ctx.github_oauth_url);\n});\n\n// Step 2: Verify GitHub token and handle user session\napp.get('/', verifyGithubToken({\n  authClient: client,\n  Callbacks: (ctx) => {\n    return {\n      session: async (session, user) => {\n        console.log('Session:', session);\n        console.log('User:', user);\n        return session;\n      }\n    };\n  }\n}), async (ctx) => {\n  return ctx.json({ success: true });\n});\n```\n\n---\n\n## ğŸ§© API Reference\n\n### `GitHubOauthClient(config: GithubOauthClient): GitHubAuthClient`\n\nCreates an OAuth client instance.\n\n#### Parameters\n\n| Name         | Type   | Description                    |\n| ------------ | ------ | ------------------------------ |\n| clientId     | string | GitHub OAuth App client ID     |\n| clientSecret | string | GitHub OAuth App client secret |\n| redirectUri  | string | URI GitHub should redirect to  |\n\n---\n\n### `getGithubOAuthURL(options: OAuthURLParams)`\n\nGenerates the GitHub OAuth URL and stores it in `ctx.state.get('github_oauth_url')`.\n\n#### Parameters\n\n| Name        | Type              | Description                                                      |\n| ----------- | ----------------- | ---------------------------------------------------------------- |\n| authClient  | GitHubOauthClient | The OAuth client instance                                        |\n| scopes      | string\\[]         | (Optional) OAuth scopes (default: `['read:user', 'user:email']`) |\n| state       | string            | (Optional) CSRF protection state value                           |\n| allowSignup | boolean           | (Optional) Allow GitHub signups (default: true)                  |\n\n---\n\n### `verifyGithubToken(options: { authClient: GitHubOauthClient, Callbacks: Callbacks })`\n\nMiddleware to validate the token returned from GitHub and handle user info.\n\n#### Parameters\n\n| Name       | Type                       | Description                  |\n| ---------- | -------------------------- | ---------------------------- |\n| authClient | GitHubOauthClient          | The initialized OAuth client |\n| Callbacks  | `(ctx) => CallbacksReturn` | Optional lifecycle methods   |\n\n---\n\n### ğŸŒ€ `CallbacksReturn`\n\n| Method                   | Description                                                       |\n| ------------------------ | ----------------------------------------------------------------- |\n| `signIn(user)`           | Called after user is authenticated. Return `true` to allow login. |\n| `jwt(token, user?)`      | Customize JWT token if applicable.                                |\n| `session(session, user)` | Customize the session object before sending to client.            |\n\n---\n\n## ğŸ›¡ Security Tip\n\nAlways validate the `state` returned from GitHub against a CSRF token stored on your server before accepting the response.\n\n---\n"
    },
    {
      "id": 42,
      "path": "toolkit/middlewares/google-oauth2",
      "name": "Google Oauth2",
      "folder": "Toolkit/Middlewares",
      "content": "\n## @tezx/google-oauth2\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/google-oauth2.svg)\n\n### **Documentation**\n\n<https://developers.google.com/identity/protocols/oauth2>\n\n### **Configuration**\n\n<https://console.developers.google.com/apis/credentials>\n\nProvides:\n\n* **OAuth2 client initialization**\n* **Auth URL generation**\n* **Token verification middleware**\n* **Full TypeScript support** with JSDoc annotations\n\n---\n\n### ğŸ”§ Installation\n\n```bash\nnpm install @tezx/google-oauth2 @googleapis/oauth2\n```\n\nOr with Yarn:\n\n```bash\nyarn add @tezx/google-oauth2 @googleapis/oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx google-auth -- --template google-oauth2 --y\n```\n\n---\n\n### ğŸš€ Quick Start\n\n```ts\nimport { TezX } from 'tezx';\nimport { GoogleOauthClient, getGoogleOAuthURL, verifyGoogleToken } from '@tezx/google-oauth2';\n\nconst app = new TezX({\n  debugMode: true,\n});\n\n// 1. Initialize OAuth2 client\nconst client = GoogleOauthClient({\n  clientId: process.env.GOOGLE_CLIENT_ID!,\n  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000/auth/callback',\n});\n\n// 2. Route to start Google login\napp.get('/auth/google', getGoogleOAuthURL({\n  authClient: client,\n  scopes: ['openid','email','profile'],\n}), (ctx) => {\n  return ctx.redirect(ctx.state.get('google_oauth_url'));\n});\n\n// 3. Callback route, verify token and establish session\napp.get('/auth/callback', verifyGoogleToken({\n  authClient: client,\n  onError: (err) => {\n    console.error('OAuth Error:', err);\n    // handle error or redirect\n  },\n  onSuccess: (tokens) => {\n    console.log('Tokens:', tokens);\n  },\n  Callbacks: (ctx)=> {\n    return {\n    signIn: async (user) => {\n      // e.g. allow only users from a domain\n      return user.email.endsWith('@yourcompany.com');\n    },\n    jwt: async (token, user) => {\n      // attach roles or custom claims\n      token.role = user.email_verified ? 'member' : 'guest';\n      return token;\n    },\n    session: async (session, user) => {\n      // persist user profile in session\n      session.user = {\n        id: user.sub,\n        email: user.email,\n        name: user.name,\n        picture: user.picture\n      };\n      return session;\n    }\n  }\n  } \n}), async (ctx) => {\n  // Now ctx.session is populated\n  return ctx.json({ success: true });\n});\n\n```\n\n---\n\n## ğŸ“š API Reference\n\n### `GoogleOauthClient(config) â†’ OAuth2Client`\n\nCreate a configured Google OAuth2 client.\n\n```ts\nimport type { OAuth2Client } from 'google-auth-library';\n\ninterface GoogleOauthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n}\n\n/**\n * @param config.clientId     Google OAuth Client ID.\n * @param config.clientSecret Google OAuth Client Secret.\n * @param config.redirectUri  Registered redirect URI.\n * @returns OAuth2Client\n */\nexport function GoogleOauthClient(config: GoogleOauthConfig): OAuth2Client;\n```\n\n---\n\n### `getGoogleOAuthURL(params) â†’ Middleware`\n\nGenerate and store the Google authentication URL in `ctx.state`.\n\n```ts\ninterface OAuthURLParams {\n  authClient: OAuth2Client;\n  scopes?: string[];               // default ['openid','email','profile']\n  loginHint?: string;              // optional, e.g. user email\n  prompt?: string;                 // default 'consent select_account'\n  accessType?: 'online'|'offline'; // default 'offline'\n  includeGrantedScopes?: boolean;  // default true\n}\n\n/**\n * Middleware that adds `state` header, generates auth URL, and redirects.\n * On success: ctx.state.get('google_oauth_url') contains the URL.\n */\nexport function getGoogleOAuthURL(params: OAuthURLParams): Middleware<any>;\n```\n\n---\n\n### `verifyGoogleToken(params) â†’ Middleware`\n\nValidate the OAuth callback, exchange the code, verify ID token, and invoke your callbacks.\n\n```ts\nexport type CallbacksReturn = {\n    /**\n     * Callback function called when a user signs in successfully.\n     * \n     * @param {User} user - The user object containing user details such as email, name, etc.\n     * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the sign-in is allowed. \n     *         If `false`, the sign-in will be rejected; if `true`, the sign-in will proceed.\n     * \n     * @example\n     * const callbacks = {\n     *     signIn: async (user) => {\n     *         // Check if the user is allowed to sign in\n     *         return user.email.endsWith('@example.com');\n     *     }\n     * };\n     */\n    signIn?: (user: User) => Promise<boolean>;\n\n    /**\n     * Callback function for handling JWT (JSON Web Token) creation or modification.\n     * \n     * @param {any} token - The token object that contains the user's authentication information.\n     * @param {User} [user] - The user object, which may be available depending on the context.\n     * @returns {Promise<any>} - A promise that resolves to a possibly modified token or additional data to be included with the token.\n     * \n     * @example\n     * const callbacks = {\n     *     jwt: async (token, user) => {\n     *         // Add custom data to the token, like user role\n     *         token.role = user?.role || 'guest';\n     *         return token;\n     *     }\n     * };\n     */\n    jwt?: (token: any, user?: User) => Promise<any>;\n\n    /**\n     * Callback function for handling user session management.\n     * \n     * @param {any} session - The session object containing session data.\n     * @param {User} user - The user object containing the authenticated user's information.\n     * @returns {Promise<any>} - A promise that resolves to the modified session data or a session object.\n     * \n     * @example\n     * const callbacks = {\n     *     session: async (session, user) => {\n     *         // Modify session object, e.g., store user roles or permissions in the session\n     *         session.userRole = user?.role || 'guest';\n     *         return session;\n     *     }\n     * };\n     */\n    session?: (session: any, user: User) => Promise<any>;\n};\n\nexport type Callbacks = (ctx: Context) => CallbacksReturn;\n\ninterface VerifyParams {\n  authClient: OAuth2Client;\n  onError?: (error: string) => void;\n  onSuccess?: (tokens: any, response: any) => void;\n  Callbacks: Callbacks;\n}\n\n/**\n * Middleware that:\n * 1. Exchanges `code` for tokens  \n * 2. Validates `id_token` audience  \n * 3. Executes `signIn`, `jwt`, `session` callbacks  \n * 4. Calls onSuccess or onError  \n */\nexport function verifyGoogleToken(params: VerifyParams): Middleware<any>;\n```\n\n---\n\n### ğŸ“ `User` & `Credentials` Types\n\n```ts\n/** Google user info returned by tokeninfo endpoint */\nexport type GoogleUser = {\n    iss: string;\n    azp: string;\n    aud: string;\n    sub: string;\n    email: string;\n    email_verified: string;\n    at_hash: string;\n    name: string;\n    picture: string;\n    given_name: string;\n    family_name: string;\n    iat: string;\n    exp: string;\n    alg: string;\n    kid: string;\n    typ: string;\n  // ...other standard claims\n};\n\n/** OAuth2 token set returned by getToken() */\nexport interface Credentials {\n  access_token?: string;\n  refresh_token?: string;\n  expiry_date?: number;\n  id_token?: string;\n  token_type?: string;\n  scope?: string;\n}\n```\n\n---\n\n## ğŸ›¡ Security & Best Practices\n\n* **State parameter**: Mitigate CSRF by using `state`.\n* **Prompt & access\\_type**: Use `offline` + `prompt='consent'` to receive refresh tokens.\n* **Scope minimization**: Request only the scopes you need.\n* **Token handling**: Securely store `refresh_token` if you need longâ€‘lived access.\n\n---\n"
    },
    {
      "id": 43,
      "path": "toolkit/middlewares/tezx-profiler",
      "name": "Tezx profiler",
      "folder": "Toolkit/Middlewares",
      "content": "# @tezx/profiler\n\nA lightweight, extensible profiling middleware for the [TezX](https://www.npmjs.com/package/tezx) framework. This module enables detailed tracking of runtime performance metrics, memory usage, CPU statistics, and supports custom plugins and rotating file storage.\n\n---\n\n## ğŸš€ Features\n\n- â±ï¸ Measure route execution time.\n- ğŸ’¾ Monitor memory usage in MB.\n- âš™ï¸ Capture CPU usage in milliseconds.\n- ğŸ“Š System stats endpoint (`/__profiler`) with a clean UI.\n- ğŸ”Œ Plugin hooks (`beforeProfile`, `afterProfile`).\n- ğŸ“ Rotating file storage for logs.\n- âœ… Written in TypeScript with full type safety.\n- ğŸŒ Supports Node.js, Deno, and Bun environments.\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/profiler\n```\n\n---\n\n## ğŸ› ï¸ Usage Example\n\n### Basic Setup\n\n```ts\nimport { TezX } from 'tezx';\nimport { profiler, createRotatingFileStorage } from '@tezx/profiler';\n\nconst app =new TezX();\n\napp.use(\n  profiler({\n    route: '/__profiler',\n    excludePaths: ['/favicon.ico'],\n    metrics: ['time', 'memory', 'cpu'],\n    storage: createRotatingFileStorage('./profiler.log', 1024 * 1024), // Rotate every 1MB\n    plugins: [],\n  })\n);\n\napp.get('/', (ctx) => ctx.json({ message: 'Hello World' }));\n\n```\n\n---\n\n## ğŸŒ Profiler UI\n\nVisit your app at:\n\n```bash\nhttp://localhost:3000/__profiler\n```\n\nYou'll see:\n\n- âœ… Uptime (seconds)\n- âœ… Timestamp\n- âœ… Memory Usage (rss, heapTotal, heapUsed, etc.) in MB\n- âœ… CPU Usage (user/system) in milliseconds\n\n---\n\n## âš™ï¸ Profiler Options\n\n| Option           | Type                                        | Default         | Description                             |\n|------------------|---------------------------------------------|-----------------|-----------------------------------------|\n| `route`          | `string`                                    | `/__profiler`   | Path to view system stats               |\n| `excludePaths`   | `string[]`                                  | `[]`            | Paths to ignore                         |\n| `metrics`        | `(\\\"time\\\" \\| \\\"memory\\\" \\| \\\"cpu\\\")[]`     | `['time', 'memory']` | Metrics to collect                |\n| `storage`        | `StorageAdapter`                            | `undefined`     | Save profile results                   |\n| `plugins`        | `ProfilerPlugin[]`                          | `[]`            | Hook into the profiling lifecycle      |\n\n---\n\n## ğŸ”Œ Plugins Example\n\n```typescript\nconst myPlugin = {\n  beforeProfile: () => console.log('Starting profiling...'),\n  afterProfile: (result) => console.log('Profile completed:', result),\n};\n\napp.use(profiler({ plugins: [myPlugin] }));\n```\n\n---\n\n## ğŸ—ƒï¸ Rotating File Storage Example\n\n```typescript\nconst storage = createRotatingFileStorage('./profiler.log', 1024 * 1024); // 1MB rotation\n\napp.use(profiler({ storage }));\n```\n\n- File automatically rotates when it reaches the configured size.\n- Supports Node.js, Deno, Bun file systems.\n\n---\n\n## ğŸ§‘â€ğŸ’» Example Profile Output\n\n```json\n{\n  \"name\": \"default\",\n  \"duration\": 6.25,\n  \"timestamp\": \"2025-07-06T19:25:47.753Z\",\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"memoryUsage\": {\n    \"rss\": 10485760,\n    \"heapTotal\": 6291456,\n    \"heapUsed\": 4194304,\n    \"external\": 102400,\n    \"arrayBuffers\": 51200\n  },\n  \"cpuUsage\": {\n    \"user\": 1416,\n    \"system\": 312\n  }\n}\n```\n\n---\n\n## âš¡ System Stats Breakdown\n\n### Memory Usage\n\n- `rss`: Resident Set Size (total memory allocated for the process)\n- `heapTotal`: Total size of allocated heap\n- `heapUsed`: Heap actually used\n- `external`: Memory used by C++ objects bound to JS\n- `arrayBuffers`: Memory allocated for ArrayBuffer\n\n### CPU Usage\n\n- `user`: Time spent in user mode (Î¼s)\n- `system`: Time spent in kernel mode (Î¼s)\n\n---\n\n## ğŸ” Environment Support\n\nâœ”ï¸ Node.js\nâœ”ï¸ Deno\nâœ”ï¸ Bun\n\n---\n<!-- \n## ğŸ” Future Enhancements\n\n- ğŸ”„ Redis or database storage adapters\n- ğŸ“ˆ Export metrics in Prometheus format\n- ğŸŒ Remote profiling dashboard -->\n\n---\n\n## ğŸ“œ License\n\nMIT Â© 2025 TezX Team\n"
    },
    {
      "id": 44,
      "path": "toolkit/helpers/devtools",
      "name": "Devtools",
      "folder": "Toolkit/Helpers",
      "content": "\n# ğŸ“Š TezX DevTools\n\n> Developer-friendly diagnostics and inspector panel for TezX-based applications. Plug in to see routes, middlewares, env variables, cookies, and add your own custom debug tabs.\n\n---\n\n## âœ… Installation\n\n```bash\nnpm install @tezx/devtools\n```\n\nEnsure you also have:\n\n```bash\nnpm install tezx\n```\n\n---\n\n## ğŸš€ Quick Usage\n\nIn your TezX app entry (e.g., `server.ts` or `index.ts`):\n\n```ts\nimport { TezX } from \"tezx\";\nimport {nodeAdapter} from \"tezx/node\";\nimport DevTools from \"@tezx/devtools\";\n\nconst app = new TezX();\n\napp.get(\n  \"/devtools\",\n  DevTools(app, {\n    // Optional\n    // disableTabs: ['cookies', 'routes'],\n    // extraTabs: (ctx) => [ ... ]\n  })\n);\n\nnodeAdapter(app).listen(3000);\n```\n\nNow visit:\n**`http://localhost:3000/devtools`**\nto see a real-time diagnostic dashboard.\n\n---\n\n## ğŸ§© Built-in Tabs\n\n| Tab           | Description                                              |\n| ------------- | -------------------------------------------------------- |\n| `routes`      | Lists all loaded routes with method, path, and source    |\n| `middlewares` | Displays registered middleware and which routes use them |\n| `cookies`     | Shows request cookies (parsed from `ctx`)                |\n| `.env`        | Displays environment variables loaded via `.env`         |\n\n---\n\n## âš™ï¸ API: `DevTools(app, options)`\n\n```ts\nDevTools(app: TezX<any>, options?: Options): Callback\n```\n\n### Options\n\n| Option        | Type                                                      | Description             |\n| ------------- | --------------------------------------------------------- | ----------------------- |\n| `extraTabs`   | `(ctx) => TabType \\| Promise<TabType>`                    | Add your own tab panels |\n| `disableTabs` | `Array<'cookies' \\| 'routes' \\| '.env' \\| 'middlewares'>` | Hide built-in tabs      |\n\n---\n\n## ğŸ› ï¸ Add Custom Tabs\n\nYou can inject your own debug panels using the `extraTabs` option.\n\n```ts\nimport DevTools , { dumpMiddlewares } from \"@tezx/devtools\";\n\napp.get(\n  \"/devtools\",\n  DevTools(app, {\n    extraTabs(ctx) {\n      const rows = dumpMiddlewares(app)\n        .map(r => `<tr><td>${r.endpoint}</td><td>${r.pattern}</td><td>${r.appliedMiddlewares}</td></tr>`)\n        .join(\"\");\n      return [\n        {\n          tab: \"middlewares\",\n          label: \"Middleware Table\",\n          doc_title: \"Middleware Overview\",\n          content: `<table>${rows}</table>`\n        }\n      ];\n    }\n  })\n);\n```\n\n---\n\n## ğŸ“š Types\n\n```ts\ntype Tab = \"cookies\" | \"routes\" | \".env\" | \"middlewares\";\n\ntype TabType = {\n  doc_title: string;\n  label: string;\n  tab: Tab | string;\n  content: string; // Rendered HTML content\n}[];\n\ntype Options = {\n  extraTabs?: (ctx: Context) => Promise<TabType> | TabType;\n  disableTabs?: Tab[];\n};\n```\n\n---\n\n## ğŸ“ Directory Example\n\n**Using `tezx/router`**\n\n```bash\nmy-app/\nâ”œâ”€â”€ routes/\nâ”‚   â”œâ”€â”€ _middleware.ts\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ public/\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ tezx.config.mjs             â† setup TezX + DevTools here\nâ”œâ”€â”€ .env\nâ”œâ”€â”€ package.json\nâ””â”€â”€ tsconfig.json\n```\n\n---\n"
    },
    {
      "id": 45,
      "path": "toolkit/helpers/tezx-localfs",
      "name": "TezX localfs",
      "folder": "Toolkit/Helpers",
      "content": "# @tezx/localfs\n\n`@tezx/localfs` is a simple, runtime-agnostic local file storage library that works with Node.js, Deno, and Bun.\n\nIt allows you to:\n\n* Save files to the local disk.\n* Automatically detect file types.\n* Auto-create directories.\n* Validate file size & type.\n* Generate public URLs for serving files.\n* List files (with recursive support).\n\n---\n\n## âœ¨ Features\n\n* ğŸ‘ TypeScript ready\n* âœ… Cross-runtime support (Node.js, Deno, Bun)\n* ğŸ“ Auto-create directories when saving files\n* ğŸ” Auto-detect MIME types from file extensions\n* âš™ï¸ Secure file-type filtering based on allowed MIME types\n* ğŸ”— Generate public URLs for serving files\n* ğŸ™ï¸ Public file serving router (TezX Router)\n* ğŸ“‚ List files recursively or non-recursively\n* ğŸ§© Built-in TezX Router for serving static files\n\n---\n\n## ğŸ“¦ Installation\n\n### Node.js / Bun\n\n```bash\nnpm install @tezx/localfs\n# OR\nbun add @tezx/localfs\n```\n\n---\n\n## ğŸ”§ Basic Example (Node.js)\n\n```ts\nimport { LocalFS } from \"@tezx/localfs\";\nimport { readFile } from \"node:fs/promises\";\n\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n\nasync function run() {\n  const buffer = await readFile(\"photo.jpg\");\n\n  const saved = await storage.saveFile(\"photo.jpg\", buffer);\n  console.log(\"File saved:\", saved);\n\n  const files = await storage.listFiles(\"\", true);\n  console.log(\"All files:\", files);\n}\n\nrun();\n```\n\n---\n\n## ğŸ”¹ API Reference\n\n### new LocalFS(options)\n\n| Option               | Type       | Default    | Description                    |\n| -------------------- | ---------- | ---------- | ------------------------------ |\n| basePath             | `string`   | `uploads`  | Folder to save files           |\n| publicUrl            | `string`   | `/uploads` | Public path prefix             |\n| allowPublicAccess    | `boolean`  | `true`     | Enable/disable public serving  |\n| autoRenameOnConflict | `boolean`  | `true`     | Rename files if name conflicts |\n| maxFileSize          | `number`   | `5MB`      | Max upload size in bytes       |\n| allowedTypes         | `string[]` | `image/*`  | Allowed MIME types             |\n\n---\n\n### saveFile(fileName, buffer, mimeType?)\n\nSaves a file to the storage.\n\nReturns:\n\n```json\n{\n  \"savedPath\": \"uploads/photo.jpg\",\n  \"fileName\": \"photo.jpg\",\n  \"publicUrl\": \"/uploads/photo.jpg\"\n}\n```\n\n---\n\n### readFile(fileName)\n\nReads file contents as a `Buffer`.\n\n---\n\n### deleteFile(fileName)\n\nDeletes a file from the disk.\n\n---\n\n### listFiles(folder = '', recursive = false)\n\nLists file names from a folder.\n\nExample output:\n\n```json\n[\n  \"photo.jpg\",\n  \"nested/file.pdf\"\n]\n```\n\n---\n\n### getPublicUrl(fileName)\n\nGenerates the public URL for a file.\n\nExample:\n\n```ts\nstorage.getPublicUrl(\"photo.jpg\");\n// \"/uploads/photo.jpg\"\n```\n\n---\n\n### serveFileResponse()\n\nReturns a TezX Router instance to serve static files from your storage folder.\n\nExample:\n\n```ts\napp.use(storage.serveFileResponse());\n```\n\nThen files are available at:\n\n```bash\n/uploads/photo.jpg\n```\n\n---\n\n## ğŸŒ Example Use with TezX API Router\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files;\n\n  const buffer = Buffer.from(await file.arrayBuffer());\n  const result = await storage.saveFile(file.name, buffer);\n\n  return ctx.json(result);\n});\n\napp.use(storage.serveFileResponse());\n```\n\n---\n\n## ğŸ”¹ Runtime Support\n\n| Runtime | Supported |\n| ------- | --------- |\n| Node.js | âœ…         |\n| Deno    | âœ…         |\n| Bun     | âœ…         |\n\n---\n\n# LocalFS Usage Docs\n\n## ğŸ”¹ Setup\n\n```ts\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n```\n\n## ğŸ“‚ Saving a File\n\n```ts\nconst buffer = await readFile(\"./logo.png\");\nconst saved = await storage.saveFile(\"logo.png\", buffer);\nconsole.log(saved);\n```\n\n---\n\n## ğŸ”¹ Listing Files\n\n```ts\nawait storage.listFiles(); // Non-recursive\nawait storage.listFiles(\"\", true); // Recursive\n```\n\n---\n\n## ğŸ”¹ Deleting Files\n\n```ts\nawait storage.deleteFile(\"logo.png\");\n```\n\n---\n\n## ğŸ”¹ Reading Files\n\n```ts\nconst content = await storage.readFile(\"logo.png\");\n```\n\n---\n\n## ğŸ”¹ Serving Public Files\n\n```ts\napp.use(storage.serveFileResponse());\n\n// Now accessible at: /uploads/logo.png\n```\n\n---\n\n## ğŸ”¹ Error Example\n\n```bash\nError: File type application/x-sh is not allowed\n```\n\n---\n"
    },
    {
      "id": 46,
      "path": "toolkit/helpers/tezx-session",
      "name": "TezX session",
      "folder": "Toolkit/Helpers",
      "content": "# âš¡ @tezx/session\n\n### Simple, Secure & Type-Safe Session Middleware for **TezX**\n\nBuild scalable applications with pluggable session storage, secure cookies, and developer-friendly TypeScript APIs.\n\n---\n\n## âœ¨ Features\n\n* âœ… **Type-Safe** session data (Generics support)\n* ğŸ” Secure, HTTP-only cookie session IDs\n* âš™ï¸ Customizable session storage (Memory, Redis, etc.)\n* ğŸ”„ Simple Middleware: `useSession()`, `createSession()`, `destroySession()`\n* ğŸŒ CORS-friendly: Supports `credentials: 'include'`\n* ğŸ§© Extensible for microservices & SSR apps\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/session\n```\n\nOR\n\n```bash\npnpm add @tezx/session\n```\n\n---\n\n## âš™ï¸ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { SessionManager } from \"@tezx/session\";\n\nconst app = new TezX();\n\nconst sessionManager = new SessionManager({\n  sessionName: \"tezx.sid\",\n  cookie: { maxAge: 1000 * 60 * 30, httpOnly: true, secure: true, sameSite: \"lax\" },\n});\n\n// Load session before routes\napp.use(sessionManager.useSession());\n\n// Login route â†’ create session\napp.post(\"/login\", async (ctx) => {\n  await sessionManager.createSession({ userId: 99, role: \"admin\" }, ctx);\n  return ctx.json({ success: true });\n});\n\n// Protected route â†’ read session\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ session: ctx.session?.data });\n});\n\n// Logout â†’ destroy session\napp.post(\"/logout\", async (ctx) => {\n  await ctx.session?.destroy();\n  return ctx.json({ loggedOut: true });\n});\n```\n\n---\n\n## ğŸ›¡ï¸ API Documentation\n\n### ğŸ”‘ SessionManager\n\n| Method             | Description                                 |\n| ------------------ | ------------------------------------------- |\n| `createSession()`  | Create and save a session                   |\n| `useSession()`     | Middleware: Load session from cookie        |\n| `destroySession()` | Destroy session from store and clear cookie |\n\n---\n\n### ğŸ“„ `createSession(data, ctx)`\n\n* Creates a session.\n* Automatically sets a session cookie in the response.\n* Saves session data to the configured storage.\n\nExample:\n\n```ts\nawait sessionManager.createSession({ userId: 101 }, ctx);\n```\n\n---\n\n### ğŸ”„ `useSession()`\n\nMiddleware for **loading session** on every request:\n\n* Reads session cookie\n* Loads session data from storage\n* Adds `ctx.session` to your context.\n\nExample:\n\n```ts\napp.use(sessionManager.useSession());\n```\n\n---\n\n### âŒ `destroySession()`\n\nDeletes the session from storage and removes the cookie:\n\n```ts\nawait sessionManager.destroySession(sessionId);\n```\n\n---\n\n## ğŸ”§ Configuration Options\n\n```ts\nconst sessionManager = new SessionManager({\n  sessionName: \"my_session\",\n  cookie: {\n    maxAge: 1000 * 60 * 30, // 30 min\n    secure: true,\n    httpOnly: true,\n    sameSite: \"lax\",\n  },\n  storage: new MemoryStore(), // Or your own adapter\n});\n```\n\n| Option          | Type                    | Description                            |\n| --------------- | ----------------------- | -------------------------------------- |\n| sessionName     | `string`                | Name of the cookie key                 |\n| sessionId       | `(ctx) => string`       | Custom session ID generator (optional) |\n| cookie.maxAge   | `number`                | Expiry in ms                           |\n| cookie.secure   | `boolean`               | Only send cookie on HTTPS              |\n| cookie.httpOnly | `boolean`               | Prevent JS access to cookie            |\n| cookie.sameSite | `\"lax\" \\| \"strict\" \\| \"none\"` | SameSite attribute             |\n| storage         | `SessionStorageAdapter` | Custom storage engine                  |\n\n---\n\n## ğŸ§° Example with Redis Storage\n\n```ts\n\nimport type { SessionStorageAdapter, SessionInstance } from \"@tezx/session\";\nimport type { RedisClientType } from \"redis\";\n\nexport class RedisStore implements SessionStorageAdapter {\n  private redisClient: RedisClientType;\n  private prefix: string;\n\n  /**\n   * Create RedisStore adapter.\n   * @param redisClient - Connected Redis client instance.\n   * @param prefix - Optional key prefix for session keys.\n   */\n  constructor(redisClient: RedisClientType, prefix = \"tezx:session:\") {\n    this.redisClient = redisClient;\n    this.prefix = prefix;\n  }\n\n  private getKey(sessionId: string) {\n    return `${this.prefix}${sessionId}`;\n  }\n\n  async get(sessionId: string): Promise<SessionInstance | undefined> {\n    const key = this.getKey(sessionId);\n    const data = await this.redisClient.get(key);\n    if (!data) return undefined;\n\n    try {\n      const parsed = JSON.parse(data);\n      const redisStore = this;\n      return {\n        sessionId: parsed.sessionId,\n        data: parsed.data,\n        async save() {\n          await redisStore.set(this.sessionId, this);\n        },\n        async destroy() {\n          await redisStore.destroy(this.sessionId);\n        },\n      } as SessionInstance;\n    } catch {\n      return undefined;\n    }\n  }\n\n  async set(sessionId: string, data: SessionInstance, maxAge?: number): Promise<void> {\n    const key = this.getKey(sessionId);\n    const value = JSON.stringify({ sessionId, data: data.data });\n    if (maxAge) {\n      // maxAge in ms, Redis EXPIRE in seconds\n      await this.redisClient.set(key, value, {\n        PX: maxAge,\n      });\n    } else {\n      await this.redisClient.set(key, value);\n    }\n  }\n\n  async destroy(sessionId: string): Promise<void> {\n    const key = this.getKey(sessionId);\n    await this.redisClient.del(key);\n  }\n}\n\nconst redisStore = new RedisStore(redisClient);\n\nconst sessionManager = new SessionManager({\n  storage: redisStore,\n  cookie: { maxAge: 1000 * 60 * 60 }, // 1 hour\n});\n```\n\n---\n\n## âš ï¸ CORS & Cookie Notes\n\nFor frontend requests (if CORS enabled):\n\n* Set credentials in the fetch request:\n\n```js\nfetch(\"/profile\", { credentials: \"include\" });\n```\n\n* Server-side: Configure CORS to allow credentials and the origin.\n\n---\n\n## ğŸ”¨ Type Safety\n\n```ts\nconst sessionManager = new SessionManager<{ userId: number, role: string }>();\n\nawait sessionManager.createSession({ userId: 1, role: \"admin\" }, ctx);\n```\n\nNow your `ctx.session.data` will always have `userId` and `role`.\n\n---\n\n## ğŸ”® Advanced Topics\n\n* Redis, MongoDB, File storage adapters\n* Regenerate session IDs on login/logout\n* Auto session expiry + cleanup\n* Session encryption for sensitive data\n* Shared session across subdomains\n\n---\n\n## âœ… License\n\nMIT Â© TezX\n\n---\n"
    },
    {
      "id": 47,
      "path": "toolkit/utilities/tezx-rbac",
      "name": "TezX rbac",
      "folder": "Toolkit/Utilities",
      "content": "# ğŸ” @tezx/rbac\n\nA powerful, fully type-safe **Role-Based Access Control (RBAC)** plugin for [TezX](https://www.npmjs.com/package/tezx), designed to help you **control access to routes, APIs, and resources** using simple, template-based permission keys with full IntelliSense support.\n\n---\n\n## ğŸš€ Highlights\n\n- ğŸ¯ Type-safe permission system (`T extends string[]`)\n- ğŸ§  IntelliSense-based permission enforcement\n- ğŸ” Multi-role support (`ctx.user.role` can be `string | string[]`)\n- âš™ï¸ Middleware-driven, plug-and-play\n- âŒ Built-in denial handling + custom `onDeny()` support\n- ğŸ§© Easy integration with auth middlewares (like `authChecker`)\n- ğŸ§ª Battle-tested in production apps\n- ğŸ”‘ Use role IDs(Dynamically generated, flexible)\n- ğŸ” Clean merge of all permissions (No manual logic needed)\n- ğŸ·ï¸ Static roles still supported (Easy for default usage)\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/rbac\n````\n\n---\n\n## ğŸ§  How It Works\n\n```bash\n[Your Middleware]\n    â¬‡ï¸ sets ctx.user.role\n[RBAC Plugin]\n    â¬‡ï¸ loads permission map\n[Route Guard]\n    â¬‡ï¸ checks permission key\n[âœ“ ALLOW] or [âŒ DENY]\n```\n\n---\n\n## âš ï¸ Required: `ctx.user.role`\n\nTo work correctly, you **must set** `ctx.user.role` before using RBAC.\n\nâœ… Example:\n\n```ts\nctx.user = {\n  id: 'user_001',\n  role: 'admin',  // âœ… Required\n  email: 'rakib@example.com'\n};\n```\n\nâœ… If roles can be multiple:\n\n```ts\nctx.user = {\n  role: ['editor', 'viewer']\n};\n```\n\n> ğŸ’¡ Use `authChecker()` middleware to assign `ctx.user` from token/session.\n\n---\n\n## ğŸ§‘â€ğŸ’» Usage Example\n\n```ts\n\nimport RBAC from '@tezx/rbac';\ntype Permissions = ['user:create', 'user:delete', 'order:read', 'property:approve'];\n\nconst rbac = new RBAC<Permissions>();\n\napp.use(authChecker()); // âœ… Assigns ctx.user + ctx.user.role\n\napp.use(rbac.plugin({\n  loadPermissions: async () => ({\n    admin: ['user:create', 'user:delete', 'order:read', 'property:approve'],\n    editor: ['order:read'],\n    guest: []\n  })\n}));\n\napp.get('/admin/users', rbac.authorize('user:create'), async (ctx) => {\n  return ctx.text('You can create users.');\n});\n\n```\n\n---\n\n## ğŸ“Œ RBAC Lifecycle\n\n| Step | Action                                                            |\n| ---- | ----------------------------------------------------------------- |\n| 1ï¸âƒ£  | `ctx.user.role` assigned by auth middleware                       |\n| 2ï¸âƒ£  | `rbac.plugin()` loads Roleâ†’Permission map                         |\n| 3ï¸âƒ£  | `rbac.authorize('permission:key')` checks merged role permissions |\n| 4ï¸âƒ£  | If not allowed â†’ return `403` (with `onDeny` if provided)         |\n\n---\n\n### ğŸ” Replace `role` with Unique Role IDs (Advanced)\n\nRBAC system supports mapping **dynamic role identifiers** (like database IDs or UUIDs) instead of hardcoded role names.\n\nThis is helpful when:\n\n- âœ… Roles are created dynamically from a dashboard or DB\n- âœ… You want to map user roles like `\"role_8FaHq1\"` instead of just `\"admin\"`\n- âœ… Permission sets are assigned to these dynamic IDs\n\n#### ğŸ§ª Example\n\n```ts\nctx.user = {\n  id: 'user_xyz',\n  role: 'role_8FaHq1' // âœ… Your actual role ID from database\n};\n```\n\n```ts\n// Load role-permission map based on DB role IDs\nloadPermissions: async () => ({\n  role_8FaHq1: ['user:create', 'order:read'],\n  role_7NbQt55: ['user:delete']\n})\n```\n\n> âœ… Internally, `RBAC` merges all permissions based on the provided `ctx.user.role`, whether it's `string` or `string[]`.\n\n#### âš ï¸ Important\n\nMake sure the role ID you assign in `ctx.user.role` **exactly matches** the keys in your permission map.\n\n---\n\n### Bonus: Hybrid Role Support\n\nYou can even mix static roles with dynamic IDs if needed:\n\n```ts\nctx.user = {\n  role: ['admin', 'role_7bXy91']\n};\n\nloadPermissions: async () => ({\n  admin: ['dashboard:access'],\n  role_7bXy91: ['product:create']\n});\n```\n\n---\n\n## ğŸ§© Plugin API\n\n### `rbac.plugin(config)`\n\nInitializes the permission map.\n\n**Config options:**\n\n| Field             | Type                         | Required | Description           |\n| ----------------- | ---------------------------- | -------- | --------------------- |\n| `loadPermissions` | `(ctx) => RolePermissionMap` | âœ…        | Role â†’ permission map |\n| `isAuthorized`    | `(roles, permissions, ctx)`  | âŒ        | Custom check hook     |\n| `onDeny`          | `(error, ctx)`               | âŒ        | Custom deny response  |\n\n---\n\n### `rbac.authorize('permission:key')`\n\nMiddleware to protect routes.\n\n```ts\napp.post('/orders', rbac.authorize('order:read'), handler);\n```\n\n---\n\n## ğŸ’¡ IntelliSense with Template Types\n\n```ts\ntype Permissions = ['user:create', 'order:read', 'admin:panel'];\n\nconst rbac = new RBAC<Permissions>();\n```\n\nâœ… Now `rbac.authorize(...)` will auto-suggest only those permission keys.\n\n---\n\n## âŒ Custom Deny Example\n\n```ts\nrbac.plugin({\n  loadPermissions: ...,\n  onDeny: (error, ctx) => {\n    return ctx.json({\n      success: false,\n      reason: error.message,\n      permission: error.permission\n    });\n  }\n});\n```\n\n---\n\n## ğŸ” Real-World Structure\n\n```ts\nconst permissionMap = {\n  admin: ['user:create', 'user:delete'],\n  editor: ['order:read'],\n  viewer: [],\n};\n```\n\nUser may have:\n\n```ts\nctx.user = {\n  id: 'u-001',\n  role: ['editor', 'viewer']\n};\n```\n\nRBAC will combine permissions from both roles.\n\n---\n\n## ğŸ”¥ Debug Tip\n\nTo check permissions being applied at runtime:\n\n```ts\nconsole.log(ctx.user.permissions); // all merged permissions\n```\n\n---\n\n## ğŸ“š Types Summary\n\n```ts\ntype RolePermissionMap<T extends string[]> = Record<string, T[number][]>;\ntype DenyError<T extends string[]> = {\n  error: string;\n  message: string;\n  permission: T[number];\n};\n```\n\n---\n\n## ğŸ“¦ Exported API\n\n```ts\nimport RBAC, { plugin, authorize } from '@tezx/rbac';\n```\n\n---\n\n## ğŸ§ª Test Route Example\n\n```ts\napp.get('/secure', rbac.authorize('admin:panel'), async (ctx) => {\n  ctx.body = { status: 'Access granted.' };\n});\n```\n\n---\n\n## âœ… Best Practices\n\n- ğŸ”„ Always assign `ctx.user.role` in `authChecker`\n- ğŸ§  Define permissions centrally as union literal type\n- ğŸ” Protect all critical routes using `rbac.authorize()`\n- ğŸ§ª Add logging inside `onDeny` for better traceability\n\n---\n"
    },
    {
      "id": 48,
      "path": "toolkit/utilities/view-engine",
      "name": "View Engine",
      "folder": "Toolkit/Utilities",
      "content": "# @tezx/view-engine\n\nA flexible, powerful, and runtime-aware view engine utility for server-side rendering (SSR) with support for **Node.js**, **Bun**, and **Deno**.\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/view-engine.svg)\n\n> ğŸ”§ Supports `ejs`, `pug`, `handlebars`, `nunjucks`, and `mustache` templates out of the box.\n\n---\n\n## âœ¨ Features\n\n- âœ… Supports multiple template engines\n- ğŸ§  Built-in caching for improved performance\n- ğŸª„ Optional file extension overrides\n- ğŸŒ Cross-runtime support: Node.js, Bun, Deno\n- ğŸ“¦ Lightweight and framework-agnostic\n- ğŸ” Ideal for SSR in Tezx or any TS/JS backend\n\n---\n\n## ğŸ“¦ Installation\n\n```bash\nnpm install @tezx/view-engine\n# or\nbun add @tezx/view-engine\n````\n\n### **Template**\n\n```bash\nnpm create tezx view-engine -- --template view-engine --y\n```\n\n### **Require**\n\n```bash\n# EJS\nnpm install ejs\n\n# Pug (formerly Jade)\nnpm install pug\n\n# Handlebars\nnpm install handlebars\n\n# Nunjucks (Jinja2-like templating)\nnpm install nunjucks\n\n# Mustache\nnpm install mustache\n\n```\n\n---\n\n## ğŸš€ Usage\n\n```ts\nimport { ViewEngine } from \"@tezx/view-engine\";\n\nconst views = new ViewEngine(\"ejs\", \"./views\");\n\nconst html = await views.render(\"home\", {\n  title: \"Welcome!\",\n  user: { name: \"Rakibul\" },\n});\n\n// In your Tezx handler:\nctx.html(html);\n```\n\n---\n\n## ğŸ”§ Constructor\n\n```ts\nnew ViewEngine(engine: TemplateEngine, viewsPath: string, options?: ViewEngineOptions)\n```\n\n### Parameters\n\n| Name        | Type                   | Description                        |\n| ----------- | ---------------------- | ---------------------------------- |\n| `engine`    | `\"ejs\"`, `\"pug\"`, etc. | Template engine to use             |\n| `viewsPath` | `string`               | Path to the views/templates folder |\n| `options`   | `ViewEngineOptions`    | (Optional) Configuration options   |\n\n---\n\n## âš™ï¸ Options\n\n```ts\ninterface ViewEngineOptions {\n  cache?: boolean; // default: true\n  autoescape?: boolean; // default: true (nunjucks only)\n  extensionOverride?: Partial<Record<TemplateEngine, string>>;\n}\n```\n\n### Example\n\n```ts\nconst views = new ViewEngine(\"ejs\", \"./views\", {\n  cache: true,\n  extensionOverride: {\n    ejs: \".html.ejs\"\n  }\n});\n```\n\n---\n\n## ğŸ“š Supported Engines\n\n| Engine       | Extension   | Notes                       |\n| ------------ | ----------- | --------------------------- |\n| `ejs`        | `.ejs`      | Supports includes/partials  |\n| `pug`        | `.pug`      | Indentation-based templates |\n| `handlebars` | `.hbs`      | Logic-less templates        |\n| `nunjucks`   | `.njk`      | Powerful and Django-like    |\n| `mustache`   | `.mustache` | Minimal and logic-less      |\n\n---\n\n## ğŸ§  Runtime Compatibility\n\n| Runtime | Supported  | Notes                     |\n| ------- | ---------- | ------------------------- |\n| Node.js | âœ…          | Recommended               |\n| Bun     | âœ…          | Fully supported           |\n| Deno     | âœ…          | Fully supported           |\n\n---\n\n## ğŸ“‚ Example View Structure\n\n```bash\nviews/\nâ”œâ”€â”€ home.ejs\nâ”œâ”€â”€ layout.pug\nâ”œâ”€â”€ about.hbs\nâ”œâ”€â”€ user/\nâ”‚   â””â”€â”€ profile.mustache\n```\n\n---\n\n## âœ… Also include in your `docs/` folder\n\nYou can save this as:\n\n```bash\n/docs/view-engine.md\n````\n\nor\n\n```bash\nREADME.md â†’ root of helpers/view-engine/\n```\n"
    },
    {
      "id": 49,
      "path": "examples/uploader",
      "name": "Uploader",
      "folder": "Examples",
      "content": "\n# ğŸ“¤ File Upload Middleware\n\n## Overview\n\nTezX provides first-class support for file uploads via its `useFormData` utility, allowing you to handle file uploads with minimal setup. This example demonstrates how to accept, read, and save a file using native `fs/promises` and `path`.\n\n## Features\n\n* Parses incoming multipart/form-data requests.\n* Supports extracting and saving uploaded files.\n* Handles errors with clear responses.\n* Compatible with modern runtimes like Bun, Node.js, and Deno.\n\n---\n\n## Example Usage\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\nimport { useFormData } from \"tezx/helper\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await useFormData(ctx);\n  const file = formData?.files as File; // Get uploaded file\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Destination path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save to disk\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n\n---\n\n## ğŸ” Notes\n\n* Make sure the `uploads` directory exists or create it before saving.\n* `formData.files` can also be an array if multiple files are submitted.\n* To support multiple files, iterate over `formData.files`:\n\n```ts\nconst files = formData?.files as File[];\nfor (const file of files) {\n  const buffer = await file.arrayBuffer();\n  await writeFile(join(process.cwd(), \"uploads\", file.name), Buffer.from(buffer));\n}\n```\n\n---\n\n## ğŸ§ª Testing with cURL\n\n```bash\ncurl -F \"file=@/path/to/file.png\" http://localhost:3000/data\n```\n\n---\n"
    },
    {
      "id": 50,
      "path": "examples/basic-auth-client",
      "name": "Basic Auth Client",
      "folder": "Examples",
      "content": "# ğŸ” Accessing Protected Routes with Basic Authentication\n\nThis guide demonstrates how to access routes secured with HTTP Basic Authentication using various tools and libraries.\n\n---\n\n### **1. Using cURL**\n\n**Option 1: With `-u` flag (recommended)**\n\n```bash\ncurl -u username:password http://localhost:3000/protected\n```\n\n**Option 2: Manually set the `Authorization` header**\n\n```bash\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" http://localhost:3000/protected\n```\n\nâœ… `-u` automatically encodes credentials using Base64.\n\n---\n\n### **2. Using Postman**\n\n1. Open a new request in Postman.\n2. Navigate to the **Authorization** tab.\n3. Choose **Basic Auth** as the type.\n4. Enter your `username` and `password`.\n5. Click **Send**.\n\nPostman automatically encodes and adds the `Authorization` header.\n\n---\n\n### **3. Using JavaScript (Fetch API)**\n\n```js\nconst username = \"admin\";\nconst password = \"password123\";\n\nfetch(\"http://localhost:3000/protected\", {\n  method: \"GET\",\n  headers: {\n    Authorization: `Basic ${btoa(`${username}:${password}`)}`,\n  },\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\nğŸ” `btoa()` encodes the credentials in Base64 format.\n\n---\n\n### **4. Using Axios**\n\n```js\nconst axios = require(\"axios\");\n\naxios\n  .get(\"http://localhost:3000/protected\", {\n    auth: {\n      username: \"admin\",\n      password: \"password123\",\n    },\n  })\n  .then((res) => console.log(res.data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\nğŸ’¡ The `auth` option in Axios handles Base64 encoding internally.\n\n---\n"
    },
    {
      "id": 51,
      "path": "examples/sse-implement",
      "name": "SSE implement",
      "folder": "Examples",
      "content": "\n# ğŸ“¡ `app.sse(path, handler)`\n\nRegisters a **Server-Sent Events (SSE)** route handler for the given path.\nSSE is a simple and efficient way to send real-time updates from the server to the browser over HTTP using a single, long-lived connection.\n\n---\n\n## âœ… Syntax\n\n```ts\napp.sse(path: string, handler: (ctx: Context) => Promise<Response> | Response)\n```\n\n---\n\n## ğŸ§  Description\n\n* Registers an HTTP `GET` route at the given `path`.\n* Sends **real-time updates** to connected clients via a persistent HTTP connection using the `text/event-stream` MIME type.\n* Automatically handles connection cleanup when the client disconnects.\n\n---\n\n## ğŸ“¥ Parameters\n\n| Name      | Type       | Description                                     |\n| --------- | ---------- | ----------------------------------------------- |\n| `path`    | `string`   | The route path (e.g. `/events`)                 |\n| `handler` | `Function` | An async or sync function that returns a stream |\n\n---\n\n## ğŸ“¤ Returns\n\n* The route is registered to send `ReadableStream` data in SSE-compliant format (`data: ...\\n\\n`).\n* The handler must return a response with appropriate headers.\n\n---\n\n## ğŸ“¦ Headers set (automatically or manually)\n\n```http\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\nYou can override or customize headers inside `ctx.send(stream, { headers })`.\n\n---\n\n## ğŸ“‹ Example\n\n```ts\nfunction encoder(str: string) {\n  return new TextEncoder().encode(str);\n}\n\napp.sse(\"/events\", (ctx) => {\n  const stream = new ReadableStream({\n    start(controller) {\n      // Initial event\n      controller.enqueue(encoder(\"data: Connected\\n\\n\"));\n\n      // Periodic event\n      const interval = setInterval(() => {\n        const message = `data: ${new Date().toISOString()}\\n\\n`;\n        controller.enqueue(encoder(message));\n      }, 2000);\n\n      // Cleanup on client disconnect\n      ctx.rawRequest?.signal?.addEventListener(\"abort\", () => {\n        clearInterval(interval);\n        controller.close()\n      });\n    },\n  });\n\n  return ctx.send(stream, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n  });\n});\n```\n\n---\n\n## ğŸ§ª Test Client (HTML)\n\n```ts\napp.get(\"/\", async (ctx) => {\n  return ctx.html`\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>SSE Demo</title>\n  </head>\n  <body>\n    <h1>Server-Sent Events</h1>\n    <pre id=\"output\"></pre>\n    <script>\n      const output = document.getElementById(\"output\");\n      const eventSource = new EventSource(\"/events\");\n\n      eventSource.onmessage = (event) => {\n        output.textContent += event.data + \"\\\\n\";\n      };\n\n      eventSource.onerror = () => {\n        output.textContent += \"ğŸ”´ Connection lost\\\\n\";\n      };\n    </script>\n  </body>\n</html>\n  `;\n});\n```\n\n---\n\n## ğŸš¨ Notes\n\n* Only supports `GET` method (per SSE spec).\n* Requires `ReadableStream` and `TextEncoder`, which are supported in Node.js 18+, Bun, and modern runtimes.\n* Don't forget to clear intervals/timers on disconnect via `ctx.rawRequest?.signal`.\n\n---\n\n## âœ… Ideal Use Cases\n\n* Live notifications\n* Real-time clock or status updates\n* Live logs / debugging streams\n* Chat message delivery (broadcast style)\n\n---\n\n## ğŸ§© Coming Soon Ideas (optional for docs)\n\n> You can optionally add features like:\n\n* `ctx.pushSSE(data)` helper\n* Broadcasting across multiple connections\n* Named event support (`event: custom\\n`)\n\n---\n\n## ğŸ“˜ Summary\n\n`app.sse()` is the easiest way to build **real-time push updates** over HTTP with zero frontend dependencies.\n\n---\n"
    }
  ]
}