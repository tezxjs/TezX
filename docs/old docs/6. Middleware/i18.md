# ðŸŒ TezX i18n Middleware

## Overview

`i18n` middleware adds **multi-language (internationalization)** support to TezX applications.
It automatically detects the user's preferred language, loads translation files, caches them (in-memory or via custom adapter), and provides a simple translation function (`ctx.t`) inside every request.

---

## âš™ï¸ Basic Usage

```ts
import { i18n } from "tezx/middleware";

app.use(
  i18n({
    loadTranslations: async (lang) => import(`./locales/${lang}.json`),
    detectLanguage: (ctx) => ctx.req.query.lang || "en",
    defaultLanguage: "en",
  })
);
```

Now every request will have:

```ts
ctx.t("greeting.hello"); // returns "Hello"
ctx.t("user.welcome", { name: "Rakibul" }); // interpolates variables
```

---

## ðŸ§  How It Works

| Step | Description                                                                |
| ---- | -------------------------------------------------------------------------- |
| 1ï¸âƒ£  | Detects the preferred language using `detectLanguage(ctx)`                 |
| 2ï¸âƒ£  | Loads translations dynamically via `loadTranslations(language)`            |
| 3ï¸âƒ£  | Optionally caches translations in memory or a custom adapter (e.g., Redis) |
| 4ï¸âƒ£  | Attaches a translation helper (`ctx.t`) to the context                     |
| 5ï¸âƒ£  | Interpolates variables in messages like `{{name}}`                         |
| 6ï¸âƒ£  | Fallbacks to `defaultLanguage` if translation missing                      |

---

## ðŸ§© Example â€” Simple Setup

### Directory structure

```bash
/locales
  â”œâ”€â”€ en.json
  â””â”€â”€ bn.json
```

### en.json

```json
{
  "greeting": {
    "hello": "Hello",
    "welcome": "Welcome, {{name}}!"
  }
}
```

### Middleware setup

```ts
app.use(
  i18n({
    loadTranslations: async (lang) => import(`./locales/${lang}.json`),
    detectLanguage: (ctx) => ctx.req.query.lang || "en",
    defaultLanguage: "en"
  })
);
```

### Usage in route

```ts
router.get("/hi", (ctx) => {
  return ctx.t("greeting.welcome", { name: "Rakibul" });
});
```

âœ… Output:
If `?lang=en` â†’ `"Welcome, Rakibul!"`
If `?lang=bn` â†’ `"à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®, Rakibul!"`

---

## âš¡ Caching

The middleware supports **translation caching** to improve performance.

### ðŸ§  In-memory cache (default)

```ts
app.use(
  i18n({
    loadTranslations,
    detectLanguage,
    cacheTranslations: true, // enables Map-based local cache
  })
);
```

### ðŸ’¾ External cache (Redis, Memcached, etc.)

You can implement your own cache adapter by extending `I18nCacheAdapter`.

```ts
const redisCache = {
  async get(lang) {
    const data = await redis.get(`i18n:${lang}`);
    return data ? JSON.parse(data) : null;
  },
  async set(lang, data) {
    await redis.set(`i18n:${lang}`, JSON.stringify(data), "PX", data.expiresAt - Date.now());
  },
  async delete(lang) {
    await redis.del(`i18n:${lang}`);
  },
};

app.use(
  i18n({
    loadTranslations,
    detectLanguage,
    cacheTranslations: true,
    cacheStorage: redisCache,
  })
);
```

---

## ðŸ§© Options Reference (Full)

| Option                       | Type                                        | Default                | Description                                                     |
| ---------------------------- | ------------------------------------------- | ---------------------- | --------------------------------------------------------------- |
| **`loadTranslations`**       | `(lang: string) => Promise<TranslationMap>` | â€”                      | Function to load translations dynamically (from JSON, DB, etc.) |
| **`detectLanguage`**         | `(ctx: Context) => string`                  | â€”                      | Determines which language to use for the request                |
| **`defaultLanguage`**        | `string`                                    | `"en"`                 | Fallback language if requested language unavailable             |
| **`defaultCacheDuration`**   | `number`                                    | `3600000` (1 hour)     | How long cached translations stay valid                         |
| **`translationFunctionKey`** | `string`                                    | `"t"`                  | Property name for translator function attached to `ctx`         |
| **`formatMessage`**          | `(msg, vars) => string`                     | Interpolates `{{var}}` | Custom variable interpolation logic                             |
| **`isCacheValid`**           | `(cached, lang) => boolean`                 | Expiry check           | Determines if cache entry is still valid                        |
| **`cacheTranslations`**      | `boolean`                                   | `false`                | Enables or disables caching                                     |
| **`cacheStorage`**           | `I18nCacheAdapter`                          | `null`                 | Custom cache (e.g., Redis, file system, DB)                     |

---

## ðŸ§© Example â€” Custom Format Function

```ts
app.use(
  i18n({
    loadTranslations,
    detectLanguage,
    formatMessage: (msg, vars) =>  msg.replace(/\{(\w+)\}/g, (_, k) => vars?.[k] ?? ""),
  })
);
```

âœ… `"Hello {name}" â†’ "Hello Rakibul"`

---

## ðŸ§© Example â€” Custom Language Detection

You can detect language from:

* Query params (`?lang=bn`)
* Headers (`Accept-Language`)
* Cookies (`ctx.cookies.get('lang')`)

```ts
detectLanguage: (ctx) =>
  ctx.req.query.lang || ctx.cookies.get("lang") || ctx.req.headers["accept-language"]?.split(",")[0] || "en"
```

---

## ðŸ§© Example â€” File-based Cache Adapter

For servers without Redis:

```ts
import fs from "fs/promises";
import path from "path";

const fileCache = {
  async get(lang) {
    const file = path.join("./cache", `${lang}.json`);
    try {
      const content = JSON.parse(await fs.readFile(file, "utf-8"));
      return content;
    } catch {
      return null;
    }
  },
  async set(lang, data) {
    const file = path.join("./cache", `${lang}.json`);
    await fs.mkdir("./cache", { recursive: true });
    await fs.writeFile(file, JSON.stringify(data), "utf-8");
  },
  async delete(lang) {
    const file = path.join("./cache", `${lang}.json`);
    await fs.unlink(file).catch(() => {});
  },
};
```

Then plug it in:

```ts
app.use(
  i18n({
    loadTranslations,
    detectLanguage,
    cacheTranslations: true,
    cacheStorage: fileCache,
  })
);
```

---

## ðŸ§© Example â€” Custom Cache Validation

```ts
isCacheValid: (cached, lang) => {
  // Reload if file modified recently
  const file = `./locales/${lang}.json`;
  const lastModified = fs.statSync(file).mtimeMs;
  return cached.expiresAt > Date.now() && cached.expiresAt > lastModified;
}
```

---

## ðŸ§© Error Handling

If any error occurs during translation loading, caching, or formatting,
the middleware throws a structured `TezXError`:

```ts
try {
  await next();
} catch (err) {
  if (err instanceof TezXError) {
    console.error("i18n failed:", err.message);
  }
}
```

---

## ðŸ§© Example â€” Using Translations in Templates or API

```ts
router.get("/about", (ctx) => {
  return {
    title: ctx.t("page.about.title"),
    description: ctx.t("page.about.description"),
  };
});
```

---
